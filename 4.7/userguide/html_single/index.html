<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>RESTEasy JAX-RS</title><link rel="stylesheet" type="text/css" href="docbook.css"/><link rel="stylesheet" type="text/css" href="css/jbossorg.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body><div class="book" id="d5e1"><div class="titlepage"><div><p id="title"><a href="http://www.jboss.org" class="site_href"><strong>JBoss.org</strong></a><a href="http://docs.jboss.org/" class="doc_href"><strong>Community Documentation</strong></a></p><div><h1 class="title">RESTEasy JAX-RS</h1></div><div><h2 class="subtitle">RESTFul Web Services for Java</h2></div><div><p class="releaseinfo">4.7.10.Final</p></div></div><hr/></div><div class="toc"><ul class="toc"><li><span class="preface"><a href="#preface">Preface</a></span></li><li><span class="chapter"><a href="#Overview">1. Overview</a></span></li><li><span class="chapter"><a href="#license">2. License</a></span></li><li><span class="chapter"><a href="#Installation_Configuration">3. Installation/Configuration</a></span><ul><li><span class="section"><a href="#resteasy_modules_in_wildfly">3.1. RESTEasy modules in WildFly</a></span><ul><li><span class="section"><a href="#other_resteasy_modules">3.1.1. Other RESTEasy modules</a></span></li><li><span class="section"><a href="#upgrading-wildfly">3.1.2. Upgrading RESTEasy within WildFly</a></span></li></ul></li><li><span class="section"><a href="#d5e123">3.2. Deploying a RESTEasy application to WildFly</a></span></li><li><span class="section"><a href="#standalone_resteasy">3.3. Deploying to other servlet containers</a></span><ul><li><span class="section"><a href="#d5e155">3.3.1. Servlet 3.0 containers</a></span></li><li><span class="section"><a href="#d5e161">3.3.2. Older servlet containers</a></span></li></ul></li><li><span class="section"><a href="#microprofile_config">3.4. Configuration</a></span><ul><li><span class="section"><a href="#resteasy_microprofile_config">3.4.1. RESTEasy with MicroProfile Config</a></span></li><li><span class="section"><a href="#d5e240">3.4.2. Using pure MicroProfile Config</a></span></li><li><span class="section"><a href="#d5e259">3.4.3. Using RESTEasy's extension of MicroProfile Config</a></span></li><li><span class="section"><a href="#configuring_mp_config">3.4.4. Configuring MicroProfile Config</a></span></li><li><span class="section"><a href="#classic_config">3.4.5. RESTEasy's classic configuration mechanism</a></span></li><li><span class="section"><a href="#overriding_config">3.4.6. Overriding RESTEasy's configuration mechanism</a></span></li></ul></li><li><span class="section"><a href="#configuration_switches">3.5. Configuration switches</a></span></li><li><span class="section"><a href="#javax.ws.rs.core.Application">3.6. javax.ws.rs.core.Application</a></span></li><li><span class="section"><a href="#listener">3.7. RESTEasy as a ServletContextListener</a></span></li><li><span class="section"><a href="#filter">3.8. RESTEasy as a Servlet Filter</a></span></li><li><span class="section"><a href="#d5e474">3.9. Client side</a></span></li></ul></li><li><span class="chapter"><a href="#Using_Path">4. Using @Path and @GET, @POST, etc.</a></span><ul><li><span class="sect1"><a href="#_Path_and_regular_expression_mappings">4.1. @Path and regular expression mappings</a></span></li></ul></li><li><span class="chapter"><a href="#_PathParam">5. @PathParam</a></span><ul><li><span class="sect1"><a href="#Advanced__PathParam_and_Regular_Expressions">5.1. Advanced @PathParam and Regular Expressions</a></span></li><li><span class="sect1"><a href="#_PathParam_and_PathSegment">5.2. @PathParam and PathSegment</a></span></li></ul></li><li><span class="chapter"><a href="#_QueryParam">6. @QueryParam</a></span></li><li><span class="chapter"><a href="#_HeaderParam">7. @HeaderParam</a></span><ul><li><span class="section"><a href="#d5e618">7.1. <code class="classname">HeaderDelegate</code>s</a></span></li></ul></li><li><span class="chapter"><a href="#LinkHeader">8. Linking resources</a></span><ul><li><span class="section"><a href="#d5e644">8.1. Link Headers</a></span></li><li><span class="section"><a href="#d5e649">8.2. Atom links in the resource representations</a></span><ul><li><span class="section"><a href="#d5e656">8.2.1. Configuration</a></span></li><li><span class="section"><a href="#d5e671">8.2.2. Your first links injected</a></span></li><li><span class="section"><a href="#d5e692">8.2.3. Customising how the Atom links are serialised</a></span></li><li><span class="section"><a href="#d5e698">8.2.4. Specifying which JAX-RS methods are tied to which resources</a></span></li><li><span class="section"><a href="#d5e763">8.2.5. Specifying path parameter values for URI templates</a></span></li><li><span class="section"><a href="#d5e837">8.2.6. Securing entities</a></span></li><li><span class="section"><a href="#d5e862">8.2.7. Extending the UEL context</a></span></li><li><span class="section"><a href="#d5e878">8.2.8. Resource facades</a></span></li></ul></li></ul></li><li><span class="chapter"><a href="#_MatrixParam">9. @MatrixParam</a></span></li><li><span class="chapter"><a href="#_CookieParam">10. @CookieParam</a></span></li><li><span class="chapter"><a href="#_FormParam">11. @FormParam</a></span></li><li><span class="chapter"><a href="#_Form">12. @Form</a></span></li><li><span class="chapter"><a href="#_NewParam">13. Improved <code class="code">@…Param</code> annotations</a></span></li><li><span class="chapter"><a href="#_OptionalParam">14. Optional parameter types</a></span></li><li><span class="chapter"><a href="#_DefaultValue">15. @DefaultValue</a></span></li><li><span class="chapter"><a href="#_Encoded_and_encoding">16. @Encoded and encoding</a></span></li><li><span class="chapter"><a href="#_Context">17. @Context</a></span></li><li><span class="chapter"><a href="#JAX-RS_Resource_Locators_and_Sub_Resources">18. JAX-RS Resource Locators and Sub Resources</a></span></li><li><span class="chapter"><a href="#Resources_Metadata">19. Resources metadata configuration</a></span></li><li><span class="chapter"><a href="#JAX-RS_Content_Negotiation">20. JAX-RS Content Negotiation</a></span><ul><li><span class="sect1"><a href="#media_mappings">20.1. URL-based negotiation</a></span></li><li><span class="sect1"><a href="#param_media_mappings">20.2. Query String Parameter-based negotiation</a></span></li></ul></li><li><span class="chapter"><a href="#Content_Marshalling_Providers">21. Content Marshalling/Providers</a></span><ul><li><span class="sect1"><a href="#Default_Providers_and_default_JAX-RS_Content_Marshalling">21.1. Default Providers and default JAX-RS Content Marshalling</a></span></li><li><span class="sect1"><a href="#Content_Marshalling_with__Provider_classes">21.2. Content Marshalling with @Provider classes</a></span></li><li><span class="sect1"><a href="#MessageBodyWorkers">21.3. Providers Utility Class</a></span></li><li><span class="sect1"><a href="#Configuring_Document_Marshalling">21.4. Configuring Document Marshalling</a></span></li><li><span class="sect1"><a href="#Text_media_types">21.5. Text media types and character sets</a></span></li></ul></li><li><span class="chapter"><a href="#Built_in_JAXB_providers">22. JAXB providers</a></span><ul><li><span class="sect1"><a href="#decorators">22.1. JAXB Decorators</a></span></li><li><span class="sect1"><a href="#Pluggable_JAXBContext_s_with_ContextResolvers">22.2. Pluggable JAXBContext's with ContextResolvers</a></span></li><li><span class="sect1"><a href="#JAXB_+_XML_provider">22.3. JAXB + XML provider</a></span><ul><li><span class="sect2"><a href="#XmlHeader">22.3.1. @XmlHeader and @Stylesheet</a></span></li></ul></li><li><span class="sect1"><a href="#JAXB_+_JSON_provider">22.4. JAXB + JSON provider</a></span></li><li><span class="sect1"><a href="#JAXB_+_FastinfoSet_provider">22.5. JAXB + FastinfoSet provider</a></span></li><li><span class="sect1"><a href="#JAXB_Collections">22.6. Arrays and Collections of JAXB Objects</a></span><ul><li><span class="sect2"><a href="#collections_on_client">22.6.1. Retrieving Collections on the client side</a></span></li><li><span class="sect2"><a href="#json_list">22.6.2. JSON and JAXB Collections/arrays</a></span></li></ul></li><li><span class="sect1"><a href="#JAXB_Map">22.7. Maps of JAXB Objects</a></span><ul><li><span class="sect2"><a href="#maps_client_side">22.7.1. Retrieving Maps on the client side</a></span></li><li><span class="sect2"><a href="#json_map">22.7.2. JSON and JAXB maps</a></span></li></ul></li><li><span class="sect1"><a href="#JAXB_INTERFACES">22.8. Interfaces, Abstract Classes, and JAXB</a></span></li><li><span class="sect1"><a href="#configuration">22.9. Configurating JAXB Marshalling</a></span></li></ul></li><li><span class="chapter"><a href="#Atom">23. RESTEasy Atom Support</a></span><ul><li><span class="sect1"><a href="#resteasy_atom">23.1. RESTEasy Atom API and Provider</a></span></li><li><span class="sect1"><a href="#jaxb_atom">23.2. Using JAXB with the Atom Provider</a></span></li></ul></li><li><span class="chapter"><a href="#json">24. JSON Support via Jackson</a></span><ul><li><span class="sect1"><a href="#d5e1441">24.1. Using Jackson 1.9.x Outside of WildFly</a></span></li><li><span class="sect1"><a href="#d5e1445">24.2. Using Jackson 1.9.x Inside WildFly 8</a></span></li><li><span class="sect1"><a href="#d5e1449">24.3. Using Jackson 2 Outside of WildFly</a></span></li><li><span class="sect1"><a href="#d5e1453">24.4. Using Jackson 2 Inside WildFly 9 and above</a></span></li><li><span class="sect1"><a href="#d5e1457">24.5. Additional RESTEasy Specifics</a></span></li><li><span class="sect1"><a href="#JSONP_Support">24.6. JSONP Support</a></span></li><li><span class="sect1"><a href="#Jackson_JSON_Decorator">24.7. Jackson JSON Decorator</a></span></li><li><span class="sect1"><a href="#JSON_Filter_Support">24.8. JSON Filter Support</a></span></li><li><span class="sect1"><a href="#Polymorphic_Typing_deserialization">24.9. Polymorphic Typing deserialization</a></span></li></ul></li><li><span class="chapter"><a href="#json-p">25. JSON Support via Java EE 7 JSON-P API</a></span></li><li><span class="chapter"><a href="#Multipart">26. Multipart Providers</a></span><ul><li><span class="section"><a href="#multipart_mixed_group">26.1. Multipart/mixed</a></span><ul><li><span class="section"><a href="#multipart_output">26.1.1. Writing multipart/mixed messages</a></span></li><li><span class="section"><a href="#MultipartInput">26.1.2. Reading multipart/mixed messages</a></span></li><li><span class="section"><a href="#Simple_mulitpart_message_example">26.1.3. Simple multipart/mixed message example</a></span></li><li><span class="section"><a href="#message_with_GenericType_example">26.1.4. Multipart/mixed message with GenericType example</a></span></li><li><span class="section"><a href="#multipart_list_example">26.1.5. java.util.List with multipart/mixed data example</a></span></li></ul></li><li><span class="section"><a href="#multipart_related_group">26.2. Multipart/related</a></span><ul><li><span class="section"><a href="#Writing_multipart_related">26.2.1. Writing multipart/related messages</a></span></li><li><span class="section"><a href="#Reading_multipart_related">26.2.2. Reading multipart/related messages</a></span></li><li><span class="section"><a href="#multipart_related_example">26.2.3. Multipart/related message example</a></span></li><li><span class="section"><a href="#XML-binary_Optimized_Packaging">26.2.4. XML-binary Optimized Packaging (XOP)</a></span></li><li><span class="section"><a href="#XopWithMultipartRelated_return_object_example">26.2.5. @XopWithMultipartRelated return object example</a></span></li><li><span class="section"><a href="#XopWithMultipartRelated_input_parameter_example">26.2.6. @XopWithMultipartRelated input parameter example</a></span></li></ul></li><li><span class="section"><a href="#multipart_formData_group">26.3. Multipart/form-data</a></span><ul><li><span class="section"><a href="#Writing_multipart_formData">26.3.1. Writing multipart/form-data messages</a></span></li><li><span class="section"><a href="#Reading_multipart_formData">26.3.2. Reading multipart/form-data messages</a></span></li><li><span class="section"><a href="#simple_multipart_formData_example">26.3.3. Simple multipart/form-data message example</a></span></li><li><span class="section"><a href="#Map_with_multipart_formData">26.3.4. java.util.Map with multipart/form-data</a></span></li><li><span class="section"><a href="#Multipart_FormData_Output">26.3.5. Multipart/form-data java.util.Map as method return type</a></span></li><li><span class="section"><a href="#multipartform_annotation">26.3.6. @MultipartForm and POJOs</a></span></li></ul></li><li><span class="section"><a href="#multipart_parsing_note">26.4. Note about multipart parsing and working with other frameworks</a></span></li><li><span class="section"><a href="#multipart_overwrite_default_content_type">26.5. Overwriting the default fallback content type for multipart messages</a></span></li><li><span class="section"><a href="#multipart_overwrite_content_type">26.6. Overwriting the content type for multipart messages</a></span></li><li><span class="section"><a href="#multipart_overwrite_default_charset">26.7. Overwriting the default fallback charset for multipart messages</a></span></li></ul></li><li><span class="chapter"><a href="#JAX-RS_2.1_additions">27. JAX-RS 2.1 Additions</a></span><ul><li><span class="sect1"><a href="#d5e1759">27.1. <code class="code">CompletionStage</code> support</a></span></li><li><span class="sect1"><a href="#d5e1769">27.2. Reactive Clients API</a></span></li><li><span class="sect1"><a href="#SSE-Server">27.3. Server-Sent Events (SSE)</a></span><ul><li><span class="sect2"><a href="#d5e1778">27.3.1. SSE Server</a></span></li><li><span class="sect2"><a href="#d5e1787">27.3.2. SSE Broadcasting</a></span></li><li><span class="sect2"><a href="#d5e1793">27.3.3. SSE Client</a></span></li></ul></li><li><span class="sect1"><a href="#d5e1799">27.4. Java API for JSON Binding</a></span></li><li><span class="sect1"><a href="#d5e1810">27.5. JSON Patch and JSON Merge Patch</a></span></li></ul></li><li><span class="chapter"><a href="#StringConverter">28. String marshalling for String based @*Param</a></span><ul><li><span class="sect1"><a href="#d5e1826">28.1. Simple conversion</a></span></li><li><span class="sect1"><a href="#d5e1839">28.2. ParamConverter</a></span></li><li><span class="sect1"><a href="#d5e1857">28.3. StringParameterUnmarshaller</a></span></li><li><span class="sect1"><a href="#d5e1883">28.4. Collections</a></span><ul><li><span class="sect2"><a href="#d5e1907">28.4.1. @QueryParam</a></span></li><li><span class="sect2"><a href="#d5e1915">28.4.2. @MatrixParam</a></span></li><li><span class="sect2"><a href="#d5e1927">28.4.3. @HeaderParam</a></span></li><li><span class="sect2"><a href="#d5e1936">28.4.4. @CookieParam</a></span></li><li><span class="sect2"><a href="#d5e1944">28.4.5. @PathParam</a></span></li></ul></li><li><span class="sect1"><a href="#d5e1960">28.5. Extension to <code class="classname">ParamConverter</code> semantics</a></span></li><li><span class="sect1"><a href="#d5e1996">28.6. Default multiple valued <code class="classname">ParamConverter</code></a></span></li></ul></li><li><span class="chapter"><a href="#Responses_using_javax.ws.rs.core.Response">29. Responses using javax.ws.rs.core.Response</a></span></li><li><span class="chapter"><a href="#ExceptionHandling">30. Exception Handling</a></span><ul><li><span class="sect1"><a href="#ExceptionMappers">30.1. Exception Mappers</a></span></li><li><span class="sect1"><a href="#builtinException">30.2. RESTEasy Built-in Internally-Thrown Exceptions</a></span></li><li><span class="sect1"><a href="#ResteasyWebApplicationException">30.3. Resteasy WebApplicationExceptions</a></span></li><li><span class="sect1"><a href="#overring_resteasy_exceptions">30.4. Overriding RESTEasy Builtin Exceptions</a></span></li></ul></li><li><span class="chapter"><a href="#Configuring_Individual_JAX-RS_Resource_Beans">31. Configuring Individual JAX-RS Resource Beans</a></span></li><li><span class="chapter"><a href="#gzip">32. Content encoding</a></span><ul><li><span class="sect1"><a href="#d5e2188">32.1. GZIP Compression/Decompression</a></span><ul><li><span class="sect2"><a href="#configuring">32.1.1. Configuring GZIP compression / decompression</a></span></li></ul></li><li><span class="sect1"><a href="#d5e2232">32.2. General content encoding</a></span></li></ul></li><li><span class="chapter"><a href="#d5e2268">33. CORS</a></span></li><li><span class="chapter"><a href="#ContentRange">34. Content-Range Support</a></span></li><li><span class="chapter"><a href="#Cache_NoCache_CacheControl">35. RESTEasy Caching Features</a></span><ul><li><span class="sect1"><a href="#Cache_Annotation">35.1. @Cache and @NoCache Annotations</a></span></li><li><span class="sect1"><a href="#client_cache">35.2. Client "Browser" Cache</a></span></li><li><span class="sect1"><a href="#server_cache">35.3. Local Server-Side Response Cache</a></span></li><li><span class="sect1"><a href="#Http_Precondition">35.4. HTTP preconditions</a></span></li></ul></li><li><span class="chapter"><a href="#Interceptors">36. Filters and Interceptors</a></span><ul><li><span class="sect1"><a href="#d5e2333">36.1. Server Side Filters</a></span><ul><li><span class="sect2"><a href="#d5e2338">36.1.1. Asynchronous filters</a></span></li></ul></li><li><span class="sect1"><a href="#d5e2368">36.2. Client Side Filters</a></span></li><li><span class="sect1"><a href="#d5e2372">36.3. Reader and Writer Interceptors</a></span></li><li><span class="sect1"><a href="#d5e2378">36.4. Per Resource Method Filters and Interceptors</a></span></li><li><span class="sect1"><a href="#d5e2382">36.5. Ordering</a></span></li></ul></li><li><span class="chapter"><a href="#Asynchronous_HTTP_Request_Processing">37. Asynchronous HTTP Request Processing</a></span><ul><li><span class="sect1"><a href="#d5e2388">37.1. Using the <code class="code">@Suspended</code> annotation</a></span></li><li><span class="sect1"><a href="#d5e2403">37.2. Using Reactive return types</a></span></li><li><span class="sect1"><a href="#d5e2417">37.3. Asynchronous filters</a></span></li><li><span class="sect1"><a href="#Asynchronous_IO">37.4. Asynchronous IO</a></span></li></ul></li><li><span class="chapter"><a href="#async_job_service">38. Asynchronous Job Service</a></span><ul><li><span class="sect1"><a href="#async_job">38.1. Using Async Jobs</a></span></li><li><span class="sect1"><a href="#oneway">38.2. Oneway: Fire and Forget</a></span></li><li><span class="sect1"><a href="#async_job_setup">38.3. Setup and Configuration</a></span></li></ul></li><li><span class="chapter"><a href="#Async_Injection">39. Asynchronous Injection</a></span><ul><li><span class="sect1"><a href="#ContextInjector_Interface">39.1. org.jboss.resteasy.spi.ContextInjector Interface</a></span></li><li><span class="sect1"><a href="#Single_foo_example">39.2. Single&lt;Foo&gt; Example</a></span></li><li><span class="sect1"><a href="#injectory_with_annotations_example">39.3. Async Injector With Annotations Example</a></span></li></ul></li><li><span class="chapter"><a href="#Reactive">40. Reactive programming support</a></span><ul><li><span class="sect1"><a href="#d5e2525">40.1. CompletionStage</a></span></li><li><span class="sect1"><a href="#d5e2565">40.2. CompletionStage in JAX-RS</a></span></li><li><span class="sect1"><a href="#d5e2613">40.3. Beyond CompletionStage</a></span></li><li><span class="sect1"><a href="#d5e2644">40.4. Pluggable reactive types: RxJava 2 in RESTEasy</a></span></li><li><span class="sect1"><a href="#d5e2843">40.5. Proxies</a></span></li><li><span class="sect1"><a href="#d5e2857">40.6. Adding extensions</a></span></li></ul></li><li><span class="chapter"><a href="#RESTEasy_Embedded_Container">41. Embedded Containers</a></span><ul><li><span class="section"><a href="#d5e2935">41.1. Undertow</a></span></li><li><span class="section"><a href="#d5e2939">41.2. Sun JDK HTTP Server</a></span></li><li><span class="section"><a href="#d5e2946">41.3. Netty</a></span></li><li><span class="section"><a href="#d5e2952">41.4. Reactor-Netty</a></span></li><li><span class="section"><a href="#d5e2958">41.5. Vert.x</a></span></li><li><span class="section"><a href="#d5e2974">41.6. EmbeddedJaxrsServer</a></span></li></ul></li><li><span class="chapter"><a href="#RESTEasy_Server-side_Mock_Framework">42. Server-side Mock Framework</a></span></li><li><span class="chapter"><a href="#Securing_JAX-RS_and_RESTeasy">43. Securing JAX-RS and RESTEasy</a></span></li><li><span class="chapter"><a href="#d5e3012">44. JSON Web Signature and Encryption (JOSE-JWT)</a></span><ul><li><span class="section"><a href="#d5e3015">44.1. JSON Web Signature (JWS)</a></span></li><li><span class="section"><a href="#d5e3021">44.2. JSON Web Encryption (JWE)</a></span></li></ul></li><li><span class="chapter"><a href="#signature">45. Doseta Digital Signature Framework</a></span><ul><li><span class="section"><a href="#d5e3083">45.1. Maven settings</a></span></li><li><span class="section"><a href="#d5e3088">45.2. Signing API</a></span><ul><li><span class="section"><a href="#d5e3094">45.2.1. @Signed annotation</a></span></li></ul></li><li><span class="section"><a href="#d5e3102">45.3. Signature Verification API</a></span><ul><li><span class="section"><a href="#d5e3111">45.3.1. Annotation-based verification</a></span></li></ul></li><li><span class="section"><a href="#d5e3119">45.4. Managing Keys via a KeyRepository</a></span><ul><li><span class="section"><a href="#d5e3122">45.4.1. Create a KeyStore</a></span></li><li><span class="section"><a href="#d5e3129">45.4.2. Configure Restreasy to use the KeyRepository</a></span></li><li><span class="section"><a href="#d5e3143">45.4.3. Using DNS to Discover Public Keys</a></span></li></ul></li></ul></li><li><span class="chapter"><a href="#d5e3157">46. Body Encryption and Signing via SMIME</a></span><ul><li><span class="section"><a href="#d5e3160">46.1. Maven settings</a></span></li><li><span class="section"><a href="#d5e3165">46.2. Message Body Encryption</a></span></li><li><span class="section"><a href="#d5e3176">46.3. Message Body Signing</a></span></li><li><span class="section"><a href="#d5e3187">46.4. application/pkcs7-signature</a></span></li></ul></li><li><span class="chapter"><a href="#RESTEasy_EJB_Integration">47. EJB Integration</a></span></li><li><span class="chapter"><a href="#RESTEasy_Spring_Integration">48. Spring Integration</a></span><ul><li><span class="section"><a href="#BasicIntegration">48.1. Basic Integration</a></span></li><li><span class="section"><a href="#CustomizedConfiguration">48.2. Customized Configuration</a></span></li><li><span class="section"><a href="#SpringMVC">48.3. Spring MVC Integration</a></span></li><li><span class="section"><a href="#SpringUndertow">48.4. Undertow Embedded Spring Container</a></span></li><li><span class="section"><a href="#SpringWebAnnotation">48.5. Processing Spring Web REST annotations in RESTEasy</a></span></li><li><span class="section"><a href="#SpringBootStarter">48.6. Spring Boot starter</a></span></li><li><span class="section"><a href="#SpringUpgradeInWildfly">48.7. Upgrading in WildFly</a></span></li></ul></li><li><span class="chapter"><a href="#CDI">49. CDI Integration</a></span><ul><li><span class="section"><a href="#d5e3425">49.1. Using CDI beans as JAX-RS components</a></span></li><li><span class="section"><a href="#d5e3432">49.2. Default scopes</a></span></li><li><span class="section"><a href="#d5e3444">49.3. Configuration within WildFly</a></span></li><li><span class="section"><a href="#d5e3447">49.4. Configuration with different distributions</a></span></li></ul></li><li><span class="chapter"><a href="#Guice1">50. Guice 3.0 Integration</a></span><ul><li><span class="section"><a href="#d5e3465">50.1. Request Scope</a></span></li><li><span class="section"><a href="#d5e3469">50.2. Binding JAX-RS utilities</a></span></li><li><span class="section"><a href="#d5e3472">50.3. Configuring Stage</a></span></li><li><span class="section"><a href="#d5e3476">50.4. Custom Injector creation</a></span></li></ul></li><li><span class="chapter"><a href="#RESTEasy_Client_Framework">51. RESTEasy Client API</a></span><ul><li><span class="section"><a href="#d5e3485">51.1. JAX-RS 2.0 Client API</a></span></li><li><span class="section"><a href="#proxies">51.2. RESTEasy Proxy Framework</a></span><ul><li><span class="section"><a href="#Custom_client-side_responses">51.2.1. Abstract Responses</a></span></li><li><span class="section"><a href="#Response_proxies">51.2.2. Response proxies</a></span></li><li><span class="section"><a href="#ClientURI">51.2.3. Giving client proxy an ad hoc URI</a></span></li><li><span class="section"><a href="#Sharing_interfaces">51.2.4. Sharing an interface between client and server</a></span></li></ul></li><li><span class="section"><a href="#transport_layer">51.3. Apache HTTP Client 4.x and other backends</a></span><ul><li><span class="section"><a href="#http_redirect">51.3.1. HTTP redirect</a></span></li><li><span class="section"><a href="#https">51.3.2. Configuring SSL</a></span></li><li><span class="section"><a href="#http_proxy">51.3.3. HTTP proxy</a></span></li><li><span class="section"><a href="#apache_4_3">51.3.4. Apache HTTP Client 4.3 APIs</a></span></li><li><span class="section"><a href="#apache_asynch">51.3.5. Asynchronous HTTP Request Processing</a></span></li><li><span class="section"><a href="#jetty_client">51.3.6. Jetty Client Engine</a></span></li><li><span class="section"><a href="#vertx_client">51.3.7. Vertx Client Engine</a></span></li><li><span class="section"><a href="#reactor_netty_client">51.3.8. Reactor Netty Client Engine</a></span></li></ul></li></ul></li><li><span class="chapter"><a href="#MicroProfile_Rest_Client">52. MicroProfile Rest Client</a></span><ul><li><span class="sect1"><a href="#d5e3860">52.1. Client proxies</a></span></li><li><span class="sect1"><a href="#d5e3903">52.2. Concepts imported from JAX-RS</a></span></li><li><span class="sect1"><a href="#d5e3936">52.3. Beyond JAX-RS and RESTEasy</a></span></li></ul></li><li><span class="chapter"><a href="#AJAX_Client">53. AJAX Client</a></span><ul><li><span class="section"><a href="#d5e4145">53.1. Generated JavaScript API</a></span><ul><li><span class="section"><a href="#d5e4154">53.1.1. JavaScript API servlet</a></span></li><li><span class="section"><a href="#d5e4158">53.1.2. JavaScript API usage</a></span></li><li><span class="section"><a href="#d5e4212">53.1.3. Work with @Form</a></span></li><li><span class="section"><a href="#d5e4224">53.1.4. MIME types and unmarshalling.</a></span></li><li><span class="section"><a href="#d5e4249">53.1.5. MIME types and marshalling.</a></span></li></ul></li><li><span class="section"><a href="#d5e4278">53.2. Using the JavaScript API to build AJAX queries</a></span><ul><li><span class="section"><a href="#d5e4281">53.2.1. The REST object</a></span></li><li><span class="section"><a href="#d5e4301">53.2.2. The REST.Request class</a></span></li></ul></li><li><span class="section"><a href="#d5e4351">53.3. Caching Features</a></span></li></ul></li><li><span class="chapter"><a href="#WADL">54. RESTEasy WADL Support</a></span><ul><li><span class="section"><a href="#d5e4359">54.1. RESTEasy WADL Support for Servlet Container(Deprecated)</a></span></li><li><span class="section"><a href="#d5e4369">54.2. RESTEasy WADL Support for Servlet Container(Updated)</a></span></li><li><span class="section"><a href="#d5e4383">54.3. RESTEasy WADL support for Sun JDK HTTP Server</a></span></li><li><span class="section"><a href="#d5e4393">54.4. RESTEasy WADL support for Netty Container</a></span></li><li><span class="section"><a href="#d5e4398">54.5. RESTEasy WADL Support for Undertow Container</a></span></li></ul></li><li><span class="chapter"><a href="#Tracing_Feature">55. RESTEasy Tracing Feature</a></span><ul><li><span class="section"><a href="#d5e4411">55.1. Overview</a></span></li><li><span class="section"><a href="#d5e4416">55.2. Tracing Info Mode</a></span></li><li><span class="section"><a href="#d5e4424">55.3. Tracing Info Level</a></span></li><li><span class="section"><a href="#d5e4433">55.4. Basic Usages</a></span></li><li><span class="section"><a href="#d5e4459">55.5. Client Side Tracing Info</a></span></li><li><span class="section"><a href="#d5e4464">55.6. Json Formatted Response</a></span></li><li><span class="section"><a href="#d5e4475">55.7. List Of Tracing Events</a></span></li><li><span class="section"><a href="#d5e4543">55.8. Tracing Example</a></span></li></ul></li><li><span class="chapter"><a href="#Validation">56. Validation</a></span><ul><li><span class="section"><a href="#d5e4576">56.1. Violation reporting</a></span></li><li><span class="section"><a href="#d5e4608">56.2. Validation Service Providers</a></span></li><li><span class="section"><a href="#d5e4626">56.3. Validation Implementations</a></span></li></ul></li><li><span class="chapter"><a href="#I18N">57. Internationalization and Localization</a></span><ul><li><span class="section"><a href="#d5e4637">57.1. Internationalization</a></span></li><li><span class="section"><a href="#d5e4739">57.2. Localization</a></span></li></ul></li><li><span class="chapter"><a href="#Maven_and_RESTEasy">58. Maven and RESTEasy</a></span></li><li><span class="chapter"><a href="#Migration_from_older_versions">59. Migration from older versions</a></span><ul><li><span class="sect1"><a href="#d5e4766">59.1. Migration to RESTEasy 3.0 series</a></span></li><li><span class="sect1"><a href="#Migration_to_RESTEasy_3.1">59.2. Migration to RESTEasy 3.1 series</a></span></li><li><span class="sect1"><a href="#d5e4865">59.3. Migration to RESTEasy 3.5+ series</a></span></li><li><span class="sect1"><a href="#d5e4870">59.4. Migration to RESTEasy 4 series</a></span></li></ul></li><li><span class="chapter"><a href="#REST_BOOKS">60. Books You Can Read</a></span></li></ul></div>

   

   

   <section class="preface" id="preface"><div class="titlepage"><div><div><h1 class="title">Preface</h1></div></div></div>
      
      <p>
         Commercial development support, production support and training for RESTEasy JAX-RS is
         available through JBoss, a division of Red Hat Inc. (see http://www.jboss.com/).
      </p>

      <p>
         In some of the example listings, what is meant to be displayed on one line does not fit
         inside the available page width. These lines have been broken up. A '\' at the end of a
         line means that a break has been introduced to fit in the page, with the following lines
         indented. So:
</p><pre><code class="no-highlight">
Let's pretend to have an extremely \
long line that \
does not fit
This one is short
</code></pre><p>
         Is really:
</p><pre><code class="no-highlight">
Let's pretend to have an extremely long line that does not fit
This one is short
</code></pre><p>
      </p>
   </section>



   <section class="chapter" id="Overview"><div class="titlepage"><div><div><h1 class="title">Chapter 1. Overview</h1></div></div></div>


<p>

JAX-RS 2.0 (JSR-339) and JAX-RS 2.1 (JSR-370), are JCP specifications that provide a Java API for RESTful Web Services over the HTTP protocol.
    RESTEasy is a portable implementation of these specifications which can run in any Servlet container. Tighter
    integration with WildFly application server is also available to make the user experience nicer in that environment.
    RESTEasy also comes with additional features on top of plain JAX-RS functionalities.
</p>
</section>

   <section class="chapter" id="license"><div class="titlepage"><div><div><h1 class="title">Chapter 2. License</h1></div></div></div>
    
    <p>RESTEasy is distributed under the Apache License 2.0. Some dependencies are covered by other open source licenses.
    </p>
</section>

   <section class="chapter" id="Installation_Configuration"><div class="titlepage"><div><div><h1 class="title">Chapter 3. Installation/Configuration</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="section"><a href="#resteasy_modules_in_wildfly">3.1. RESTEasy modules in WildFly</a></span><ul><li><span class="section"><a href="#other_resteasy_modules">3.1.1. Other RESTEasy modules</a></span></li><li><span class="section"><a href="#upgrading-wildfly">3.1.2. Upgrading RESTEasy within WildFly</a></span></li></ul></li><li><span class="section"><a href="#d5e123">3.2. Deploying a RESTEasy application to WildFly</a></span></li><li><span class="section"><a href="#standalone_resteasy">3.3. Deploying to other servlet containers</a></span><ul><li><span class="section"><a href="#d5e155">3.3.1. Servlet 3.0 containers</a></span></li><li><span class="section"><a href="#d5e161">3.3.2. Older servlet containers</a></span></li></ul></li><li><span class="section"><a href="#microprofile_config">3.4. Configuration</a></span><ul><li><span class="section"><a href="#resteasy_microprofile_config">3.4.1. RESTEasy with MicroProfile Config</a></span></li><li><span class="section"><a href="#d5e240">3.4.2. Using pure MicroProfile Config</a></span></li><li><span class="section"><a href="#d5e259">3.4.3. Using RESTEasy's extension of MicroProfile Config</a></span></li><li><span class="section"><a href="#configuring_mp_config">3.4.4. Configuring MicroProfile Config</a></span></li><li><span class="section"><a href="#classic_config">3.4.5. RESTEasy's classic configuration mechanism</a></span></li><li><span class="section"><a href="#overriding_config">3.4.6. Overriding RESTEasy's configuration mechanism</a></span></li></ul></li><li><span class="section"><a href="#configuration_switches">3.5. Configuration switches</a></span></li><li><span class="section"><a href="#javax.ws.rs.core.Application">3.6. javax.ws.rs.core.Application</a></span></li><li><span class="section"><a href="#listener">3.7. RESTEasy as a ServletContextListener</a></span></li><li><span class="section"><a href="#filter">3.8. RESTEasy as a Servlet Filter</a></span></li><li><span class="section"><a href="#d5e474">3.9. Client side</a></span></li></ul></div>
    

    <p>
        RESTEasy is installed and configured in different ways depending on which environment you are running in.
        If you are running in WildFly, RESTEasy is already bundled and integrated completely
        so there is very little you have to do. If you are running in a different environment, there is some manual
        installation and configuration you will have to do.
    </p>

    <section class="section" id="resteasy_modules_in_wildfly"><div class="titlepage"><div><div><h2 class="title">3.1. RESTEasy modules in WildFly</h2></div></div></div>
        
        <p>
            In WildFly, RESTEasy and the JAX-RS API are automatically loaded into your deployment's classpath
            if and only if you are deploying a JAX-RS application (as determined by the presence
            of JAX-RS annotations). However, only some RESTEasy features are automatically loaded. See Table 3.1.
            If you need any of those libraries which are not loaded automatically, you'll have to bring them in
            with a jboss-deployment-structure.xml file in the WEB-INF directory of your WAR file.  Here's an example:
        </p>
        <pre><code class="no-highlight">
&lt;jboss-deployment-structure&gt;
    &lt;deployment&gt;
        &lt;dependencies&gt;
            &lt;module name="org.jboss.resteasy.resteasy-jackson-provider" services="import"/&gt;
        &lt;/dependencies&gt;
    &lt;/deployment&gt;
&lt;/jboss-deployment-structure&gt;</code></pre>
        <p>The <code class="literal">services</code> attribute must be set to "import" for modules that have default providers
            in a META-INF/services/javax.ws.rs.ext.Providers file.
        </p>
        <p>
            To get an idea of which RESTEasy modules are loaded by default when JAX-RS services are deployed, please
            see the table below, which refers to a recent WildFly ditribution patched with the current RESTEasy
            distribution. Clearly, future and unpatched WildFly distributions might differ a bit in terms of modules
            enabled by default, as the container actually controls this too.
        </p>
        <p>
            </p><div class="table" id="d5e30"><div class="table-title">Table 3.1. </div><div class="table-contents">
            <table style="border-collapse: collapse; border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 1px  ; border-bottom: 1px  ; ">
                        Module Name
                    </th><th style="border-right: 1px  ; border-bottom: 1px  ; ">
                        Loaded by Default
                    </th><th style="border-bottom: 1px  ; ">
                        Description
                    </th></tr></thead><tbody><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        org.jboss.resteasy.resteasy-atom-provider
                    </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        yes
                    </td><td style="border-bottom: 1px  ; ">
                        RESTEasy's atom library
                    </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        org.jboss.resteasy.resteasy-cdi
                    </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        yes
                    </td><td style="border-bottom: 1px  ; ">
                        RESTEasy CDI integration
                    </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        org.jboss.resteasy.resteasy-crypto
                    </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        yes
                    </td><td style="border-bottom: 1px  ; ">
                        S/MIME, DKIM, and support for other security formats.
                    </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        org.jboss.resteasy.resteasy-jackson-provider
                    </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        no
                    </td><td style="border-bottom: 1px  ; ">
                        Integration with the JSON parser and object mapper Jackson (deprecated)
                    </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        org.jboss.resteasy.resteasy-jackson2-provider
                    </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        yes
                    </td><td style="border-bottom: 1px  ; ">
                        Integration with the JSON parser and object mapper Jackson 2
                    </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        org.jboss.resteasy.resteasy-jaxb-provider
                    </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        yes
                    </td><td style="border-bottom: 1px  ; ">
                        XML JAXB integration.
                    </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        org.jboss.resteasy.resteasy-jaxrs
                    </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        yes
                    </td><td style="border-bottom: 1px  ; ">
                        Core RESTEasy libraries for server and client.  You will need to include this in your deployment
                        if you are only using JAX-RS client.
                    </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        org.jboss.resteasy.jose-jwt
                    </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        no
                    </td><td style="border-bottom: 1px  ; ">
                        JSON Web Token support.
                    </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        org.jboss.resteasy.resteasy-jsapi
                    </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        yes
                    </td><td style="border-bottom: 1px  ; ">
                        RESTEasy's Javascript API
                    </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        org.jboss.resteasy.resteasy-json-p-provider
                    </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        yes
                    </td><td style="border-bottom: 1px  ; ">
                        JSON parsing API
                    </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        org.jboss.resteasy.resteasy-json-binding-provider
                    </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        yes
                    </td><td style="border-bottom: 1px  ; ">
                        JSON binding API
                    </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        javax.json.bind-api
                    </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        yes
                    </td><td style="border-bottom: 1px  ; ">
                        JSON binding API
                    </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        org.eclipse.yasson
                    </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        yes
                    </td><td style="border-bottom: 1px  ; ">
                        RI implementation of JSON binding API
                    </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        org.jboss.resteasy.resteasy-multipart-provider
                    </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        yes
                    </td><td style="border-bottom: 1px  ; ">
                        Support for multipart formats
                    </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        org.jboss.resteasy.resteasy-spring
                    </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        no
                    </td><td style="border-bottom: 1px  ; ">
                        Spring provider
                    </td></tr><tr><td style="border-right: 1px  ; ">
                        org.jboss.resteasy.resteasy-validator-provider
                    </td><td style="border-right: 1px  ; ">
                        yes
                    </td><td>
                        RESTEasy's interface to Hibernate Bean Validation
                    </td></tr></tbody></table>
            </div></div><p><br class="table-break"/>
        </p>

        <section class="section" id="other_resteasy_modules"><div class="titlepage"><div><div><h3 class="title">3.1.1. Other RESTEasy modules</h3></div></div></div>
        
            <p>
                Not all RESTEasy modules are bundled with WildFly. For example,
                <code class="code">resteasy-fastinfoset-provider</code> and <code class="code">resteasy-wadl</code> are not included among the
                modules listed in <a class="xref" href="#resteasy_modules_in_wildfly" title="3.1. RESTEasy modules in WildFly">Section 3.1, “RESTEasy modules in WildFly”</a>. If you want
                to use them in your application, you can include them in your WAR as you would if you were
                deploying outside of WildFly. See <a class="xref" href="#standalone_resteasy" title="3.3. Deploying to other servlet containers">Section 3.3, “Deploying to other servlet containers”</a> for more information.
        </p>
        </section>
	    <section class="section" id="upgrading-wildfly"><div class="titlepage"><div><div><h3 class="title">3.1.2. Upgrading RESTEasy within WildFly</h3></div></div></div>
	        
	        <p>
	            RESTEasy is bundled with WildFly, but you may want to upgrade RESTEasy in WildFly to the latest version.  The RESTEasy
                distribution comes with a zip file called <code class="code">resteasy-jboss-modules-4.7.10.Final.zip</code>.  Unzip this file
	            within the modules/system/layers/base/ directory of the WildFly distribution.  This will configure WildFly
	            to use new versions of the modules listed in <a class="xref" href="#resteasy_modules_in_wildfly" title="3.1. RESTEasy modules in WildFly">Section 3.1, “RESTEasy modules in WildFly”</a>.
	        </p>
            <p>
                To build the <code class="code">resteasy-jboss-modules-4.7.10.Final.zip</code>, enter the <code class="code">jboss-modules</code>
                directory of the project, and run the following Maven command:
                </p><pre><code class="no-highlight">$ mvn install</code></pre><p>
                It will start to build the modules and finally it will produce the zip file inside "target" directory:
                </p><pre><code class="no-highlight">$ pwd
resteasy/jboss-modules
$ ls target/*.zip
target/resteasy-jboss-modules-4.7.10.Final-mavenized.zip
target/resteasy-jboss-modules-4.7.10.Final.zip
</code></pre><p>
            </p>
            <p>
                To use the zip file, you need to copy it into Wildfly's "modules" directory:
                </p><pre><code class="no-highlight">$ pwd
wildfly
$ ls
LICENSE.txt       bin               domain            standalone
README.txt        copyright.txt     jboss-modules.jar welcome-content
appclient         docs              modules

</code></pre><p>
            </p>
            <p>
                Use the following step to copy and extract the modules zip into Wildfly modules directory:
                </p><pre><code class="no-highlight">
$ cp ~/works/resteasy/jboss-modules/target/resteasy-jboss-modules-4.7.10.Final.zip \
modules/system/layers/base/
$ cd modules/system/layers/base
$ unzip resteasy-jboss-modules-4.7.10.Final.zip
...</code></pre><p>
                With the above process, the RESTEasy modules are upgraded inside Wildfly.
            </p>
	    </section>
    </section>
    <section class="section" id="d5e123"><div class="titlepage"><div><div><h2 class="title">3.2. Deploying a RESTEasy application to WildFly</h2></div></div></div>
        
        <p>
            RESTEasy is bundled with WildFly and completely integrated as per the requirements of Java EE.
            You can use it with EJB and CDI and you can rely completely on WildFly to scan for and deploy your JAX-RS services and providers.
            All you have to provide is your JAX-RS service and provider classes packaged
            within a WAR either as POJOs, CDI beans, or EJBs.
            A simple way to configure an application is by simply providing an empty web.xml file.
            You can of course deploy any custom servlet, filter
            or security constraint you want to within your web.xml, but none of them are required:
        </p>
        <p>
            </p><pre><code class="no-highlight">
&lt;web-app version="3.0" xmlns="http://java.sun.com/xml/ns/javaee"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"&gt;
&lt;/web-app&gt;</code></pre><p>
        </p>
        <p>
            Also, web.xml can supply to RESTEasy init-params and context-params (see <a class="xref" href="#configuration_switches" title="3.5. Configuration switches">Section 3.5, “Configuration switches”</a>)
            if you want to tweak or turn on/off any specific RESTEasy feature.
        </p>
        <p>
            Since we're not using a &lt;servlet-mapping&gt; element, we must define a
            <code class="classname">javax.ws.rs.core.Application</code> class (see <a class="xref" href="#javax.ws.rs.core.Application" title="3.6. javax.ws.rs.core.Application">Section 3.6, “javax.ws.rs.core.Application”</a>) that is annotated with
            the <code class="classname">javax.ws.rs.ApplicationPath</code> annotation.  If you return any empty set for classes and singletons,
            which is the behavior inherited from <code class="classname">Application</code>, your WAR will
            be scanned for resource and provider classes as indicated by the presence of JAX-RS annotations.
        </p>
        <pre><code class="no-highlight">
import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;

@ApplicationPath("/root-path")
public class MyApplication extends Application
{
}       </code></pre>

        <p>
            <span class="bold"><strong>Note.</strong></span> Actually, if the application jar contains an
            <code class="classname">Application</code> class (or a subclass thereof)
            which is annotated with an <code class="classname">ApplicationPath</code> annotation, a web.xml file isn't even needed.
            Of course, even in this case it can be used to specify additional information such as context parameters.
            If there is an <code class="classname">Application</code> class but it doesn't have an
            <code class="classname">@ApplicationPath</code> annotation, then a web.xml file with at least a
            &lt;servlet-mapping&gt; element is required.
        </p>

        <p>
            <span class="bold"><strong>Note.</strong></span> As mentioned in <a class="xref" href="#other_resteasy_modules" title="3.1.1. Other RESTEasy modules">Section 3.1.1, “Other RESTEasy modules”</a>,
            not all RESTEasy modules are bundled with WildFly. For example,
            resteasy-fastinfoset-provider and resteasy-wadl are not included among the
            modules listed in <a class="xref" href="#resteasy_modules_in_wildfly" title="3.1. RESTEasy modules in WildFly">Section 3.1, “RESTEasy modules in WildFly”</a>. If you want
            to use them in your application, you can include them in your WAR as you would if you were
            deploying outside of WildFly. See <a class="xref" href="#standalone_resteasy" title="3.3. Deploying to other servlet containers">Section 3.3, “Deploying to other servlet containers”</a> for more information.
        </p>

</section>
    <section class="section" id="standalone_resteasy"><div class="titlepage"><div><div><h2 class="title">3.3. Deploying to other servlet containers</h2></div></div></div>
        
        <p>
            If you are using RESTEasy outside of WildFly, in a standalone servlet container like Tomcat or Jetty, for example,
            you will need to include the appropriate RESTEasy jars in your WAR file.  You will need the core classes
            in the resteasy-jaxrs module, and you may need additional facilities like the resteasy-jaxb-provider module.
            We strongly suggest that you use Maven to build your WAR files as RESTEasy is split into
            a bunch of different modules:
        </p>
        <pre><code class="no-highlight">
&lt;dependency&gt;
    &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
    &lt;artifactId&gt;resteasy-core&lt;/artifactId&gt;
    &lt;version&gt;4.7.10.Final&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
    &lt;artifactId&gt;resteasy-jaxb-provider&lt;/artifactId&gt;
    &lt;version&gt;4.7.10.Final&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
        <p>
            You can see sample Maven projects in
            <a class="ulink" href="https://github.com/resteasy/resteasy-examples">https://github.com/resteasy/resteasy-examples</a>.
        </p>
        <p>
            If you are not using Maven, you can include the necessary jars by hand. If you download
            RESTEasy (from <a class="ulink" href="http://resteasy.jboss.org/downloads.html">http://resteasy.jboss.org/downloads.html</a>,
            for example) you will get a file like resteasy-jaxrs-&lt;version&gt;-all.zip.
            If you unzip it you will see a lib/ directory that contains the libraries needed by RESTEasy.
            Copy these, as needed, into your /WEB-INF/lib directory. Place your JAX-RS annotated class resources and providers
            within one or more jars within /WEB-INF/lib or your raw class files within /WEB-INF/classes.
        </p>

        <section class="section" id="d5e155"><div class="titlepage"><div><div><h3 class="title">3.3.1. Servlet 3.0 containers</h3></div></div></div>
        
        <p>
            RESTEasy provides an implementation of the Servlet 3.0 <code class="literal">ServletContainerInitializer</code>
            integration interface for containers to use in initializing an application.
            The container calls this interface during the application's startup phase.
            The RESTEasy implementation performs automatic scanning for resources and providers,
            and programmatic registration of a servlet.

            RESTEasy's implementation is provided in maven artifact, <code class="literal">resteasy-servlet-initializer</code>.
            Add this artifact dependency to your project's pom.xml file so the JAR file will be included
            in your WAR file.
        </p>
        <pre><code class="no-highlight">
&lt;dependency&gt;
    &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
    &lt;artifactId&gt;resteasy-servlet-initializer&lt;/artifactId&gt;
    &lt;version&gt;4.7.10.Final&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
        </section>

        <section class="section" id="d5e161"><div class="titlepage"><div><div><h3 class="title">3.3.2. Older servlet containers</h3></div></div></div>
        
        <p>
            The <code class="literal">resteasy-servlet-initializer</code> artifact will not work in Servlet versions older than
            3.0.  You'll then have to manually declare the RESTEasy servlet in your WEB-INF/web.xml file of your WAR project,
            and you'll have to use an <code class="classname">Application</code> class (see <a class="xref" href="#javax.ws.rs.core.Application" title="3.6. javax.ws.rs.core.Application">Section 3.6, “javax.ws.rs.core.Application”</a>)
            which explicitly lists resources and providers. For example:
        </p>
        <p>
            </p><pre><code class="no-highlight">
&lt;web-app&gt;
    &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
        &lt;servlet-class&gt;
            org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher
        &lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;javax.ws.rs.Application&lt;/param-name&gt;
            &lt;param-value&gt;com.restfully.shop.services.ShoppingApplication&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;</code></pre><p>
        </p>
        <p>
            The RESTEasy servlet is responsible for initializing some basic components of RESTEasy.
        </p>
        <p>
            <span class="bold"><strong>Note.</strong></span> It is likely that support for pre-3.0 Servlet specifications
            will be deprecated and eliminated eventually.
        </p>
        </section>
    </section>
   <section class="section" id="microprofile_config"><div class="titlepage"><div><div><h2 class="title">3.4. Configuration</h2></div></div></div>
        
        
        <p>
        RESTEasy has two mutually exclusive mechanisms for retrieving configuration parameters
        (see <a class="xref" href="#configuration_switches" title="3.5. Configuration switches">Section 3.5, “Configuration switches”</a>).
        The classic mechanism depends on context-params and init-params in a web.xml file.
        Alternatively, the Eclipse MicroProfile Config project
        (<a class="ulink" href="https://github.com/eclipse/microprofile-config">https://github.com/eclipse/microprofile-config</a>)
        provides a flexible parameter retrieval mechanism that RESTEasy will use if the necessary
        dependencies are available. See <a class="xref" href="#configuring_mp_config" title="3.4.4. Configuring MicroProfile Config">Section 3.4.4, “Configuring MicroProfile Config”</a> for more about that. If 
        they are not available, it will fall back to an extended form of the classic mechanism.
        </p>
        
        <section class="section" id="resteasy_microprofile_config"><div class="titlepage"><div><div><h3 class="title">3.4.1. RESTEasy with MicroProfile Config</h3></div></div></div>
        
        <p>
            In the presence of the Eclipse MicroProfile Config API jar and an implementation
            of the API (see <a class="xref" href="#configuring_mp_config" title="3.4.4. Configuring MicroProfile Config">Section 3.4.4, “Configuring MicroProfile Config”</a>), RESTEasy will use the facilities
            of MicroProfile Config for accessing configuration properties (see <a class="xref" href="#configuration_switches" title="3.5. Configuration switches">Section 3.5, “Configuration switches”</a>). 
            MicroProfile Config offers to both RESTEasy users and RESTEasy developers a great deal of
            flexibility in controlling runtime configuration.	
        </p>
        
        <p>
            In MicroProfile Config, a <code class="classname">ConfigSource</code> represents a <code class="classname">Map&lt;String, String&gt;</code>
            of property names to values, and a <code class="classname">Config</code> represents a sequence of <code class="classname">ConfigSource</code>s,
            ordered by priority. The priority of a <code class="classname">ConfigSource</code> is given by an ordinal (represented by an
            <code class="classname">int</code>), with a higher value indicating a higher priority. For a given property name, the
            <code class="classname">ConfigSource</code>s are searched in order until a value is found.
        </p>
        <p>
            MicroProfile Config mandates the presence of the following <code class="classname">ConfigSource</code>s:
        </p>
        <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">a <code class="classname">ConfigSource</code> based on System.getProperties() (ordinal = 400)</li><li class="listitem">a <code class="classname">ConfigSource</code> based on System.getenv() (ordinal = 300)</li><li class="listitem">a <code class="classname">ConfigSource</code> for each META-INF/microprofile-config.properties file on the ClassPath,
            separately configurable via a config_ordinal property inside each file (default ordinal = 100)</li></ol></div>
        <p>
            Note that a property which is found among the System properties and which is also in the System environment will be assigned
            the System property value because of the relative priorities of the <code class="classname">ConfigSource</code>s.
        </p>
        <p>
            The set of <code class="classname">ConfigSources</code> is extensible. For example, smallrye-config
            (<a class="ulink" href="https://github.com/smallrye/smallrye-config">https://github.com/smallrye/smallrye-config</a>),
            the implementation of the MicroProfile Config specification currently used by RESTEasy, adds the following
            kinds of <code class="classname">ConfigSource</code>s:
        </p>
        <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><code class="classname">PropertiesConfigSource</code> creates a <code class="classname">ConfigSource</code> from a
            Java <code class="classname">Properties</code> object or a Map&lt;String, String&gt; object or a properties file
            (referenced by its URL) (default ordinal = 100).</li><li class="listitem"><code class="classname">DirConfigSource</code> creates a <code class="classname">ConfigSource</code> that will look into a directory
            where each file corresponds to a property (the file name is the property key and its textual content is the property value).
            This <code class="classname">ConfigSource</code> can be used to read configuration from Kubernetes ConfigMap (default ordinal = 100).</li><li class="listitem"><code class="classname">ZkMicroProfileConfig</code> creates a <code class="classname">ConfigSource</code>ConfigSource that is backed by Apache Zookeeper
            (ordinal = 150).</li></ol></div>
        <p>
            These can be registered programmatically by using an instance of <code class="classname">ConfigProviderResolver</code>:
        </p>
        <pre><code class="no-highlight">
Config config = new PropertiesConfigSource("file:/// ...");
ConfigProviderResolver.instance().registerConfig(config, getClass().getClassLoader());
        </code></pre>
        <p>where <code class="classname">ConfigProviderResolver</code> is part of the Eclipse API.</p>
        <p>
            If the application is running in Wildfly, then Wildfly provides another set of <code class="classname">ConfigSource</code>s,
            as described in the "MicroProfile Config Subsystem Configuration" section of the WildFly Admin guide
            (<a class="ulink" href="https://docs.wildfly.org/21/Admin_Guide.html#MicroProfile_Config_SmallRye">https://docs.wildfly.org/21/Admin_Guide.html#MicroProfile_Config_SmallRye</a>).
        </p>
        <p>
            Finally, RESTEasy automatically provides three more <code class="classname">ConfigSource</code>s:
        </p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="classname">org.jboss.resteasy.microprofile.config.ServletConfigSource</code> represents
            a servlet's &lt;init-param&gt;s from web.xml (ordinal = 60).</li><li class="listitem"><code class="classname">org.jboss.resteasy.microprofile.config.FilterConfigSource</code> represents
            a filter's &lt;init-param&gt;s from web.xml (ordinal = 50). (See <a class="xref" href="#filter" title="3.8. RESTEasy as a Servlet Filter">Section 3.8, “RESTEasy as a Servlet Filter”</a> for more information.)
            </li><li class="listitem"><code class="classname">org.jboss.resteasy.microprofile.config.ServletContextConfigSource</code> represents
            &lt;context-param&gt;s from web.xml (ordinal = 40).</li></ul></div>
        <p>
            <span class="bold"><strong>Note. </strong></span>As stated by the MicroProfile Config specification, a special property
            <code class="classname">config_ordinal</code> can be set within any RESTEasy built-in <code class="classname">ConfigSource</code>s.
            The default implementation of getOrdinal() will attempt to read this value. If found and a valid integer, the value
            will be used. Otherwise the respective default value will be used.
        </p>
        </section>

        <section class="section" id="d5e240"><div class="titlepage"><div><div><h3 class="title">3.4.2. Using pure MicroProfile Config</h3></div></div></div>
            
            
            <p>
                The MicroProfile Config API is very simple. A <code class="classname">Config</code> may be obtained either
                programatically:
            </p>
            
            <pre><code class="no-highlight">
Config config = ConfigProvider.getConfig();
            </code></pre>
            
            <p>
                or, in the presence of CDI, by way of injection:
            </p>
            
            <pre><code class="no-highlight">
@Inject Config config;
            </code></pre>
            
            <p>
                Once a <code class="classname">Config</code> has been obtained, a property can be queried. For example,
            </p>
            
            <pre><code class="no-highlight">
String s = config.getValue("prop_name", String.class);
            </code></pre>
            
            <p>
                or
            </p>
            
            <pre><code class="no-highlight">
String s = config.getOptionalValue("prop_name", String.class).orElse("d'oh");
            </code></pre>
            
            <p>
                Now, consider a situation in which "prop_name" has been set by <code class="code">System.setProperty("prop_name", "system")</code>
                and also by
            </p>
            
            <pre><code class="no-highlight">
   &lt;context-param&gt;
      &lt;param-name&gt;prop_name&lt;/param-name&gt;
      &lt;param-value&gt;context&lt;/param-value&gt;
   &lt;/context-param&gt;
            </code></pre>
               
            <p>
                Then, since the system parameter <code class="classname">ConfigSource</code> has precedence over (has a higher ordinal than)
                <code class="classname">ServletContextConfigSource</code>, <code class="code">config.getValue("prop_name", String.class)</code> will
                return "system" rather than "context".
            </p>

        </section>
        <section class="section" id="d5e259"><div class="titlepage"><div><div><h3 class="title">3.4.3. Using RESTEasy's extension of MicroProfile Config</h3></div></div></div>
            
            
            <p>
            RESTEasy offers a general purpose parameter retrieval mechanism which incorporates MicroProfile Config if the necessary
            dependencies are available, and which falls back to an extended version of the classic RESTEasy mechanism 
            (see <a class="xref" href="#classic_config" title="3.4.5. RESTEasy's classic configuration mechanism">Section 3.4.5, “RESTEasy's classic configuration mechanism”</a>) otherwise.
            </p>
            
            <p>Calling</p>
            
            <pre><code class="no-highlight">
ConfigurationFactory.getInstance().getConfiguration()
            </code></pre>
            
            <p>
            will return an instance of org.jboss.resteasy.spi.config.Configuration:
            </p>
            
            <pre><code class="no-highlight">
public interface Configuration {

    /**
     * Returns the resolved value for the specified type of the named property.
     *
     * @param name the name of the parameter
     * @param type the type to convert the value to
     * @param &lt;T&gt;  the property type
     *
     * @return the resolved optional value
     *
     * @throws IllegalArgumentException if the type is not supported
     */
    &lt;T&gt; Optional&lt;T&gt; getOptionalValue(String name, Class&lt;T&gt; type);

    /**
     * Returns the resolved value for the specified type of the named property.
     *
     * @param name the name of the parameter
     * @param type the type to convert the value to
     * @param &lt;T&gt;  the property type
     *
     * @return the resolved value
     *
     * @throws IllegalArgumentException         if the type is not supported
     * @throws java.util.NoSuchElementException if there is no property associated with the name
     */
    &lt;T&gt; T getValue(String name, Class&lt;T&gt; type);
}
            </code></pre>
            
        <p>
        For example,
        </p>
        
        <pre><code class="no-highlight">
String value = ConfigurationFactory.getInstance().getConfiguration().getOptionalValue("prop_name", String.class).orElse("d'oh");
        </code></pre>
        
        <p>
        If MicroProfile Config is available, that would be equivalent to
        </p>
        
        <pre><code class="no-highlight">
String value = ConfigProvider.getConfig().getOptionalValue("prop_name", String.class).orElse("d'oh");
        </code></pre>
        
        <p>
        If MicroProfile Config is not available, then an attempt is made to retrieve the parameter from
        the following sources:
        </p>
        
        <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">system variables, followed by</li><li class="listitem">environment variables, followed by</li><li class="listitem">web.xml parameters, as described in <a class="xref" href="#classic_config" title="3.4.5. RESTEasy's classic configuration mechanism">Section 3.4.5, “RESTEasy's classic configuration mechanism”</a> </li></ol></div>
        </section>
                
        <section class="section" id="configuring_mp_config"><div class="titlepage"><div><div><h3 class="title">3.4.4. Configuring MicroProfile Config</h3></div></div></div>
            
            
            <p>
                If an application is running inside Wildfly, then all of the dependencies are automatically available. Outside of
                Wildfly, an application will need the Eclipse MicroProfile API at compile time. In maven, for example, use
            </p>
            
            <pre><code class="no-highlight">
        &lt;dependency&gt;
            &lt;groupId&gt;org.eclipse.microprofile.config&lt;/groupId&gt;
            &lt;artifactId&gt;microprofile-config-api&lt;/artifactId&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
            </code></pre>
            
            <p>
                It will also need the implementation, smallrye-config, at runtime:
            </p>
            
            <pre><code class="no-highlight">
        &lt;dependency&gt;
            &lt;groupId&gt;io.smallrye&lt;/groupId&gt;
            &lt;artifactId&gt;smallrye-config&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
            </code></pre>
        </section>
       
    <section class="section" id="classic_config"><div class="titlepage"><div><div><h3 class="title">3.4.5. RESTEasy's classic configuration mechanism</h3></div></div></div>
    
    
    <p>
    Prior to the incorporation of MicroProfile Config, nearly all of RESTEasy's parameters were retrieved from
    servlet init-params and context-params. Which ones are available depends on how a web application invokes RESTEasy.
    </p>
    
    <p>
    If RESTEasy is invoked as a servlet, as in
    </p>
    
<pre><code class="no-highlight">
&lt;web-app version="3.0" xmlns="http://java.sun.com/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"&gt;

   &lt;context-param&gt;
      &lt;param-name&gt;system&lt;/param-name&gt;
      &lt;param-value&gt;system-context&lt;/param-value&gt;
   &lt;/context-param&gt;
   
   &lt;servlet&gt;
      &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
      &lt;servlet-class&gt;org.jboss.resteasy.plugins.server.servlet.HttpServlet30Dispatcher&lt;/servlet-class&gt;

      &lt;init-param&gt;
         &lt;param-name&gt;system&lt;/param-name&gt;
         &lt;param-value&gt;system-init&lt;/param-value&gt;
      &lt;/init-param&gt;
      
   &lt;/servlet&gt;

   &lt;servlet-mapping&gt;
      &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
   &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>

   <p>
   then the servlet specific init-params and the general context-params are available,
   with the former taking precedence over the latter. For example, the property "system" would
   have the value "system-init".
   </p>

   <p>
   If RESTEasy is invoked by way of a filter (see <a class="xref" href="#filter" title="3.8. RESTEasy as a Servlet Filter">Section 3.8, “RESTEasy as a Servlet Filter”</a>), as in
   </p>
   
   <pre><code class="no-highlight">
&lt;web-app version="3.0" xmlns="http://java.sun.com/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"&gt;

   &lt;context-param&gt;
      &lt;param-name&gt;system&lt;/param-name&gt;
      &lt;param-value&gt;system-context&lt;/param-value&gt;
   &lt;/context-param&gt;

   &lt;filter&gt;
      &lt;filter-name&gt;Resteasy&lt;/filter-name&gt;
      &lt;filter-class&gt;org.jboss.resteasy.plugins.server.servlet.FilterDispatcher&lt;/filter-class&gt;

      &lt;init-param&gt;
         &lt;param-name&gt;system&lt;/param-name&gt;
         &lt;param-value&gt;system-filter&lt;/param-value&gt;
      &lt;/init-param&gt;

    &lt;/filter&gt;

    &lt;filter-mapping&gt;
        &lt;filter-name&gt;Resteasy&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

&lt;/web-app&gt;
   </code></pre>

   <p>
   then the filter specific init-params and the general context-params are available,
   with the former taking precedence over the latter. For example, the property "system" would
   have the value "system-filter".
   </p>

   <p>
   Finally, if RESTEasy is invoked by way of a ServletContextListener (see <a class="xref" href="#listener" title="3.7. RESTEasy as a ServletContextListener">Section 3.7, “RESTEasy as a ServletContextListener”</a>), as in
   </p>

<pre><code class="no-highlight">
&lt;web-app version="3.0" xmlns="http://java.sun.com/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"&gt;

   &lt;listener&gt;
      &lt;listener-class&gt;
         org.jboss.resteasy.plugins.server.servlet.ResteasyBootstrap
      &lt;/listener-class&gt;
   &lt;/listener&gt;

   &lt;context-param&gt;
      &lt;param-name&gt;system&lt;/param-name&gt;
      &lt;param-value&gt;system-context&lt;/param-value&gt;
   &lt;/context-param&gt;
&lt;/web-app&gt;
</code></pre>
 
    <p>
    where <code class="classname">ResteasyBootstrap</code> is a <code class="classname">ServletContextListener</code>,
    then the context-params are available.
    </p>
    </section>
   
    <section class="section" id="overriding_config"><div class="titlepage"><div><div><h3 class="title">3.4.6. Overriding RESTEasy's configuration mechanism</h3></div></div></div>
    
    
    <p>
    Before adopting the default behavior, with or without MicroProfile Config, as described in 
    previous sections, RESTEasy will use service loading to look for one or more implementations of
    the interface <code class="classname">org.jboss.resteasy.spi.config.ConfigurationFactory</code>, selecting one
    with the highest priority as determined by the value returned by 
    <code class="methodname">ConfigurationFactory.priority()</code>. Smaller numbers indicate higher priority.
    The default <code class="classname">ConfigurationFactory</code> is
    <code class="classname">org.jboss.resteasy.core.config.DefaultConfigurationFactory</code> with a priority of 500.
    </p>
    </section>
    </section>
     
    <section class="section" id="configuration_switches"><div class="titlepage"><div><div><h2 class="title">3.5. Configuration switches</h2></div></div></div>
        
        <p>RESTEasy can receive the following configuration options from any <code class="classname">ConfigSource</code>s
        that are available at runtime:
        </p>
        <p>
            </p><div class="table" id="d5e311"><div class="table-title">Table 3.2. </div><div class="table-contents">
                <table style="border-collapse: collapse;border-top: 1px solid ; border-bottom: 1px solid ; "><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 1px  ; border-bottom: 1px  ; ">
                                Option Name
                            </th><th style="border-right: 1px  ; border-bottom: 1px  ; ">
                                Default Value
                            </th><th style="border-bottom: 1px  ; ">
                                Description
                            </th></tr></thead><tbody><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                resteasy.servlet.mapping.prefix
                            </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                no default
                            </td><td style="border-bottom: 1px  ; ">
                                If the url-pattern for the RESTEasy servlet-mapping is not /*
                            </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                resteasy.providers
                            </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                no default
                            </td><td style="border-bottom: 1px  ; ">
                                A comma delimited list of fully qualified @Provider class names you want to register
                            </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                resteasy.use.builtin.providers
                            </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                true
                            </td><td style="border-bottom: 1px  ; ">
                                Whether or not to register default, built-in @Provider classes
                            </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                resteasy.resources
                            </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                no default
                            </td><td style="border-bottom: 1px  ; ">
                                A comma delimited list of fully qualified JAX-RS resource class names you want to
                                register
                            </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                resteasy.jndi.resources
                            </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                no default
                            </td><td style="border-bottom: 1px  ; ">
                                A comma delimited list of JNDI names which reference objects you want to register as
                                JAX-RS resources
                            </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                javax.ws.rs.Application
                            </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                no default
                            </td><td style="border-bottom: 1px  ; ">
                                Fully qualified name of Application class to bootstrap in a spec portable way
                            </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                resteasy.media.type.mappings
                            </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                no default
                            </td><td style="border-bottom: 1px  ; ">
                                Replaces the need for an Accept header by mapping file name extensions (like .xml or
                                .txt) to a media type. Used when the client
                                is unable to use an Accept header to choose a representation (i.e. a browser). See
                                <a class="xref" href="#JAX-RS_Content_Negotiation" title="Chapter 20. JAX-RS Content Negotiation">Chapter 20, <em>JAX-RS Content Negotiation</em></a> for more details.
                            </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                resteasy.language.mappings
                            </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                no default
                            </td><td style="border-bottom: 1px  ; ">
                                Replaces the need for an Accept-Language header by mapping file name extensions (like
                                .en or .fr) to a language. Used when the client
                                is unable to use an Accept-Language header to choose a language (i.e. a browser). See
                                <a class="xref" href="#JAX-RS_Content_Negotiation" title="Chapter 20. JAX-RS Content Negotiation">Chapter 20, <em>JAX-RS Content Negotiation</em></a> for more details.
                            </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                resteasy.media.type.param.mapping
                            </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                no default
                            </td><td style="border-bottom: 1px  ; ">
                                Names a query parameter that can be set to an acceptable media type,
                                enabling content negotiation without an Accept header. See
                                <a class="xref" href="#JAX-RS_Content_Negotiation" title="Chapter 20. JAX-RS Content Negotiation">Chapter 20, <em>JAX-RS Content Negotiation</em></a> for more details.
                            </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                resteasy.role.based.security
                            </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                false
                            </td><td style="border-bottom: 1px  ; ">
                                Enables role based security. See <a class="xref" href="#Securing_JAX-RS_and_RESTeasy" title="Chapter 43. Securing JAX-RS and RESTEasy">Chapter 43, <em>Securing JAX-RS and RESTEasy</em></a>
                                for more details.
                            </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                resteasy.document.expand.entity.references
                            </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                false
                            </td><td style="border-bottom: 1px  ; ">
                                Expand external entities in org.w3c.dom.Document documents
                                and JAXB object representations
                            </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                resteasy.document.secure.processing.feature
                            </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                true
                            </td><td style="border-bottom: 1px  ; ">
                                Impose security constraints in processing org.w3c.dom.Document documents
                                and JAXB object representations
                            </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                resteasy.document.secure.disableDTDs
                            </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                true
                            </td><td style="border-bottom: 1px  ; ">
                                Prohibit DTDs in org.w3c.dom.Document documents
                                and JAXB object representations
                            </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                resteasy.wider.request.matching
                            </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                false
                            </td><td style="border-bottom: 1px  ; ">
                                Turns off the JAX-RS spec defined class-level expression filtering and instead
                                tries to match version every method's full path.
                            </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                resteasy.use.container.form.params
                            </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                false
                            </td><td style="border-bottom: 1px  ; ">
                                Obtain form parameters by using HttpServletRequest.getParameterMap().
                                Use this switch if you are calling this method within a servlet filter or eating
                                the input stream within the filter.
                            </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                resteasy.rfc7232preconditions
                            </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                false
                            </td><td style="border-bottom: 1px  ; ">
                                Enables <a class="link" href="#Http_Precondition" title="35.4. HTTP preconditions">RFC7232 compliant HTTP preconditions handling</a>.
                            </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                resteasy.gzip.max.input
                            </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                10000000
                            </td><td style="border-bottom: 1px  ; ">
                                Imposes maximum size on decompressed gzipped .
                            </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                resteasy.secure.random.max.use
                            </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                100
                            </td><td style="border-bottom: 1px  ; ">
                                The number of times a SecureRandom can be used before reseeding.
                            </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                resteasy.buffer.exception.entity
                            </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                true
                            </td><td style="border-bottom: 1px  ; ">
                                Upon receiving an exception, the client side buffers any response
                                entity before closing the connection.
                            </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                resteasy.add.charset
                            </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                true
                            </td><td style="border-bottom: 1px  ; ">
                                If a resource method returns a text/* or application/xml* media type without
                                an explicit charset, RESTEasy will add "charset=UTF-8" to the returned
                                Content-Type header. Note that the charset defaults to UTF-8 in this case,
                                independent of the setting of this parameter.
                            </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                resteasy.disable.html.sanitizer
                            </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                false
                            </td><td style="border-bottom: 1px  ; ">
                                Normally, a response with media type "text/html" and a status of 400 will be processed
                                so that the characters "/", "&lt;", "&gt;", "&amp;", """ (double quote), and "'" (single quote)
                                are escaped to prevent an XSS attack. If this parameter is set to "true", escaping
                                will not occur.
                            </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                resteasy.patchfilter.disabled
                            </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                false
                            </td><td style="border-bottom: 1px  ; ">
                                Turns off the default patch filter to handle JSON patch and JSON Merge Patch request. 
                                A customerized patch method filter can be provided to serve the JSON patch and JSON merge
                                patch request instead.
                            </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                resteasy.patchfilter.legacy
                            </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                true
                            </td><td style="border-bottom: 1px  ; ">
                                Set this value to false, the jsonp provider will be activated to provide
                                PatchFilter for Json patch or Json Merge patch functionalities. By default(true value),
                                the Jackson provider will be used.
                            </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                resteasy.original.webapplicationexception.behavior
                            </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                false
                            </td><td style="border-bottom: 1px  ; ">
                                When set to "true", this parameter will restore the original behavior in which
                                a Client running in a resource method will throw a JAX-RS WebApplicationException
                                instead of a Resteasy version with a sanitized <code class="classname">Response</code>. For more information,
                                see section <a class="link" href="#ResteasyWebApplicationException" title="30.3. Resteasy WebApplicationExceptions">Resteasy WebApplicationExceptions</a>
                            </td></tr><tr><td style="border-right: 1px  ; ">
                                dev.resteasy.throw.options.exception
                            </td><td style="border-right: 1px  ; ">
                                false
                            </td><td>
                                Setting this value to true will throw a <code class="classname">org.jboss.resteasy.spi.DefaultOptionsMethodException</code>
                                if the HTTP method "OPTIONS" is sent and the matching method is not annotated with
                                <code class="classname">@OPTIONS</code>. This is the original behavior of RESTEasy. However, this
                                has been changed to return the response so that it's processed with an
                                <code class="classname">ExceptionMapper</code>.
                            </td></tr></tbody></table>
            </div></div><p><br class="table-break"/>
        </p>
        <p>
            <span class="bold"><strong>Note. </strong></span>
            The resteasy.servlet.mapping.prefix &lt;context param&gt; variable must be set if your servlet-mapping for
            the RESTEasy servlet has a url-pattern other than /*. For example, if the url-pattern is
        </p>
        <p>
            </p><pre><code class="no-highlight">
&lt;servlet-mapping&gt;
&lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
&lt;url-pattern&gt;/restful-services/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</code></pre><p>
        </p>
        <p>
            Then the value of resteasy.servlet.mapping.prefix must be:
        </p>
        <p>
            </p><pre><code class="no-highlight">
&lt;context-param&gt;
&lt;param-name&gt;resteasy.servlet.mapping.prefix&lt;/param-name&gt;
&lt;param-value&gt;/restful-services&lt;/param-value&gt;
&lt;/context-param&gt;</code></pre><p>
        </p>

        <p>
            Resteasy internally uses a cache to find the resource invoker for the request url. This cache
            size and enablement can be controlled with these system properties.
        </p>
        <p>
            </p><div class="table" id="d5e438"><div class="table-title">Table 3.3. </div><div class="table-contents">
                <table style="border-collapse: collapse;border-top: 1px solid ; border-bottom: 1px solid ; "><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 1px  ; border-bottom: 1px  ; ">
                                System Property Name
                            </th><th style="border-right: 1px  ; border-bottom: 1px  ; ">
                                Default Value
                            </th><th style="border-bottom: 1px  ; ">
                                Description
                            </th></tr></thead><tbody><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                resteasy.match.cache.enabled
                            </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                true
                            </td><td style="border-bottom: 1px  ; ">
                                If the match cache is enabled or not
                            </td></tr><tr><td style="border-right: 1px  ; ">
                                resteasy.match.cache.size
                            </td><td style="border-right: 1px  ; ">
                                2048
                            </td><td>
                                The size of this match cache
                            </td></tr></tbody></table>
            </div></div><p><br class="table-break"/>
        </p>
    </section>
    <section class="section" id="javax.ws.rs.core.Application"><div class="titlepage"><div><div><h2 class="title">3.6. javax.ws.rs.core.Application</h2></div></div></div>
        

        <p>

            The <code class="classname">javax.ws.rs.core.Application</code> class is a standard JAX-RS class that you may implement to provide
            information on your deployment. It is simply a class the lists all JAX-RS root resources and providers.
        </p>
        <p>

            </p><pre><code class="no-highlight">
/**
* Defines the components of a JAX-RS application and supplies additional
* metadata. A JAX-RS application or implementation supplies a concrete
* subclass of this abstract class.
*/
public abstract class Application
{
    private static final Set&lt;Object&gt; emptySet = Collections.emptySet();

    /**
    * Get a set of root resource and provider classes. The default lifecycle
    * for resource class instances is per-request. The default lifecycle for
    * providers is singleton.
    * &lt;p/&gt;
    * &lt;p&gt;Implementations should warn about and ignore classes that do not
    * conform to the requirements of root resource or provider classes.
    * Implementations should warn about and ignore classes for which
    * {@link #getSingletons()} returns an instance. Implementations MUST
    * NOT modify the returned set.&lt;/p&gt;
    *
    * @return a set of root resource and provider classes. Returning null
    * is equivalent to returning an empty set.
    */
    public abstract Set&lt;Class&lt;?&gt;&gt; getClasses();

    /**
    * Get a set of root resource and provider instances. Fields and properties
    * of returned instances are injected with their declared dependencies
    * (see {@link Context}) by the runtime prior to use.
    * &lt;p/&gt;
    * &lt;p&gt;Implementations should warn about and ignore classes that do not
    * conform to the requirements of root resource or provider classes.
    * Implementations should flag an error if the returned set includes
    * more than one instance of the same class. Implementations MUST
    * NOT modify the returned set.&lt;/p&gt;
    * &lt;p/&gt;
    * &lt;p&gt;The default implementation returns an empty set.&lt;/p&gt;
    *
    * @return a set of root resource and provider instances. Returning null
    * is equivalent to returning an empty set.
    */
    public Set&lt;Object&gt; getSingletons()
    {
        return emptySet;
    }

}            </code></pre><p>
        </p>
        <p>


        </p>

        <p>

        </p>
        <p>
            <span class="bold"><strong>Note. </strong></span>If your web.xml file does not have a
            &lt;servlet-mapping&gt; element, you must use an <code class="classname">Application</code> class
            annotated with <code class="classname">@ApplicationPath</code>.

        </p>
    </section>

    <section class="section" id="listener"><div class="titlepage"><div><div><h2 class="title">3.7. RESTEasy as a ServletContextListener</h2></div></div></div>
        

        <p>
            This section is pretty much deprecated if you are using a Servlet 3.0 container or higher.  Skip it if
            you are and read the configuration section above on installing in Servlet 3.0.
            The initialization of RESTEasy can be performed within a ServletContextListener instead of within the
            Servlet. You may need this if you are writing custom Listeners that need to interact with RESTEasy at boot
            time. An example of this is the RESTEasy Spring integration that requires a Spring ServletContextListener.
            The org.jboss.resteasy.plugins.server.servlet.ResteasyBootstrap class is a ServletContextListener that
            configures an instance of an ResteasyProviderFactory and Registry. You can obtain instances of a
            ResteasyProviderFactory and Registry from the ServletContext attributes
            org.jboss.resteasy.spi.ResteasyProviderFactory and org.jboss.resteasy.spi.Registry. From these instances you
            can programmatically interact with RESTEasy registration interfaces.
        </p>

        <pre><code class="no-highlight">
&lt;web-app&gt;
   &lt;listener&gt;
      &lt;listener-class&gt;
         org.jboss.resteasy.plugins.server.servlet.ResteasyBootstrap
      &lt;/listener-class&gt;
   &lt;/listener&gt;

  &lt;!-- ** INSERT YOUR LISTENERS HERE!!!! --&gt;

   &lt;servlet&gt;
      &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
      &lt;servlet-class&gt;
         org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher
      &lt;/servlet-class&gt;
   &lt;/servlet&gt;

   &lt;servlet-mapping&gt;
      &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
      &lt;url-pattern&gt;/Resteasy/*&lt;/url-pattern&gt;
   &lt;/servlet-mapping&gt;

&lt;/web-app&gt;</code></pre>
    </section>
    <section class="section" id="filter"><div class="titlepage"><div><div><h2 class="title">3.8. RESTEasy as a Servlet Filter</h2></div></div></div>
        

        <p>
            This section is pretty much deprecated if you are using a Servlet 3.0 container or higher.  Skip it if
            you are and read the configuration section above on installing in Servlet 3.0.
            The downside of running RESTEasy as a Servlet is that you cannot have static resources like .html and .jpeg
            files in the
            same path as your JAX-RS services. RESTEasy allows you to run as a Filter instead. If a JAX-RS resource is
            not
            found under the URL requested, RESTEasy will delegate back to the base servlet container to resolve URLs.
        </p>

        <pre><code class="no-highlight">
&lt;web-app&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;Resteasy&lt;/filter-name&gt;
        &lt;filter-class&gt;
            org.jboss.resteasy.plugins.server.servlet.FilterDispatcher
        &lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;javax.ws.rs.Application&lt;/param-name&gt;
            &lt;param-value&gt;com.restfully.shop.services.ShoppingApplication&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;

    &lt;filter-mapping&gt;
        &lt;filter-name&gt;Resteasy&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

&lt;/web-app&gt;</code></pre>
    </section>

    <section class="section" id="d5e474"><div class="titlepage"><div><div><h2 class="title">3.9. Client side</h2></div></div></div>
    

    <p>
        JAX-RS 2.0 conforming implementations such as RESTEasy support a client side framework which simplifies
        communicating with restful applications. In RESTEasy, the minimal set of modules needed for the client framework
        consists of resteasy-core and resteasy-client. You can access them by way of maven:
    </p>

<pre><code class="no-highlight">
&lt;dependency&gt;
    &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
    &lt;artifactId&gt;resteasy-core&lt;/artifactId&gt;
    &lt;version&gt;4.7.10.Final&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
    &lt;artifactId&gt;resteasy-client&lt;/artifactId&gt;
    &lt;version&gt;4.7.10.Final&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

    <p>
        Other modules, such as resteasy-jaxb-provider, may be brought in as needed.
    </p>

    </section>
</section>


   <section class="chapter" id="Using_Path"><div class="titlepage"><div><div><h1 class="title">Chapter 4. Using @Path and @GET, @POST, etc.</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="sect1"><a href="#_Path_and_regular_expression_mappings">4.1. @Path and regular expression mappings</a></span></li></ul></div>


<p>

</p><pre><code class="no-highlight">
@Path("/library")
public class Library {

   @GET
   @Path("/books")
   public String getBooks() {...}

   @GET
   @Path("/book/{isbn}")
   public String getBook(@PathParam("isbn") String id) {
      // search my database and get a string representation and return it
   }

   @PUT
   @Path("/book/{isbn}")
   public void addBook(@PathParam("isbn") String id, @QueryParam("name") String name) {...}

   @DELETE
   @Path("/book/{id}")
   public void removeBook(@PathParam("id") String id {...}
   
}
</code></pre><p>
</p>
<p>

Let's say you have the RESTEasy servlet configured and reachable at a root path of http://myhost.com/services.  The requests would be handled by the Library class:
</p>
<p>

</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
 GET http://myhost.com/services/library/books
</li><li class="listitem">
 GET http://myhost.com/services/library/book/333
</li><li class="listitem">
 PUT http://myhost.com/services/library/book/333
</li><li class="listitem">
 DELETE http://myhost.com/services/library/book/333
</li></ul></div><p>

</p>
<p>

The @javax.ws.rs.Path annotation must exist on either the class and/or a resource method.  If it exists on both the class and method, the relative path to the resource method is a concatenation of the class and method.
</p>
<p>

In the @javax.ws.rs package there are annotations for each HTTP method.  @GET, @POST, @PUT, @DELETE, and @HEAD.  You place these on public methods that you want to map to that certain kind of HTTP method.  As long as there is a @Path annotation on the class, you do not have to have a @Path annotation on the method you are mapping.  You can have more than one HTTP method as long as they can be distinguished from other methods.
</p>
<p>

When you have a @Path annotation on a method without an HTTP method, these are called JAXRSResourceLocators.
</p>
<p>


</p>
<section class="sect1" id="_Path_and_regular_expression_mappings"><div class="titlepage"><div><div><h2 class="title">4.1. @Path and regular expression mappings</h2></div></div></div>


<p>

The @Path annotation is not limited to simple path expressions.  You also have the ability to insert regular expressions into @Path's value.  For example:
</p>
<p>

</p><pre><code class="no-highlight">
@Path("/resources)
public class MyResource {

   @GET
   @Path("{var:.*}/stuff")
   public String get() {...}
}
</code></pre><p>
</p>
<p>

The following GETs will route to the getResource() method:
</p>
<p>

</p><pre><code class="no-highlight">
GET /resources/stuff
GET /resources/foo/stuff
GET /resources/on/and/on/stuff
</code></pre><p>
</p>
<p>

The format of the expression is:
</p>
<p>

</p><pre><code class="no-highlight">
"{" variable-name [ ":" regular-expression ] "}"
</code></pre><p>
</p>
<p>

The regular-expression part is optional.  When the expression is not provided, it defaults to a wildcard matching of one particular segment.  In regular-expression terms, the expression defaults to 
</p><pre><code class="no-highlight">
"([]*)"
</code></pre><p>
</p>
<p>

For example:
</p>
<p>

@Path("/resources/{var}/stuff")
</p>
<p>

will match these:
</p>
<p>

</p><pre><code class="no-highlight">
GET /resources/foo/stuff
GET /resources/bar/stuff
</code></pre><p>
</p>
<p>

but will not match:
</p>
<p>

</p><pre><code class="no-highlight">
GET /resources/a/bunch/of/stuff
</code></pre><p>
</p>
<p>

</p>
<p>

</p>
<p>


</p>
</section>
</section>

   <section class="chapter" id="_PathParam"><div class="titlepage"><div><div><h1 class="title">Chapter 5. @PathParam</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="sect1"><a href="#Advanced__PathParam_and_Regular_Expressions">5.1. Advanced @PathParam and Regular Expressions</a></span></li><li><span class="sect1"><a href="#_PathParam_and_PathSegment">5.2. @PathParam and PathSegment</a></span></li></ul></div>


<div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2>
   <p>
      RESTEasy <a class="link" href="#_NewParam" title="Chapter 13. Improved @…Param annotations">supports <code class="code">@PathParam</code> annotations with no parameter name.</a>.
   </p>
</div>

<p>

@PathParam is a parameter annotation which allows you to map variable URI path fragments into your method call.
</p>
<p>

</p><pre><code class="no-highlight">
@Path("/library")
public class Library {

   @GET
   @Path("/book/{isbn}")
   public String getBook(@PathParam("isbn") String id) {
      // search my database and get a string representation and return it
   }
}
</code></pre><p>
</p>
<p>

What this allows you to do is embed variable identification within the URIs of your resources.  In the above example, an isbn URI parameter is used
to pass information about the book we want to access.  The parameter type you inject into can be any primitive type, a String, or any Java object that has
a constructor that takes a String parameter, or a static valueOf method that takes a String as a parameter.  For example, lets say we wanted isbn to be a real object.  We could do:
</p>
<p>

</p><pre><code class="no-highlight">
@GET
@Path("/book/{isbn}")
public String getBook(@PathParam("isbn") ISBN id) {...}

public class ISBN {
   public ISBN(String str) {...}
}
</code></pre><p>
</p>
<p>

Or instead of a public String constructors, have a valueOf method:
</p>
<p>

</p><pre><code class="no-highlight">
public class ISBN {
    public static ISBN valueOf(String isbn) {...}
}
</code></pre><p>
</p>
<p>

</p>
<p>


</p>
<section class="sect1" id="Advanced__PathParam_and_Regular_Expressions"><div class="titlepage"><div><div><h2 class="title">5.1. Advanced @PathParam and Regular Expressions</h2></div></div></div>


<p>

There are a few more complicated uses of @PathParams not discussed in the previous section.
</p>
<p>

</p>
<p>


</p>
<p>

You are allowed to specify one or more path params embedded in one URI segment.  Here are some examples:
</p>
<p>

</p><pre><code class="no-highlight">
1. @Path("/aaa{param}bbb")
2. @Path("/{name}-{zip}")
3. @Path("/foo{name}-{zip}bar")
</code></pre><p>
</p>
<p>

So, a URI of "/aaa111bbb" would match #1.  "/bill-02115" would match #2.  "foobill-02115bar" would match #3.
</p>
<p>


</p>
<p>

We discussed before how you can use regular expression patterns within @Path values.
</p>
<p>

</p><pre><code class="no-highlight">
@GET
@Path("/aaa{param:b+}/{many:.*}/stuff")
public String getIt(@PathParam("param") String bs, @PathParam("many") String many) {...}
</code></pre><p>
</p>
<p>

For the following requests, lets see what the values of the "param" and "many" @PathParams would be:
</p>
<p>

</p><div class="table" id="d5e550"><div class="table-title">Table 5.1. </div><div class="table-contents">
<table style="border-collapse: collapse;border-top: 1px solid ; border-bottom: 1px solid ; "><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 1px  ; border-bottom: 1px  ; ">
Request</th><th style="border-right: 1px  ; border-bottom: 1px  ; ">
param</th><th style="border-bottom: 1px  ; ">
many</th></tr></thead><tbody><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
GET /aaabb/some/stuff</td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
bb</td><td style="border-bottom: 1px  ; ">
some</td></tr><tr><td style="border-right: 1px  ; ">
GET /aaab/a/lot/of/stuff</td><td style="border-right: 1px  ; ">
b</td><td>
a/lot/of</td></tr></tbody></table>
</div></div><p><br class="table-break"/>

</p>
<p>


</p>
</section>
<section class="sect1" id="_PathParam_and_PathSegment"><div class="titlepage"><div><div><h2 class="title">5.2. @PathParam and PathSegment</h2></div></div></div>


<p>

The specification has a very simple abstraction for examining a fragment of the URI path being invoked on  javax.ws.rs.core.PathSegment:
</p>
<p>

</p><pre><code class="no-highlight">
public interface PathSegment {

    /**
     * Get the path segment.
     * &lt;p&gt;
     * @return the path segment
     */
    String getPath();
    
    /**
     * Get a map of the matrix parameters associated with the path segment
     * @return the map of matrix parameters
     */
    MultivaluedMap&lt;String, String&gt; getMatrixParameters();

}
</code></pre><p>
</p>
<p>

You can have RESTEasy inject a PathSegment instead of a value with your @PathParam.
</p>
<p>

</p><pre><code class="no-highlight">
@GET
@Path("/book/{id}")
public String getBook(@PathParam("id") PathSegment id) {...}
</code></pre><p>
</p>
<p>

This is very useful if you have a bunch of @PathParams that use matrix parameters.  The idea of matrix parameters is
    that they are an arbitrary set of name-value pairs embedded in a uri path segment.  The PathSegment object gives you
    access to these parameters. See also MatrixParam.
</p>
<p>

A matrix parameter example is:
</p>
<p>

GET http://host.com/library/book;name=EJB 3.0;author=Bill Burke
</p>
<p>

The basic idea of matrix parameters is that it represents resources that are addressable by their attributes as well as their raw id.
</p>
<p>

</p>
<p>

</p>
<p>

</p>
<p>

</p>
<p>

</p>
<p>

</p>
<p>

</p>
<p>

</p>
<p>

</p>
<p>

</p>
<p>


</p>
</section>
</section>

   <section class="chapter" id="_QueryParam"><div class="titlepage"><div><div><h1 class="title">Chapter 6. @QueryParam</h1></div></div></div>


<div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2>
   <p>
      RESTEasy <a class="link" href="#_NewParam" title="Chapter 13. Improved @…Param annotations">supports <code class="code">@QueryParam</code> annotations with no parameter name.</a>.
   </p>
</div>

<p>

The @QueryParam annotation allows you to map a URI query string parameter or url form encoded parameter to your method invocation.
</p>
<p>

GET /books?num=5
</p>
<p>

</p><pre><code class="no-highlight">
@GET
public String getBooks(@QueryParam("num") int num) {
...
}
</code></pre><p>
</p>
<p>

Currently since RESTEasy is built on top of a Servlet, it does not distinguish between URI query strings or url form encoded parameters. Like PathParam, your parameter type can be an String, primitive, or class that has a String constructor or static valueOf() method.
</p>
<p>

</p>
<p>


</p>
</section>

   <section class="chapter" id="_HeaderParam"><div class="titlepage"><div><div><h1 class="title">Chapter 7. @HeaderParam</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="section"><a href="#d5e618">7.1. <code class="classname">HeaderDelegate</code>s</a></span></li></ul></div>


<div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2>
   <p>
      RESTEasy <a class="link" href="#_NewParam" title="Chapter 13. Improved @…Param annotations">supports <code class="code">@HeaderParam</code> annotations with no parameter name.</a>.
   </p>
</div>

<p>

The @HeaderParam annotation allows you to map a request HTTP header to your method invocation.
</p>
<p>

GET /books?num=5
</p>
<p>

</p><pre><code class="no-highlight">
@GET
public String getBooks(@HeaderParam("From") String from) {
...
}
</code></pre><p>
</p>
<p>

Like PathParam, your parameter type can be an String, primitive, or class that has a String constructor or static valueOf() method.  For example, MediaType has a valueOf() method and you could do:
</p>
<p>

</p><pre><code class="no-highlight">
@PUT
public void put(@HeaderParam("Content-Type") MediaType contentType, ...)
</code></pre><p>
</p>
<p>

</p>
<p>


</p>

<section class="section" id="d5e618"><div class="titlepage"><div><div><h2 class="title">7.1. <code class="classname">HeaderDelegate</code>s</h2></div></div></div>


<p>
In addition to the usual methods for translating parameters to and from strings, parameters annotated
with <code class="classname">@HeaderParam</code> have another option: implementations of 
<code class="classname">RuntimeDelegate$HeaderDelegate</code>:
</p>

<pre><code class="no-highlight">
    /**
     * Defines the contract for a delegate that is responsible for
     * converting between the String form of a HTTP header and
     * the corresponding JAX-RS type {@code T}.
     *
     * @param &lt;T&gt; a JAX-RS type that corresponds to the value of a HTTP header.
     */
    public static interface HeaderDelegate&lt;T&gt; {

        /**
         * Parse the supplied value and create an instance of {@code T}.
         *
         * @param value the string value.
         * @return the newly created instance of {@code T}.
         * @throws IllegalArgumentException if the supplied string cannot be
         *                                  parsed or is {@code null}.
         */
        public T fromString(String value);

        /**
         * Convert the supplied value to a String.
         *
         * @param value the value of type {@code T}.
         * @return a String representation of the value.
         * @throws IllegalArgumentException if the supplied object cannot be
         *                                  serialized or is {@code null}.
         */
        public String toString(T value);
    }
</code></pre>

<p>
<code class="classname">HeaderDelegate</code> is similar to <code class="classname">ParamConverter</code>, but it is not
very convenient to register a <code class="classname">HeaderDelegate</code> since, unlike, for example,
<code class="classname">ParamConverterProvider</code>, it is not treated by the JAX-RS specification as a provider.
The class <code class="classname">javax.ws.rs.core.Configurable</code>, which is subclassed by, for example,
<code class="classname">org.jboss.resteasy.spi.ResteasyProviderFactory</code> has methods like
</p>

<pre><code class="no-highlight">
    /**
     * Register a class of a custom JAX-RS component (such as an extension provider or
     * a {@link javax.ws.rs.core.Feature feature} meta-provider) to be instantiated
     * and used in the scope of this configurable context.
     *
     * ...
     *
     * @param componentClass JAX-RS component class to be configured in the scope of this
     *                       configurable context.
     * @return the updated configurable context.
     */
    public C register(Class&lt;?&gt; componentClass);
</code></pre>

<p>
but it is not clear that they are applicable to <code class="classname">HeaderDelegate</code>s.
</p>

<p>
RESTEasy approaches this problem by allowing <code class="classname">HeaderDelegate</code>s to be annotated
with <code class="classname">@Provider</code>. Not only will <code class="methodname">ResteasyProviderFactory.register()</code>
process <code class="classname">HeaderDelegate</code>s, but another useful consequence is that
<code class="classname">HeaderDelegate</code>s can be discovered automatically at runtime.
</p>
</section>
</section>

   
<section class="chapter" id="LinkHeader"><div class="titlepage"><div><div><h1 class="title">Chapter 8. Linking resources</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="section"><a href="#d5e644">8.1. Link Headers</a></span></li><li><span class="section"><a href="#d5e649">8.2. Atom links in the resource representations</a></span><ul><li><span class="section"><a href="#d5e656">8.2.1. Configuration</a></span></li><li><span class="section"><a href="#d5e671">8.2.2. Your first links injected</a></span></li><li><span class="section"><a href="#d5e692">8.2.3. Customising how the Atom links are serialised</a></span></li><li><span class="section"><a href="#d5e698">8.2.4. Specifying which JAX-RS methods are tied to which resources</a></span></li><li><span class="section"><a href="#d5e763">8.2.5. Specifying path parameter values for URI templates</a></span></li><li><span class="section"><a href="#d5e837">8.2.6. Securing entities</a></span></li><li><span class="section"><a href="#d5e862">8.2.7. Extending the UEL context</a></span></li><li><span class="section"><a href="#d5e878">8.2.8. Resource facades</a></span></li></ul></li></ul></div>
	
	<p>
		There are two mechanisms available in RESTEasy to link a resource to another, and to link resources to
		operations: the Link HTTP header, and Atom links inside the resource representations.
	</p>
	<section class="section" id="d5e644"><div class="titlepage"><div><div><h2 class="title">8.1. Link Headers</h2></div></div></div>
		
		<p>
		RESTEasy has both client and server side support for the <a class="ulink" href="http://tools.ietf.org/html/draft-nottingham-http-link-header-06">Link header specification</a>.
		See the javadocs for org.jboss.resteasy.spi.LinkHeader, org.jboss.resteasy.spi.Link, and org.jboss.resteasy.client.ClientResponse.
		</p>
		<p>
		The main advantage of Link headers over Atom links in the resource is that those links are available
		without parsing the entity body.
		</p>
	</section>
	<section class="section" id="d5e649"><div class="titlepage"><div><div><h2 class="title">8.2. Atom links in the resource representations</h2></div></div></div>
		
		<p>
		RESTEasy allows you to inject <a class="ulink" href="http://tools.ietf.org/html/rfc4287#section-4.2.7">Atom links</a> directly inside the entity objects you are sending to the
		client, via auto-discovery.
		</p>
		<div style="margin-left: 0.5in; margin-right: 0.5in;" class="warning"><h2>Warning</h2>
			<p>This is only available when using the Jackson2 or JAXB providers (for JSON and XML).</p>
		</div>
		<p>
		The main advantage over Link headers is that you can have any number of Atom links directly over the
		concerned resources, for any number of resources in the response. For example, you can have Atom links
		for the root response entity, and also for each of its children entities.
		</p>
		<section class="section" id="d5e656"><div class="titlepage"><div><div><h3 class="title">8.2.1. Configuration</h3></div></div></div>
			
			<p>
				There is no configuration required to be able to inject Atom links in your resource
				representation, you just have to have this maven artifact in your path:
			</p>
			<div class="table" id="d5e659"><div class="table-title">Table 8.1. Maven artifact for Atom link injection</div><div class="table-contents"><table>
				
				<thead>
					<tr>
						<th>Group</th>
						<th>Artifact</th>
						<th>Version</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>org.jboss.resteasy</td>
						<td>resteasy-links</td>
						<td>4.7.10.Final</td>
					</tr>
				</tbody>
			</table></div></div><br class="table-break"/>
		</section>
		<section class="section" id="d5e671"><div class="titlepage"><div><div><h3 class="title">8.2.2. Your first links injected</h3></div></div></div>
			
			<p>
			You need three things in order to tell RESTEasy to inject Atom links in your entities:
			</p>
			<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
					<p>
					Annotate the JAX-RS method with <code class="classname">@AddLinks</code> to indicate that you want
					Atom links injected in your response entity.
					</p>
				</li><li class="listitem">
					<p>
					Add <code class="classname">RESTServiceDiscovery</code> fields to the resource classes where you
					want Atom links injected.
					</p>
				</li><li class="listitem">
					<p>
					Annotate the JAX-RS methods you want Atom links for with <code class="classname">@LinkResource</code>,
					so that RESTEasy knows which links to create for which resources.
					</p>
				</li></ul></div>
			<p>
			The following example illustrates how you would declare everything in order to get the Atom links
			injected in your book store:
			</p>
			<pre><code class="language-java">@Path("/")
@Consumes({"application/xml", "application/json"})
@Produces({"application/xml", "application/json"})
public interface BookStore {

	@AddLinks
	@LinkResource(value = Book.class)
	@GET
	@Path("books")
	public Collection&lt;Book&gt; getBooks();

	@LinkResource
	@POST
	@Path("books")
	public void addBook(Book book);

	@AddLinks
	@LinkResource
	@GET
	@Path("book/{id}")
	public Book getBook(@PathParam("id") String id);

	@LinkResource
	@PUT
	@Path("book/{id}")
	public void updateBook(@PathParam("id") String id, Book book);

	@LinkResource(value = Book.class)
	@DELETE
	@Path("book/{id}")
	public void deleteBook(@PathParam("id") String id);
}</code></pre>
			<p>
			And this is the definition of the Book resource:
			</p>
			<pre><code class="language-java">@Mapped(namespaceMap = @XmlNsMap(jsonName = "atom", namespace = "http://www.w3.org/2005/Atom"))
@XmlRootElement
@XmlAccessorType(XmlAccessType.NONE)
public class Book {
	@XmlAttribute
	private String author;

	@XmlID
	@XmlAttribute
	private String title;

	@XmlElementRef
	private RESTServiceDiscovery rest;
}</code></pre>
			<p>
			If you do a GET /order/foo you will then get this XML representation:
			</p>
			<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;book xmlns:atom="http://www.w3.org/2005/Atom" title="foo" author="bar"&gt;
 &lt;atom:link href="http://localhost:8081/books" rel="list"/&gt;
 &lt;atom:link href="http://localhost:8081/books" rel="add"/&gt;
 &lt;atom:link href="http://localhost:8081/book/foo" rel="self"/&gt;
 &lt;atom:link href="http://localhost:8081/book/foo" rel="update"/&gt;
 &lt;atom:link href="http://localhost:8081/book/foo" rel="remove"/&gt;
&lt;/book&gt;</code></pre>
			<p>
			And in JSON format:
			</p>
			<pre><code class="language-javascript">{
 "book":
 {
  "@title":"foo",
  "@author":"bar",
  "atom.link":
   [
    {"@href":"http://localhost:8081/books","@rel":"list"},
    {"@href":"http://localhost:8081/books","@rel":"add"},
    {"@href":"http://localhost:8081/book/foo","@rel":"self"},
    {"@href":"http://localhost:8081/book/foo","@rel":"update"},
    {"@href":"http://localhost:8081/book/foo","@rel":"remove"}
   ]
 }
}</code></pre>
		</section>
		<section class="section" id="d5e692"><div class="titlepage"><div><div><h3 class="title">8.2.3. Customising how the Atom links are serialised</h3></div></div></div>
			
			<p>
			Because the <code class="classname">RESTServiceDiscovery</code> is in fact a JAXB type which inherits from
			<code class="classname">List</code> you are free to annotate it as you want to customise the JAXB serialisation,
			or just rely on the default with <code class="classname">@XmlElementRef</code>.
			</p>
		</section>
		<section class="section" id="d5e698"><div class="titlepage"><div><div><h3 class="title">8.2.4. Specifying which JAX-RS methods are tied to which resources</h3></div></div></div>
			
			<p>
			This is all done by annotating the methods with the <code class="classname">@LinkResource</code> annotation.
			It supports the following optional parameters:
			</p>
			<div class="table" id="d5e702"><div class="table-title">Table 8.2. <p><code class="classname">@LinkResource</code> parameters</p></div><div class="table-contents"><table>
				
				<thead>
					<tr>
						<th>Parameter</th>
						<th>Type</th>
						<th>Function</th>
						<th>Default</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>value</td>
						<td><code class="classname">Class</code></td>
						<td>Declares an Atom link for the given type of resources.</td>
						<td>Defaults to the entity body type (non-annotated parameter), or the method's return type.
						This default does not work with <code class="classname">Response</code> or <code class="classname">Collection</code>
						types, they need to be explicitly specified.</td>
					</tr>
					<tr>
						<td>rel</td>
						<td><code class="classname">String</code></td>
						<td>The Atom link relation</td>
						<td>
							<div class="variablelist"><dl class="variablelist"><dt><span class="term">list</span></dt><dd><p>For <code class="classname">GET</code> methods returning a <code class="classname">Collection</code></p></dd><dt><span class="term">self</span></dt><dd><p>For <code class="classname">GET</code> methods returning a non-<code class="classname">Collection</code></p></dd><dt><span class="term">remove</span></dt><dd><p>For <code class="classname">DELETE</code> methods</p></dd><dt><span class="term">update</span></dt><dd><p>For <code class="classname">PUT</code> methods</p></dd><dt><span class="term">add</span></dt><dd><p>For <code class="classname">POST</code> methods</p></dd></dl></div>
						</td>
					</tr>
				</tbody>
			</table></div></div><br class="table-break"/>
			<p>
			You can add several <code class="classname">@LinkResource</code> annotations on a single method by enclosing
			them in	a <code class="classname">@LinkResources</code> annotation. This way you can add links to the same
			method on several resource types. For example the <code class="constant">/order/foo/comments</code> operation
			can belongs on the <code class="classname">Order</code> resource with the <code class="constant">comments</code>
			relation, and on the <code class="classname">Comment</code> resource with the <code class="constant">list</code>
			relation.
			</p>
		</section>
		<section class="section" id="d5e763"><div class="titlepage"><div><div><h3 class="title">8.2.5. Specifying path parameter values for URI templates</h3></div></div></div>
			
			<p>
			When RESTEasy adds links to your resources it needs to insert the right values in the URI template.
			This is done either automatically by guessing the list of values from the entity, or by specifying
			the values in the <code class="classname">@LinkResource</code> <code class="varname">pathParameters</code> parameter.
			</p>
			<section class="section" id="d5e768"><div class="titlepage"><div><div><h4 class="title">8.2.5.1. Loading URI template values from the entity</h4></div></div></div>
				
				<p>
					URI template values are extracted from the entity from fields or Java Bean properties
					annotated with <code class="classname">@ResourceID</code>, JAXB's <code class="classname">@XmlID</code> or
					JPA's <code class="classname">@Id</code>. If there are more than one URI template
					value to find in a given entity, you can annotate your entity with <code class="classname">@ResourceIDs</code>
					to list the names of fields or properties that make up this entity's Id. If there are other
					URI template values required from a parent entity, we try to find that parent in a field or
					Java Bean property
					annotated with <code class="classname">@ParentResource</code>. The list of URI template
					values extracted up every <code class="classname">@ParentResource</code> is then reversed and used
					as the list of values for the URI template.
				</p>
				<p>For example, let's consider the previous Book example, and a list of comments:</p>
			<pre><code class="language-java">@XmlRootElement
@XmlAccessorType(XmlAccessType.NONE)
public class Comment {
	@ParentResource
	private Book book;

	@XmlElement
	private String author;

	@XmlID
	@XmlAttribute
	private String id;

	@XmlElementRef
	private RESTServiceDiscovery rest;
}</code></pre>
				<p>
				Given the previous book store service augmented with comments:
				</p>
			<pre><code class="language-java">@Path("/")
@Consumes({"application/xml", "application/json"})
@Produces({"application/xml", "application/json"})
public interface BookStore {

	@AddLinks
	@LinkResources({
		@LinkResource(value = Book.class, rel = "comments"),
		@LinkResource(value = Comment.class)
	})
	@GET
	@Path("book/{id}/comments")
	public Collection&lt;Comment&gt; getComments(@PathParam("id") String bookId);

	@AddLinks
	@LinkResource
	@GET
	@Path("book/{id}/comment/{cid}")
	public Comment getComment(@PathParam("id") String bookId, @PathParam("cid") String commentId);

	@LinkResource
	@POST
	@Path("book/{id}/comments")
	public void addComment(@PathParam("id") String bookId, Comment comment);

	@LinkResource
	@PUT
	@Path("book/{id}/comment/{cid}")
	public void updateComment(@PathParam("id") String bookId, @PathParam("cid") String commentId, Comment comment);

	@LinkResource(Comment.class)
	@DELETE
	@Path("book/{id}/comment/{cid}")
	public void deleteComment(@PathParam("id") String bookId, @PathParam("cid") String commentId);

}</code></pre>
				<p>
				Whenever we need to make links for a <code class="classname">Book</code> entity, we look up the ID
				in the <code class="classname">Book</code>'s <code class="classname">@XmlID</code> property. Whenever we make links
				for <code class="classname">Comment</code> entities, we have a list of values taken from the <code class="classname">Comment</code>'s
				<code class="classname">@XmlID</code> and its <code class="classname">@ParentResource</code>: the <code class="classname">Book</code> and
				its <code class="classname">@XmlID</code>.
				</p>
				<p>
				For a <code class="classname">Comment</code> with <code class="varname">id</code> <code class="constant">"1"</code> on a <code class="classname">Book</code>
				with <code class="varname">title</code> <code class="constant">"foo"</code> we will therefore get a list of URI
				template values of <code class="constant">{"foo", "1"}</code>, to be replaced in the URI template, thus
				obtaining either <code class="constant">"/book/foo/comments"</code> or <code class="constant">"/book/foo/comment/1"</code>.
				</p>
			</section>
			<section class="section" id="d5e801"><div class="titlepage"><div><div><h4 class="title">8.2.5.2. Specifying path parameters manually</h4></div></div></div>
				
				<p>
				If you do not want to annotate your entities with resource ID annotations (<code class="classname">@ResourceID</code>,
				<code class="classname">@ResourceIDs</code>, <code class="classname">@XmlID</code> or <code class="classname">@Id</code>) and
				<code class="classname">@ParentResource</code>, you can also specify the URI template values inside the
				<code class="classname">@LinkResource</code> annotation, using Unified Expression Language expressions:
				</p>
				<div class="table" id="d5e810"><div class="table-title">Table 8.3. <p><code class="classname">@LinkResource</code> URI template parameter</p></div><div class="table-contents"><table>
					
					<thead>
						<tr>
							<th>Parameter</th>
							<th>Type</th>
							<th>Function</th>
							<th>Default</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>pathParameters</td>
							<td><code class="classname">String[]</code></td>
							<td>Declares a list of UEL expressions to obtain the URI template values.</td>
							<td>Defaults to using <code class="classname">@ResourceID</code>, <code class="classname">@ResourceIDs</code>,
							<code class="classname">@XmlID</code> or <code class="classname">@Id</code> and <code class="classname">@ParentResource</code>
							annotations to extract the values from the model.</td>
						</tr>
					</tbody>
				</table></div></div><br class="table-break"/>
				<p>
				The UEL expressions are evaluated in the context of the entity, which means that any unqualified
				variable will be taken as a property for the entity itself, with the special variable
				<code class="varname">this</code> bound to the entity we're generating links for.
				</p>
				<p>
				The previous example of <code class="classname">Comment</code> service could be declared as such:
				</p>
				<pre><code class="language-java">@Path("/")
@Consumes({"application/xml", "application/json"})
@Produces({"application/xml", "application/json"})
public interface BookStore {

	@AddLinks
	@LinkResources({
		@LinkResource(value = Book.class, rel = "comments", pathParameters = "${title}"),
		@LinkResource(value = Comment.class, pathParameters = {"${book.title}", "${id}"})
	})
	@GET
	@Path("book/{id}/comments")
	public Collection&lt;Comment&gt; getComments(@PathParam("id") String bookId);

	@AddLinks
	@LinkResource(pathParameters = {"${book.title}", "${id}"})
	@GET
	@Path("book/{id}/comment/{cid}")
	public Comment getComment(@PathParam("id") String bookId, @PathParam("cid") String commentId);

	@LinkResource(pathParameters = {"${book.title}", "${id}"})
	@POST
	@Path("book/{id}/comments")
	public void addComment(@PathParam("id") String bookId, Comment comment);

	@LinkResource(pathParameters = {"${book.title}", "${id}"})
	@PUT
	@Path("book/{id}/comment/{cid}")
	public void updateComment(@PathParam("id") String bookId, @PathParam("cid") String commentId, Comment comment);

	@LinkResource(Comment.class, pathParameters = {"${book.title}", "${id}"})
	@DELETE
	@Path("book/{id}/comment/{cid}")
	public void deleteComment(@PathParam("id") String bookId, @PathParam("cid") String commentId);

}</code></pre>
			</section>
		</section>
		<section class="section" id="d5e837"><div class="titlepage"><div><div><h3 class="title">8.2.6. Securing entities</h3></div></div></div>
			
			<p>
			You can restrict which links are injected in the resource based on security restrictions for the client,
			so that if the current client doesn't have permission to delete a resource he will not be presented
			with the <code class="constant">"delete"</code> link relation.
			</p>
			<p>
			Security restrictions can either be specified on the <code class="classname">@LinkResource</code> annotation,
			or using RESTEasy and EJB's security annotation <code class="classname">@RolesAllowed</code> on the JAX-RS
			method.
			</p>
			<div class="table" id="d5e844"><div class="table-title">Table 8.4. <p><code class="classname">@LinkResource</code> security restrictions</p></div><div class="table-contents"><table>
				
				<thead>
					<tr>
						<th>Parameter</th>
						<th>Type</th>
						<th>Function</th>
						<th>Default</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>constraint</td>
						<td><code class="classname">String</code></td>
						<td>A UEL expression which must evaluate to true to inject this method's link in the
						response entity.</td>
						<td>Defaults to using <code class="classname">@RolesAllowed</code> from the JAX-RS method.</td>
					</tr>
				</tbody>
			</table></div></div><br class="table-break"/>
		</section>
		<section class="section" id="d5e862"><div class="titlepage"><div><div><h3 class="title">8.2.7. Extending the UEL context</h3></div></div></div>
			
			<p>
			We've seen that both the URI template values and the security constraints of <code class="classname">@LinkResource</code>
			use UEL to evaluate expressions, and we provide a basic UEL context with access only to the entity
			we're injecting links in, and nothing more.
			</p>
			<p>
			If you want to add more variables or functions in this
			context, you can by adding a <code class="classname">@LinkELProvider</code> annotation on the JAX-RS method,
			its class, or its package. This annotation's value should point to a class that implements the
			<code class="classname">ELProvider</code> interface, which wraps the default <code class="classname">ELContext</code>
			in order to add any missing functions.
			</p>
			<p>
			For example, if you want to support the Seam annotation <code class="varname">s:hasPermission(target, permission)</code>
			in your security constraints, you can add a <code class="classname">package-info.java</code> file like this:
			</p>
			<pre><code class="language-java">@LinkELProvider(SeamELProvider.class)
package org.jboss.resteasy.links.test;

import org.jboss.resteasy.links.*;</code></pre>
			<p>
			With the following provider implementation:
			</p>
			<pre><code class="language-java">package org.jboss.resteasy.links.test;

import javax.el.ELContext;
import javax.el.ELResolver;
import javax.el.FunctionMapper;
import javax.el.VariableMapper;

import org.jboss.seam.el.SeamFunctionMapper;

import org.jboss.resteasy.links.ELProvider;

public class SeamELProvider implements ELProvider {

	public ELContext getContext(final ELContext ctx) {
		return new ELContext() {

			private SeamFunctionMapper functionMapper;

			@Override
			public ELResolver getELResolver() {
				return ctx.getELResolver();
			}

			@Override
			public FunctionMapper getFunctionMapper() {
				if (functionMapper == null)
					functionMapper = new SeamFunctionMapper(ctx
							.getFunctionMapper());
				return functionMapper;
			}

			@Override
			public VariableMapper getVariableMapper() {
				return ctx.getVariableMapper();
			}
		};
	}

}</code></pre>
			<p>
			And then use it as such:
			</p>
				<pre><code class="language-java">@Path("/")
@Consumes({"application/xml", "application/json"})
@Produces({"application/xml", "application/json"})
public interface BookStore {

	@AddLinks
	@LinkResources({
		@LinkResource(value = Book.class, rel = "comments", constraint = "${s:hasPermission(this, 'add-comment')}"),
		@LinkResource(value = Comment.class, constraint = "${s:hasPermission(this, 'insert')}")
	})
	@GET
	@Path("book/{id}/comments")
	public Collection&lt;Comment&gt; getComments(@PathParam("id") String bookId);

	@AddLinks
	@LinkResource(constraint = "${s:hasPermission(this, 'read')}")
	@GET
	@Path("book/{id}/comment/{cid}")
	public Comment getComment(@PathParam("id") String bookId, @PathParam("cid") String commentId);

	@LinkResource(constraint = "${s:hasPermission(this, 'insert')}")
	@POST
	@Path("book/{id}/comments")
	public void addComment(@PathParam("id") String bookId, Comment comment);

	@LinkResource(constraint = "${s:hasPermission(this, 'update')}")
	@PUT
	@Path("book/{id}/comment/{cid}")
	public void updateComment(@PathParam("id") String bookId, @PathParam("cid") String commentId, Comment comment);

	@LinkResource(Comment.class, constraint = "${s:hasPermission(this, 'delete')}")
	@DELETE
	@Path("book/{id}/comment/{cid}")
	public void deleteComment(@PathParam("id") String bookId, @PathParam("cid") String commentId);

}</code></pre>
		</section>
		<section class="section" id="d5e878"><div class="titlepage"><div><div><h3 class="title">8.2.8. Resource facades</h3></div></div></div>
			
			<p>
			Sometimes it is useful to add resources which are just containers or layers on other resources. For
			example if you want to represent a collection of <code class="classname">Comment</code> with a start index
			and a certain number of entries, in order to implement paging. Such a collection is not really an
			entity in your model, but it should obtain the <code class="constant">"add"</code> and <code class="constant">"list"</code>
			link relations for the <code class="constant">Comment</code> entity.
			</p>
			<p>
			This is possible using resource facades. A resource facade is a resource which implements the
			<code class="classname">ResourceFacade&lt;T&gt;</code> interface for the type <code class="varname">T</code>, and as
			such, should receive all links for that type.
			</p>
			<p>
			Since in most cases the instance of the <code class="varname">T</code> type is not directly available in the
			resource facade, we need another way to extract its URI template values, and this is done by calling
			the resource facade's <code class="methodname">pathParameters()</code> method to obtain a map of URI template
			values by name. This map will be used to fill in the URI template values for any link generated for
			<code class="varname">T</code>, if there are enough values in the map.
			</p>
			<p>
			Here is an example of such a resource facade for a collection of <code class="classname">Comment</code>s:
			</p>
				<pre><code class="language-java">@XmlRootElement
@XmlAccessorType(XmlAccessType.NONE)
public class ScrollableCollection implements ResourceFacade&lt;Comment&gt; {

	private String bookId;
	@XmlAttribute
	private int start;
	@XmlAttribute
	private int totalRecords;
	@XmlElement
	private List&lt;Comment&gt; comments = new ArrayList&lt;Comment&gt;();
	@XmlElementRef
	private RESTServiceDiscovery rest;

	public Class&lt;Comment&gt; facadeFor() {
		return Comment.class;
	}

	public Map&lt;String, ? extends Object&gt; pathParameters() {
		HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
		map.put("id", bookId);
		return map;
	}
}</code></pre>
			<p>
			This will produce such an XML collection:
			</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;collection xmlns:atom="http://www.w3.org/2005/Atom" totalRecords="2" start="0"&gt;
 &lt;atom.link href="http://localhost:8081/book/foo/comments" rel="add"/&gt;
 &lt;atom.link href="http://localhost:8081/book/foo/comments" rel="list"/&gt;
 &lt;comment xmlid="0"&gt;
  &lt;text&gt;great book&lt;/text&gt;
  &lt;atom.link href="http://localhost:8081/book/foo/comment/0" rel="self"/&gt;
  &lt;atom.link href="http://localhost:8081/book/foo/comment/0" rel="update"/&gt;
  &lt;atom.link href="http://localhost:8081/book/foo/comment/0" rel="remove"/&gt;
  &lt;atom.link href="http://localhost:8081/book/foo/comments" rel="add"/&gt;
  &lt;atom.link href="http://localhost:8081/book/foo/comments" rel="list"/&gt;
 &lt;/comment&gt;
 &lt;comment xmlid="1"&gt;
  &lt;text&gt;terrible book&lt;/text&gt;
  &lt;atom.link href="http://localhost:8081/book/foo/comment/1" rel="self"/&gt;
  &lt;atom.link href="http://localhost:8081/book/foo/comment/1" rel="update"/&gt;
  &lt;atom.link href="http://localhost:8081/book/foo/comment/1" rel="remove"/&gt;
  &lt;atom.link href="http://localhost:8081/book/foo/comments" rel="add"/&gt;
  &lt;atom.link href="http://localhost:8081/book/foo/comments" rel="list"/&gt;
 &lt;/comment&gt;
&lt;/collection&gt;
</code></pre>
		</section>
	</section>
</section>

   <section class="chapter" id="_MatrixParam"><div class="titlepage"><div><div><h1 class="title">Chapter 9. @MatrixParam</h1></div></div></div>


<div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2>
   <p>
      RESTEasy <a class="link" href="#_NewParam" title="Chapter 13. Improved @…Param annotations">supports <code class="code">@MatrixParam</code> annotations with no parameter name.</a>.
   </p>
</div>

<p>

The idea of matrix parameters is that they are an arbitrary set of name-value pairs embedded in a uri path segment.  
A matrix parameter example is:
</p>
<p>

GET http://host.com/library/book;name=EJB 3.0;author=Bill Burke
</p>
<p>

The basic idea of matrix parameters is that it represents resources that are addressable by their attributes as well as their raw id.  The @MatrixParam annotation allows you to inject URI matrix parameters into your method invocation
</p>
<p>

</p><pre><code class="no-highlight">
@GET
public String getBook(@MatrixParam("name") String name, @MatrixParam("author") String author) {...}
</code></pre><p>
</p>
<p>

There is one big problem with @MatrixParam that the current version of the specification does not resolve.  What if the same MatrixParam exists twice in different path segments?  In this case, right now, its probably better to use PathParam combined with PathSegment.
</p>
<p>

</p>
<p>

</p>
<p>


</p>
</section>

   <section class="chapter" id="_CookieParam"><div class="titlepage"><div><div><h1 class="title">Chapter 10. @CookieParam</h1></div></div></div>


<div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2>
   <p>
      RESTEasy <a class="link" href="#_NewParam" title="Chapter 13. Improved @…Param annotations">supports <code class="code">@CookieParam</code> annotations with no parameter name.</a>.
   </p>
</div>

<p>

The @CookieParam annotation allows you to inject the value of a cookie or an object representation of an HTTP request cookie into your method invocation
</p>
<p>

GET /books?num=5
</p>
<p>

</p><pre><code class="no-highlight">
@GET
public String getBooks(@CookieParam("sessionid") int id) {
...
}

@GET
public String getBooks(@CookieParam("sessionid") javax.ws.rs.core.Cookie id) {...}
</code></pre><p>
</p>
<p>

Like PathParam, your parameter type can be an String, primitive, or class that has a String constructor or static valueOf() method.  You can also get an object representation of the cookie via the javax.ws.rs.core.Cookie class.
</p>
<p>

</p>
<p>


</p>
</section>

   <section class="chapter" id="_FormParam"><div class="titlepage"><div><div><h1 class="title">Chapter 11. @FormParam</h1></div></div></div>


<div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2>
   <p>
      RESTEasy <a class="link" href="#_NewParam" title="Chapter 13. Improved @…Param annotations">supports <code class="code">@FormParam</code> annotations with no parameter name.</a>.
   </p>
</div>

<p>

When the input request body is of the type "application/x-www-form-urlencoded", a.k.a. an HTML Form, you can inject individual form parameters from the request body into method parameter values.
</p>
<p>

</p><pre><code class="no-highlight">
&lt;form method="POST" action="/resources/service"&gt;
First name: 
&lt;input type="text" name="firstname"&gt;
&lt;br&gt;
Last name: 
&lt;input type="text" name="lastname"&gt;
&lt;/form&gt;
</code></pre><p>
</p>
<p>

If you post through that form, this is what the service might look like:
</p>
<p>

</p><pre><code class="no-highlight">
@Path("/")
public class NameRegistry {

   @Path("/resources/service")
   @POST
   public void addName(@FormParam("firstname") String first, @FormParam("lastname") String last) {...}

</code></pre><p>
</p>
<p>

You cannot combine @FormParam with the default "application/x-www-form-urlencoded" that unmarshalls to a MultivaluedMap&lt;String, String&gt;.  i.e. This is illegal:
</p>
<p>

</p><pre><code class="no-highlight">
@Path("/")
public class NameRegistry {

   @Path("/resources/service")
   @POST
   @Consumes("application/x-www-form-urlencoded")
   public void addName(@FormParam("firstname") String first, MultivaluedMap&lt;String, String&gt; form) {...}

</code></pre><p>
</p>
<p>


</p>
</section>

   <section class="chapter" id="_Form"><div class="titlepage"><div><div><h1 class="title">Chapter 12. @Form</h1></div></div></div>


<p>

This is a RESTEasy specific annotation that allows you to re-use any @*Param annotation within an injected class.  RESTEasy will instantiate the class and inject values into any annotated @*Param or @Context property.  This is useful if you have a lot of parameters on your method and you want to condense them into a value object.
</p>
<p>

</p>
<p>

</p><pre><code class="no-highlight">
public class MyForm {

    @FormParam("stuff")
    private int stuff;

    @HeaderParam("myHeader")
    private String header;

    @PathParam("foo")
    public void setFoo(String foo) {...}
}


@POST
@Path("/myservice")
public void post(@Form MyForm form) {...}
</code></pre><p>
</p>
<p>

When somebody posts to /myservice, RESTEasy will instantiate an instance of MyForm and inject the form parameter "stuff" into the "stuff" field, the header "myheader" into the header field, and call the setFoo method with the path param variable of "foo".
</p>
<p>

</p>
<p>
Also, @Form has some expanded @FormParam features.  If you specify a prefix within the Form param, this will prepend a prefix to any form parameter lookup.  For example,
    let's say you have one Address class, but want to reference invoice and shipping addresses from the same set of form parameters:
</p>
<pre><code class="no-highlight">
public static class Person
{
    @FormParam("name")
    private String name;

    @Form(prefix = "invoice")
    private Address invoice;

    @Form(prefix = "shipping")
    private Address shipping;
}

public static class Address
{
    @FormParam("street")
    private String street;
}

@Path("person")
public static class MyResource
{
    @POST
    @Produces(MediaType.TEXT_PLAIN)
    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)
    public String post(@Form Person p)
    {
        return p.toString();
    }
}
</code></pre>
    <p>
        In this example, the client could send the following form parameters:
    </p>
<pre><code class="no-highlight">
name=bill
invoice.street=xxx
shipping.street=yyy
</code></pre>
    <p>
        The Person.invoice and Person.shipping fields would be populated appropriately. Also, prefix mappings also support lists and maps:
    </p>
<pre><code class="no-highlight">
public static class Person {
    @Form(prefix="telephoneNumbers") List&lt;TelephoneNumber&gt; telephoneNumbers;
    @Form(prefix="address") Map&lt;String, Address&gt; addresses;
}

public static class TelephoneNumber {
    @FormParam("countryCode") private String countryCode;
    @FormParam("number") private String number;
}

public static class Address {
    @FormParam("street") private String street;
    @FormParam("houseNumber") private String houseNumber;
}

@Path("person")
public static class MyResource {

    @POST
    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)
    public void post (@Form Person p) {} 
</code></pre>
    <p>The following form params could be submitted and the Person.telephoneNumbers and Person.addresses fields would be populated appropriately</p>
<pre><code class="no-highlight">
request.addFormHeader("telephoneNumbers[0].countryCode", "31");
request.addFormHeader("telephoneNumbers[0].number", "0612345678");
request.addFormHeader("telephoneNumbers[1].countryCode", "91");
request.addFormHeader("telephoneNumbers[1].number", "9717738723");
request.addFormHeader("address[INVOICE].street", "Main Street");
request.addFormHeader("address[INVOICE].houseNumber", "2");
request.addFormHeader("address[SHIPPING].street", "Square One");
request.addFormHeader("address[SHIPPING].houseNumber", "13");
</code></pre>

</section>

   <section class="chapter" id="_NewParam"><div class="titlepage"><div><div><h1 class="title">Chapter 13. Improved <code class="code">@…Param</code> annotations</h1></div></div></div>


<p>
With the addition of parameter names in the bytecode since Java 8, it is no longer necessary to require users to specify parameter names
in the following annotations: <a class="link" href="#_PathParam" title="Chapter 5. @PathParam"><code class="code">@PathParam</code></a>, 
<a class="link" href="#_QueryParam" title="Chapter 6. @QueryParam"><code class="code">@QueryParam</code></a>, <a class="link" href="#_FormParam" title="Chapter 11. @FormParam"><code class="code">@FormParam</code></a>,
<a class="link" href="#_CookieParam" title="Chapter 10. @CookieParam"><code class="code">@CookieParam</code></a>, <a class="link" href="#_HeaderParam" title="Chapter 7. @HeaderParam"><code class="code">@HeaderParam</code></a>
and <a class="link" href="#_MatrixParam" title="Chapter 9. @MatrixParam"><code class="code">@MatrixParam</code></a>. In order to benefit from this feature, you have to switch to new annotations
with the same name, in a different package, which have an optional value parameter. To use this, follow these steps:
</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Import the <code class="code">org.jboss.resteasy.annotations.jaxrs</code> package to replace annotations from the JAX-RS spec.</li><li class="listitem">Tell your build system to record method parameter names in the bytecode.</li><li class="listitem">Remove the annotation value if the name matches the name of the annotated variable.</li></ul></div>
<p>
Note that you can omit the annotation name for annotated method parameters as well as annotated fields or JavaBean properties.
</p>
<p>
For Maven users, recording method parameter names in the bytecode can be enabled by setting the <code class="code">maven.compiler.parameters</code> 
to <code class="code">true</code>:
</p>
<pre><code class="no-highlight">
    &lt;properties&gt;
        &lt;maven.compiler.parameters&gt;true&lt;/maven.compiler.parameters&gt;
    &lt;/properties&gt;
</code></pre>
<p>Usage:</p>
<pre><code class="no-highlight">
import org.jboss.resteasy.annotations.jaxrs.*;

@Path("/library")
public class Library {

   @GET
   @Path("/book/{isbn}")
   public String getBook(@PathParam String isbn) {
      // search my database and get a string representation and return it
   }
}
</code></pre>

<p>If your annotated variable does not have the same name as the path parameter, you can still
specify the name:</p>
<pre><code class="no-highlight">
import org.jboss.resteasy.annotations.jaxrs.*;

@Path("/library")
public class Library {

   @GET
   @Path("/book/{isbn}")
   public String getBook(@PathParam("isbn") String id) {
      // search my database and get a string representation and return it
   }
}
</code></pre>
</section>

   <section class="chapter" id="_OptionalParam"><div class="titlepage"><div><div><h1 class="title">Chapter 14. Optional parameter types</h1></div></div></div>
    
    <p>RESTEasy offers a mechanism to support a series of <code class="code">java.util.Optional</code> types as a wrapper object types. This
        will give users the ability to use optional typed parameters, and eliminate all null checks by using methods
        like <code class="code">Optional.orElse()</code>.
    </p>
    <p>Here is the sample:</p>
    <pre><code class="no-highlight">@Path("/double")
@GET
public String optDouble(@QueryParam("value") OptionalDouble value) {
    return Double.toString(value.orElse(4242.0));
}
</code></pre>
    <p>
        From the above sample code we can see that the <code class="code">OptionalDouble</code> can be used as parameter type, and when users
        don't provide a value in <code class="code">@QueryParam</code>, then the default value will be returned.
    </p>
    <p>
        Here is the list of supported optional parameter types:
        </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                <p>@QueryParam</p>
            </li><li class="listitem">
                <p>@FormParam</p>
            </li><li class="listitem">
                <p>@MatrixParam</p>
            </li><li class="listitem">
                <p>@HeaderParam</p>
            </li><li class="listitem">
                <p>@CookieParam</p>
            </li></ul></div><p>
    </p>
    <p>
        As the list shown above, those parameter types support the Java-provided <code class="code">Optional</code> types. Please note that the <code class="code">@PathParam</code> is an exception for which <code class="code">Optional</code> is not available. The reason is that <code class="code">Optional</code> for the <code class="code">@PathParam</code> use case would just be a NO-OP, since an element of the path cannot be omitted.
    </p>

    <p>
      The <code class="code">Optional</code> types can also be used as type of the fields of a <code class="code">@BeanParam</code>'s class.
    </p>

    <p>Here is an example of endpoint with a <code class="code">@BeanParam</code>:</p>

    <pre><code class="no-highlight">@Path("/double")
@GET
public String optDouble(@BeanParam Bean bean) {
    return Double.toString(bean.value.orElse(4242.0));
}</code></pre>

  <p>The corresponding class <code class="code">Bean</code>:</p>

  <pre><code class="no-highlight">public class Bean {
    @QueryParam("value")
    OptionalDouble value;
}</code></pre>

  <p> Finally, the <code class="code">Optional</code> types can be used directly as type of the fields of a JAX-RS resource class.</p>

  <p>Here is an example of a JAX-RS resource class with an <code class="code">Optional</code> type:</p>

  <pre><code class="no-highlight">@RequestScoped
public class OptionalResource {
    @QueryParam("value")
    Optional&lt;String&gt; value;
    ...
}</code></pre>
</section>

   <section class="chapter" id="_DefaultValue"><div class="titlepage"><div><div><h1 class="title">Chapter 15. @DefaultValue</h1></div></div></div>


<p>

@DefaultValue is a parameter annotation that can be combined with any of the other @*Param annotations to define a default value when the HTTP request item does not exist.
</p>
<p>

</p><pre><code class="no-highlight">
@GET
public String getBooks(@QueryParam("num") @DefaultValue("10") int num) {...}
</code></pre><p>
</p>
<p>

</p>
<p>


</p>
</section>

   <section class="chapter" id="_Encoded_and_encoding"><div class="titlepage"><div><div><h1 class="title">Chapter 16. @Encoded and encoding</h1></div></div></div>


<p>

JAX-RS allows you to get encoded or decoded @*Params and specify path definitions and parameter names using encoded or decoded strings.
</p>
<p>


</p>
<p>

The @javax.ws.rs.Encoded annotation can be used on a class, method, or param.  By default, inject @PathParam and @QueryParams are decoded.  By additionally adding the @Encoded annotation, the value of these params will be provided in encoded form.
</p>
<p>

</p><pre><code class="no-highlight">
@Path("/")
public class MyResource {

    @Path("/{param}")
    @GET
    public String get(@PathParam("param") @Encoded String param) {...}
}
</code></pre><p>
</p>
<p>

In the above example, the value of the @PathParam injected into the param of the get() method will be URL encoded.  Adding the @Encoded annotation as a paramater annotation triggers this affect.
</p>
<p>

You may also use the @Encoded annotation on the entire method and any combination of @QueryParam or @PathParam's values will be encoded.
</p>
<p>

</p><pre><code class="no-highlight">
@Path("/")
public class MyResource {
  
    @Path("/{param}")
    @GET
    @Encoded
    public String get(@QueryParam("foo") String foo, @PathParam("param") String param) {}
}
</code></pre><p>
</p>
<p>

In the above example, the values of the "foo" query param and "param" path param will be injected as encoded values.
</p>
<p>

You can also set the default to be encoded for the entire class.
</p><pre><code class="no-highlight">
@Path("/")
@Encoded
public class ClassEncoded {
  
    @GET
    public String get(@QueryParam("foo") String foo) {}
}
</code></pre><p>
</p>
<p>


</p>
<p>

The @Path annotation has an attribute called encode.  Controls whether the literal part of the supplied value (those characters that are not part of a template variable) are URL encoded. If true, any characters in the URI template that are not valid URI character will be automatically encoded. If false then all characters must be valid URI characters.  By default this is set to true.  If you want to encoded the characters yourself, you may.
</p>
<p>

</p><pre><code class="no-highlight">
@Path(value="hello%20world", encode=false)
</code></pre><p>
</p>
<p>


</p>
<p>

Much like @Path.encode(), this controls whether the specified query param name should be encoded by the container before it tries to find the query param in the request.
</p>
<p>

</p><pre><code class="no-highlight">
@QueryParam(value="hello%20world", encode=false)
</code></pre><p>
</p>
<p>

</p>
<p>

</p>
<p>


</p>
</section>

   <section class="chapter" id="_Context"><div class="titlepage"><div><div><h1 class="title">Chapter 17. @Context</h1></div></div></div>


<p>

The @Context annotation allows you to inject instances of 
</p>

<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">javax.ws.rs.core.HttpHeaders</li><li class="listitem">javax.ws.rs.core.UriInfo</li><li class="listitem">javax.ws.rs.core.Request</li><li class="listitem">javax.servlet.http.HttpServletRequest</li><li class="listitem">javax.servlet.http.HttpServletResponse</li><li class="listitem">javax.servlet.ServletConfig</li><li class="listitem">javax.servlet.ServletContext</li><li class="listitem">javax.ws.rs.core.SecurityContext</li></ul></div>

<p>objects.</p>
<p>


</p>
</section>

   <section class="chapter" id="JAX-RS_Resource_Locators_and_Sub_Resources"><div class="titlepage"><div><div><h1 class="title">Chapter 18. JAX-RS Resource Locators and Sub Resources</h1></div></div></div>


<p>

Resource classes are able to partially process a request and provide another "sub" resource object that can process the remainder of the request.  For example:
</p>
<p>

</p><pre><code class="no-highlight">
@Path("/")
public class ShoppingStore {

    @Path("/customers/{id}")
    public Customer getCustomer(@PathParam("id") int id) {
        Customer cust = ...; // Find a customer object
        return cust;
    }
}

public class Customer {
   
    @GET
    public String get() {...}

    @Path("/address")
    public String getAddress() {...}
}
</code></pre><p>
</p>
<p>

</p>
<p>

Resource methods that have a @Path annotation, but no HTTP method are considered sub-resource locators.  Their job is to provide an object that can process the request.  In the above example ShoppingStore is a root resource because its class is annotated with @Path.  The getCustomer() method is a sub-resource locator method.
</p>
<p>

If the client invoked:
</p>
<p>

</p><pre><code class="no-highlight">GET /customer/123</code></pre><p>
</p>
<p>

The ShoppingStore.getCustomer() method would be invoked first.  This method provides a Customer object that can service the request.  The http request will be dispatched to the Customer.get() method.  Another example is:
</p>
<p>

</p><pre><code class="no-highlight">GET /customer/123/address</code></pre><p>
</p>
<p>

In this request, again, first the ShoppingStore.getCustomer() method is invoked.  A customer object is returned, and the rest of the request is dispatched to the Customer.getAddress() method.
</p>
<p>


</p>
<p>

Another interesting feature of Sub-resource locators is that the locator method result is dynamically processed at runtime to figure out how to dispatch the request.  So, the ShoppingStore.getCustomer() method does not have to declare any specific type.
</p>
<p>

</p><pre><code class="no-highlight">
@Path("/")
public class ShoppingStore {

   @Path("/customers/{id}")
   public java.lang.Object getCustomer(@PathParam("id") int id) {
      Customer cust = ...; // Find a customer object
      return cust;
   }
}

public class Customer {
   
    @GET
    public String get() {...}

    @Path("/address")
    public String getAddress() {...}
}
</code></pre><p>
</p>
<p>

In the above example, getCustomer() returns a java.lang.Object.  Per request, at runtime, the JAX-RS server will figure out how to dispatch the request based on the object returned by getCustomer().  What are the uses of this?  Well, maybe you have a class hierarchy for your customers.  Customer is the abstract base, CorporateCustomer and IndividualCustomer are subclasses.  Your getCustomer() method might be doing a Hibernate polymorphic query and doesn't know, or care, what concrete class is it querying for, or what it returns.
</p>
<p>

</p><pre><code class="no-highlight">
@Path("/")
public class ShoppingStore {

   @Path("/customers/{id}")
   public java.lang.Object getCustomer(@PathParam("id") int id) {
      Customer cust = entityManager.find(Customer.class, id);
      return cust;
   }
}

public class Customer {
   
    @GET
    public String get() {...}

    @Path("/address")
    public String getAddress() {...}
}

public class CorporateCustomer extends Customer {
   
    @Path("/businessAddress")
    public String getAddress() {...}
}
</code></pre><p>
</p>
<p>

</p>
<p>


</p>
</section>

   <section class="chapter" id="Resources_Metadata"><div class="titlepage"><div><div><h1 class="title">Chapter 19. Resources metadata configuration</h1></div></div></div>


<p>
When processing JAX-RS deployments, RESTEasy relies on <span class="emphasis"><em>ResourceBuilder</em></span> to create metadata for each JAX-RS resource. Such metadata is defined using the metadata SPI in package <span class="emphasis"><em>org.jboss.resteasy.spi.metadata</em></span>, in particular the <span class="emphasis"><em>ResourceClass</em></span> interface:
</p><pre><code class="no-highlight">
package org.jboss.resteasy.spi.metadata;

public interface ResourceClass
{
  String getPath();

  Class&lt;?&gt; getClazz();

  ResourceConstructor getConstructor();

  FieldParameter[] getFields();

  SetterParameter[] getSetters();

  ResourceMethod[] getResourceMethods();

  ResourceLocator[] getResourceLocators();
}
</code></pre><p>

Among the other classes and interfaces defining metadata SPI, the following interfaces are worth a mention here:

</p><pre><code class="no-highlight">
public interface ResourceConstructor
{
  ResourceClass getResourceClass();

  Constructor getConstructor();

  ConstructorParameter[] getParams();
}

public interface ResourceMethod extends ResourceLocator
{
  Set&lt;String&gt; getHttpMethods();

  MediaType[] getProduces();

  MediaType[] getConsumes();

  boolean isAsynchronous();

  void markAsynchronous();
}

public interface ResourceLocator
{
  ResourceClass getResourceClass();

  Class&lt;?&gt; getReturnType();

  Type getGenericReturnType();

  Method getMethod();

  Method getAnnotatedMethod();

  MethodParameter[] getParams();

  String getFullpath();

  String getPath();

}
</code></pre><p>
</p>

<p>
Now, the interesting point is that RESTEasy allows tuning the metadata generation by providing implementations of the <span class="emphasis"><em>ResourceClassProcessor</em></span> interface:
</p><pre><code class="no-highlight">
package org.jboss.resteasy.spi.metadata;

public interface ResourceClassProcessor
{

  /**
   * Allows the implementation of this method to modify the resource metadata represented by
   * the supplied {@link ResourceClass} instance. Implementation will typically create
   * wrappers which modify only certain aspects of the metadata.
   *
   * @param clazz The original metadata
   * @return the (potentially modified) metadata (never null)
   */
  ResourceClass process(ResourceClass clazz);

}
</code></pre><p>

The processors are meant to be, and are resolved as, regular JAX-RS annotated providers. They allow for wrapping resource metadata classes with custom versions that can be used for various advanced scenarios like
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
adding additional resource method/locators to the resource
</li><li class="listitem">
altering the http methods
</li><li class="listitem">
altering the @Produces / @Consumes media types
</li><li class="listitem">
...
</li></ul></div><p>




</p>
</section>

   <section class="chapter" id="JAX-RS_Content_Negotiation"><div class="titlepage"><div><div><h1 class="title">Chapter 20. JAX-RS Content Negotiation</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="sect1"><a href="#media_mappings">20.1. URL-based negotiation</a></span></li><li><span class="sect1"><a href="#param_media_mappings">20.2. Query String Parameter-based negotiation</a></span></li></ul></div>
   

   <p>

      The HTTP protocol has built in content negotiation headers that allow the client and server to specify what
      content they are transferring and what content they would prefer to get. The server declares content preferences
      via the @Produces and @Consumes headers.
   </p>
   <p>


      @Consumes is an array of media types that a particular resource or resource method consumes. For example:
   </p>
   <p>

</p><pre><code class="no-highlight">
@Consumes("text/*")
@Path("/library")
public class Library {

    @POST
    public String stringBook(String book) {...}

    @Consumes("text/xml")
    @POST
    public String jaxbBook(Book book) {...}
}
</code></pre><p>
   </p>
   <p>

      When a client makes a request, JAX-RS first finds all methods that match the path, then, it sorts things based on
      the content-type header sent by the client.
      So, if a client sent:
   </p>
   <p>

</p><pre><code class="no-highlight">
POST /library
Content-Type: text/plain

This is a nice book
</code></pre><p>
   </p>
   <p>

      The stringBook() method would be invoked because it matches to the default "text/*" media type. Now, if
      the client instead sends XML:
   </p>
   <p>

</p><pre><code class="no-highlight">
POST /library
Content-Type: text/xml

&lt;book name="EJB 3.0" author="Bill Burke"/&gt;
</code></pre><p>
   </p>
   <p>

      The jaxbBook() method would be invoked.
   </p>
   <p>


      The @Produces is used to map a client request and match it up to the client's Accept header. The Accept HTTP
      header is sent by the client and defines the media types the client prefers to receive from the server.
   </p>
   <p>


</p><pre><code class="no-highlight">
@Produces("text/*")
@Path("/library")
public class Library {

@GET
@Produces("application/json")
public String getJSON() {...}

@GET
public String get() {...}
</code></pre><p>
   </p>
   <p>

      So, if the client sends:
   </p>
   <p>

</p><pre><code class="no-highlight">
GET /library
Accept: application/json
</code></pre><p>
   </p>
   <p>

      The getJSON() method would be invoked.
   </p>
   <p>


      @Consumes and @Produces can list multiple media types that they support. The client's Accept header can also send
      multiple types it might like to receive. More specific media types are chosen first. The client Accept header or
      @Produces @Consumes can also specify weighted preferences that are used to match up requests with resource
      methods. This is best explained by RFC 2616 section 14.1 . RESTEasy supports this complex way of doing content
      negotiation.
   </p>
   <p>


   </p>
   <p>

      A variant in JAX-RS is a combination of media type, content-language, and content encoding as well as etags, last
      modified headers, and other preconditions. This is a more complex form of content negotiation that is done
      programmatically by the application developer using the javax.ws.rs.Variant, VarianListBuilder, and Request
      objects. Request is injected via @Context. Read the javadoc for more info on these.
   </p>
<section class="sect1" id="media_mappings"><div class="titlepage"><div><div><h2 class="title">20.1. URL-based negotiation</h2></div></div></div>

<p>
Some clients, like browsers, cannot use the Accept and Accept-Language headers to negotiation the representation's media type
or language.  RESTEasy allows you to map file name suffixes like (.xml, .txt, .en, .fr) to media types and languages.  These file name suffixes
take the place and override any Accept header sent by the client.  You configure this using the resteasy.media.type.mappings and resteasy.language.mappings
parameters. If configured within your web.xml, it would look like:
</p>
<pre><code class="no-highlight">
&lt;web-app&gt;
    &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.media.type.mappings&lt;/param-name&gt;
        &lt;param-value&gt;html : text/html, json : application/json, xml : application/xml&lt;/param-value&gt;
    &lt;/context-param&gt;

   &lt;context-param&gt;
        &lt;param-name&gt;resteasy.language.mappings&lt;/param-name&gt;
        &lt;param-value&gt;en : en-US, es : es, fr : fr&lt;/param-value&gt;
   &lt;/context-param&gt;

   ...
&lt;/web-app&gt;
</code></pre>

<p>See <a class="xref" href="#microprofile_config" title="3.4. Configuration">Section 3.4, “Configuration”</a> for more information about application configuration. </p>

<p>
Mappings are a comma delimited list of suffix/mediatype or suffix/language mappings.  Each mapping is delimited by a ':'.  So, if you invoked GET /foo/bar.xml.en, this would be equivalent to invoking the following request:
</p>
<pre><code class="no-highlight">
GET /foo/bar
Accept: application/xml
Accept-Language: en-US
</code></pre>
<p>
The mapped file suffixes are stripped from the target URL path before the request is dispatched to a corresponding JAX-RS resource.
</p>
</section>

<section class="sect1" id="param_media_mappings"><div class="titlepage"><div><div><h2 class="title">20.2. Query String Parameter-based negotiation</h2></div></div></div>

<p>
RESTEasy can do content negotiation based in a parameter in query string. To enable this, the parameter resteasy.media.type.param.mapping
can be configured. In web.xml, it would look like the following:
</p>
<pre><code class="no-highlight">
&lt;web-app&gt;
    &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.media.type.param.mapping&lt;/param-name&gt;
        &lt;param-value&gt;someName&lt;/param-value&gt;
    &lt;/context-param&gt;

    ...
&lt;/web-app&gt;
</code></pre>

<p>See <a class="xref" href="#microprofile_config" title="3.4. Configuration">Section 3.4, “Configuration”</a> for more information about application configuration. </p>

<p>The param-value is the name of the query string parameter that RESTEasy will use in the place of the Accept header.</p>
<p>Invoking http://service.foo.com/resouce?someName=application/xml, will give the application/xml media type the highest priority in the content negotiation.</p>
<p>In cases where the request contains both the parameter and the Accept header, the parameter will be more relevant.</p>
<p>It is possible to left the param-value empty, what will cause the processor to look for a parameter named 'accept'.</p>
</section>

</section>

    <section class="chapter" id="Content_Marshalling_Providers"><div class="titlepage"><div><div><h1 class="title">Chapter 21. Content Marshalling/Providers</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="sect1"><a href="#Default_Providers_and_default_JAX-RS_Content_Marshalling">21.1. Default Providers and default JAX-RS Content Marshalling</a></span></li><li><span class="sect1"><a href="#Content_Marshalling_with__Provider_classes">21.2. Content Marshalling with @Provider classes</a></span></li><li><span class="sect1"><a href="#MessageBodyWorkers">21.3. Providers Utility Class</a></span></li><li><span class="sect1"><a href="#Configuring_Document_Marshalling">21.4. Configuring Document Marshalling</a></span></li><li><span class="sect1"><a href="#Text_media_types">21.5. Text media types and character sets</a></span></li></ul></div>
   
   <section class="sect1" id="Default_Providers_and_default_JAX-RS_Content_Marshalling"><div class="titlepage"><div><div><h2 class="title">21.1. Default Providers and default JAX-RS Content Marshalling</h2></div></div></div>
      

      <p>

         RESTEasy can automatically marshal and unmarshal a few different message bodies.
      </p>
      <p>

         </p><div class="table" id="d5e1162"><div class="table-title">Table 21.1. </div><div class="table-contents">
            <table style="border-collapse: collapse;border-top: 1px solid ; border-bottom: 1px solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 1px  ; border-bottom: 1px  ; ">
                        Media Types
                     </th><th style="border-bottom: 1px  ; ">
                        Java Type
                     </th></tr></thead><tbody><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        application/*+xml, text/*+xml, application/*+json, application/*+fastinfoset, application/atom+*
                     </td><td style="border-bottom: 1px  ; ">
                        JaxB annotated classes
                     </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        application/*+xml, text/*+xml
                     </td><td style="border-bottom: 1px  ; ">
                        org.w3c.dom.Document
                     </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        */*
                     </td><td style="border-bottom: 1px  ; ">
                        java.lang.String
                     </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        */*
                     </td><td style="border-bottom: 1px  ; ">
                        java.io.InputStream
                     </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        text/plain
                     </td><td style="border-bottom: 1px  ; ">
                        primitives, java.lang.String, or any type that has a String constructor, or static
                        valueOf(String) method for input, toString() for output
                     </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        */*
                     </td><td style="border-bottom: 1px  ; ">
                        javax.activation.DataSource
                     </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        */*
                     </td><td style="border-bottom: 1px  ; ">
                        java.io.File
                     </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                        */*
                     </td><td style="border-bottom: 1px  ; ">
                        byte[]
                     </td></tr><tr><td style="border-right: 1px  ; ">
                        application/x-www-form-urlencoded
                     </td><td>
                        javax.ws.rs.core.MultivaluedMap
                     </td></tr></tbody></table>
         </div></div><p><br class="table-break"/>

      </p>
      <p>
          <span class="bold"><strong>Note. </strong></span> When a <code class="classname">java.io.File</code> is created, as in
      </p>
      
      <pre><code class="no-highlight">
@Path("/test")
public class TempFileDeletionResource
{
   @POST
   @Path("post")
   public Response post(File file) throws Exception
   {
      return Response.ok(file.getPath()).build();
   }
}
      </code></pre>

      <p>
          a temporary file is created in the file system. On the server side, that temporary file will be deleted
          at the end of the invocation. On the client side, however, it is the responsibility of the user to 
          delete the temporary file.
      </p>
 
      <p>

      </p>
      <p>


      </p>
   </section>
   <section class="sect1" id="Content_Marshalling_with__Provider_classes"><div class="titlepage"><div><div><h2 class="title">21.2. Content Marshalling with @Provider classes</h2></div></div></div>
      

      <p>

         The JAX-RS specification allows you to plug in your own request/response body reader and writers. To do this,
         you annotate a class
         with @Provider and specify the @Produces types for a writer and @Consumes types for a reader. You must
         also implement
         a MessageBodyReader/Writer interface respectively. Here is an example:
      </p>

      <pre><code class="no-highlight">
         @Provider
         @Produces("text/plain")
         @Consumes("text/plain")
         public class DefaultTextPlain implements MessageBodyReader, MessageBodyWriter {

            public boolean isReadable(Class type, Type genericType, Annotation[] annotations, MediaType mediaType) {
               // StringTextStar should pick up strings
               return !String.class.equals(type) &amp;&amp; TypeConverter.isConvertable(type);
            }

            public Object readFrom(Class type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap httpHeaders, InputStream entityStream) throws IOException, WebApplicationException {
               InputStream delegate = NoContent.noContentCheck(httpHeaders, entityStream);
               String value = ProviderHelper.readString(delegate, mediaType);
               return TypeConverter.getType(type, value);
            }

            public boolean isWriteable(Class type, Type genericType, Annotation[] annotations, MediaType mediaType) {
               // StringTextStar should pick up strings
               return !String.class.equals(type) &amp;&amp; !type.isArray();
            }

            public long getSize(Object o, Class type, Type genericType, Annotation[] annotations, MediaType mediaType) {
               String charset = mediaType.getParameters().get("charset");
               if (charset != null)
                  try {
                     return o.toString().getBytes(charset).length;
                  } catch (UnsupportedEncodingException e) {
                     // Use default encoding.
                  }
               return o.toString().getBytes(StandardCharsets.UTF_8).length;
            }

            public void writeTo(Object o, Class type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException {
               String charset = mediaType.getParameters().get("charset");
               if (charset == null) entityStream.write(o.toString().getBytes(StandardCharsets.UTF_8));
               else entityStream.write(o.toString().getBytes(charset));
            }
         }
      </code></pre>
      <p>
        Note that in order to support <a class="link" href="#Asynchronous_IO" title="37.4. Asynchronous IO">Async IO</a>, you need to implement the
        <code class="code">AsyncMessageBodyWriter</code> interface, which requires you to implement this extra method:
      </p>
      <pre><code class="no-highlight">
         @Provider
         @Produces("text/plain")
         @Consumes("text/plain")
         public class DefaultTextPlain implements MessageBodyReader, AsyncMessageBodyWriter {
            // ...
            public CompletionStage&lt;Void&gt; asyncWriteTo(Object o, Class type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap httpHeaders, AsyncOutputStream entityStream) {
               String charset = mediaType.getParameters().get("charset");
               if (charset == null)
                  return entityStream.asyncWrite(o.toString().getBytes(StandardCharsets.UTF_8));
               else
                  return entityStream.asyncWrite(o.toString().getBytes(charset));
            }
         }
      </code></pre>
      <p>


         The RESTEasy ServletContextLoader will automatically scan your WEB-INF/lib and classes directories for classes
         annotated with @Provider or you can manually configure them in web.xml. See Installation/Configuration.
      </p>
      <p>


      </p>
   </section>
   <section class="sect1" id="MessageBodyWorkers"><div class="titlepage"><div><div><h2 class="title">21.3. Providers Utility Class</h2></div></div></div>
      

      <p>

         javax.ws.rs.ext.Providers is a simple injectable interface that allows you to look up MessageBodyReaders,
          Writers, ContextResolvers, and ExceptionMappers. It is very useful, for instance, for implementing
          multipart providers. Content types that embed
         other random content types.
      </p>
      <p>

         </p><pre><code class="no-highlight">
public interface Providers
{

   /**
    * Get a message body reader that matches a set of criteria. The set of
    * readers is first filtered by comparing the supplied value of
    * {@code mediaType} with the value of each reader's
    * {@link javax.ws.rs.Consumes}, ensuring the supplied value of
    * {@code type} is assignable to the generic type of the reader, and
    * eliminating those that do not match.
    * The list of matching readers is then ordered with those with the best
    * matching values of {@link javax.ws.rs.Consumes} (x/y &gt; x&amp;#47;* &gt; *&amp;#47;*)
    * sorted first. Finally, the
    * {@link MessageBodyReader#isReadable}
    * method is called on each reader in order using the supplied criteria and
    * the first reader that returns {@code true} is selected and returned.
    *
    * @param type        the class of object that is to be written.
    * @param mediaType   the media type of the data that will be read.
    * @param genericType the type of object to be produced. E.g. if the
    *                    message body is to be converted into a method parameter, this will be
    *                    the formal type of the method parameter as returned by
    *                    &lt;code&gt;Class.getGenericParameterTypes&lt;/code&gt;.
    * @param annotations an array of the annotations on the declaration of the
    *                    artifact that will be initialized with the produced instance. E.g. if the
    *                    message body is to be converted into a method parameter, this will be
    *                    the annotations on that parameter returned by
    *                    &lt;code&gt;Class.getParameterAnnotations&lt;/code&gt;.
    * @return a MessageBodyReader that matches the supplied criteria or null
    *         if none is found.
    */
   &lt;T&gt; MessageBodyReader&lt;T&gt; getMessageBodyReader(Class&lt;T&gt; type,
                                                 Type genericType, Annotation annotations[], MediaType mediaType);

   /**
    * Get a message body writer that matches a set of criteria. The set of
    * writers is first filtered by comparing the supplied value of
    * {@code mediaType} with the value of each writer's
    * {@link javax.ws.rs.Produces}, ensuring the supplied value of
    * {@code type} is assignable to the generic type of the reader, and
    * eliminating those that do not match.
    * The list of matching writers is then ordered with those with the best
    * matching values of {@link javax.ws.rs.Produces} (x/y &gt; x&amp;#47;* &gt; *&amp;#47;*)
    * sorted first. Finally, the
    * {@link MessageBodyWriter#isWriteable}
    * method is called on each writer in order using the supplied criteria and
    * the first writer that returns {@code true} is selected and returned.
    *
    * @param mediaType   the media type of the data that will be written.
    * @param type        the class of object that is to be written.
    * @param genericType the type of object to be written. E.g. if the
    *                    message body is to be produced from a field, this will be
    *                    the declared type of the field as returned by
    *                    &lt;code&gt;Field.getGenericType&lt;/code&gt;.
    * @param annotations an array of the annotations on the declaration of the
    *                    artifact that will be written. E.g. if the
    *                    message body is to be produced from a field, this will be
    *                    the annotations on that field returned by
    *                    &lt;code&gt;Field.getDeclaredAnnotations&lt;/code&gt;.
    * @return a MessageBodyReader that matches the supplied criteria or null
    *         if none is found.
    */
   &lt;T&gt; MessageBodyWriter&lt;T&gt; getMessageBodyWriter(Class&lt;T&gt; type,
                                                 Type genericType, Annotation annotations[], MediaType mediaType);

   /**
    * Get an exception mapping provider for a particular class of exception.
    * Returns the provider whose generic type is the nearest superclass of
    * {@code type}.
    *
    * @param type the class of exception
    * @return an {@link ExceptionMapper} for the supplied type or null if none
    *         is found.
    */
   &lt;T extends Throwable&gt; ExceptionMapper&lt;T&gt; getExceptionMapper(Class&lt;T&gt; type);

   /**
    * Get a context resolver for a particular type of context and media type.
    * The set of resolvers is first filtered by comparing the supplied value of
    * {@code mediaType} with the value of each resolver's
    * {@link javax.ws.rs.Produces}, ensuring the generic type of the context
    * resolver is assignable to the supplied value of {@code contextType}, and
    * eliminating those that do not match. If only one resolver matches the
    * criteria then it is returned. If more than one resolver matches then the
    * list of matching resolvers is ordered with those with the best
    * matching values of {@link javax.ws.rs.Produces} (x/y &gt; x&amp;#47;* &gt; *&amp;#47;*)
    * sorted first. A proxy is returned that delegates calls to
    * {@link ContextResolver#getContext(java.lang.Class)} to each matching context
    * resolver in order and returns the first non-null value it obtains or null
    * if all matching context resolvers return null.
    *
    * @param contextType the class of context desired
    * @param mediaType   the media type of data for which a context is required.
    * @return a matching context resolver instance or null if no matching
    *         context providers are found.
    */
   &lt;T&gt; ContextResolver&lt;T&gt; getContextResolver(Class&lt;T&gt; contextType,
                                             MediaType mediaType);
}</code></pre><p>
      </p>
      <p>


      </p>
      <p>

         A Providers instance is injectable into MessageBodyReader or Writers:
      </p>
      <p>

</p><pre><code class="no-highlight">
@Provider
@Consumes("multipart/fixed")
public class MultipartProvider implements MessageBodyReader {

    private @Context Providers providers;

    ...

}
</code></pre><p>
      </p>
      <p>


      </p>
   </section>
   
   <section class="sect1" id="Configuring_Document_Marshalling"><div class="titlepage"><div><div><h2 class="title">21.4. Configuring Document Marshalling</h2></div></div></div>
      

      <p>
   
         XML document parsers are subject to a form of attack known as the XXE (Xml eXternal Entity) Attack
         (<a class="ulink" href="http://www.securiteam.com/securitynews/6D0100A5PU.html">http://www.securiteam.com/securitynews/6D0100A5PU.html</a>),
         in which expanding an external entity causes an unsafe file to be loaded. For example, the document
      </p>
      
<pre><code class="no-highlight">
&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE foo
[&lt;!ENTITY xxe SYSTEM "file:///etc/passwd"&gt;]&gt;
&lt;search&gt;
    &lt;user&gt;bill&lt;/user&gt;
    &lt;file&gt;&amp;xxe;&lt;file&gt;
&lt;/search&gt;
</code></pre>
      
      <p>
      
      could cause the passwd file to be loaded.
      </p>
      
      <p>
      
         By default, RESTEasy's built-in unmarshaller for org.w3c.dom.Document documents will not expand external entities,
         replacing them by the empty string instead. It can be configured to replace external entities by values defined in the
         DTD by setting the parameter
   
      </p>
      
      <div class="blockquote"><blockquote class="blockquote">resteasy.document.expand.entity.references</blockquote></div>
      
      <p> to "true". If configured in the web.xml file, it would be:</p>
      
<pre><code class="no-highlight">
&lt;context-param&gt;
    &lt;param-name&gt;resteasy.document.expand.entity.references&lt;/param-name&gt;
    &lt;param-value&gt;true&lt;/param-value&gt;
&lt;/context-param&gt;
</code></pre>
      
      <p>See <a class="xref" href="#microprofile_config" title="3.4. Configuration">Section 3.4, “Configuration”</a> for more information about application configuration. </p>
      
      <p>
      
      Another way of dealing with the problem is by prohibiting DTDs, which RESTEasy does by default. This behavior
      can be changed by setting the parameter
      
      </p>
      
      <div class="blockquote"><blockquote class="blockquote">resteasy.document.secure.disableDTDs</blockquote></div>
           
      <p>to "false".</p>
 
 	  <p>
 	  
 	  Documents are also subject to Denial of Service Attacks when buffers are overrun by large entities or too many
 	  attributes.  For example, if a DTD defined the following entities
 	  
 	  </p>
 	  
<pre><code class="no-highlight">
&lt;!ENTITY foo 'foo'&gt;
&lt;!ENTITY foo1 '&amp;foo;&amp;foo;&amp;foo;&amp;foo;&amp;foo;&amp;foo;&amp;foo;&amp;foo;&amp;foo;&amp;foo;'&gt;
&lt;!ENTITY foo2 '&amp;foo1;&amp;foo1;&amp;foo1;&amp;foo1;&amp;foo1;&amp;foo1;&amp;foo1;&amp;foo1;&amp;foo1;&amp;foo1;'&gt;
&lt;!ENTITY foo3 '&amp;foo2;&amp;foo2;&amp;foo2;&amp;foo2;&amp;foo2;&amp;foo2;&amp;foo2;&amp;foo2;&amp;foo2;&amp;foo2;'&gt;
&lt;!ENTITY foo4 '&amp;foo3;&amp;foo3;&amp;foo3;&amp;foo3;&amp;foo3;&amp;foo3;&amp;foo3;&amp;foo3;&amp;foo3;&amp;foo3;'&gt;
&lt;!ENTITY foo5 '&amp;foo4;&amp;foo4;&amp;foo4;&amp;foo4;&amp;foo4;&amp;foo4;&amp;foo4;&amp;foo4;&amp;foo4;&amp;foo4;'&gt;
&lt;!ENTITY foo6 '&amp;foo5;&amp;foo5;&amp;foo5;&amp;foo5;&amp;foo5;&amp;foo5;&amp;foo5;&amp;foo5;&amp;foo5;&amp;foo5;'&gt;
</code></pre>
 	  
   <p>
   then the expansion of &amp;foo6; 
   would result in 1,000,000 foos. By default, RESTEasy will limit the number of expansions and
   the number of attributes per entity. The exact behavior depends on the underlying parser. The limits
   can be turned off by setting the parameter
   </p>
   
   <div class="blockquote"><blockquote class="blockquote">resteasy.document.secure.processing.feature</blockquote></div>
   
   <p>to "false".</p>
   </section>
   
   <section class="sect1" id="Text_media_types"><div class="titlepage"><div><div><h2 class="title">21.5. Text media types and character sets</h2></div></div></div>
      
   
   <p>
   The JAX-RS specification says
   </p>

<pre><code class="no-highlight">
When writing responses, implementations SHOULD respect application-supplied character
set metadata and SHOULD use UTF-8 if a character set is not specified by the application
or if the application specifies a character set that is unsupported.
</code></pre>

   <p>
   On the other hand, the HTTP specification says
   </p>
   
<pre><code class="no-highlight">
When no explicit charset parameter is provided by the sender, media subtypes of the
"text" type are defined to have a default charset value of "ISO-8859-1" when received
via HTTP. Data in character sets other than "ISO-8859-1" or its subsets MUST be labeled
with an appropriate charset value.
</code></pre>

   <p>
   It follows that, in the absence of a character set specified by a resource or resource method,
   RESTEasy SHOULD use UTF-8 as the character set for text media types, and, if it does, it MUST add an explicit 
   charset parameter to the Content-Type response header. RESTEasy started adding the explicit charset
   parameter in releases 3.1.2.Final and 3.0.22.Final, and that new behavior could cause some compatibility problems. To
   specify the previous behavior, in which UTF-8 was used for text media types, but the explicit charset
   was not appended, the parameter "resteasy.add.charset" may be set to "false". It defaults to "true".
   </p>
   
   <p>
   <span class="bold"><strong>Note.</strong></span> By "text" media types, we mean
   </p>
   
   <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">a media type with type "text" and any subtype;</li><li class="listitem">a media type with type ""application" and subtype beginning with "xml".</li></ul></div>
   
   <p>
   The latter set includes "application/xml-external-parsed-entity" and "application/xml-dtd".
   </p>
   </section>
   
</section>

    <section class="chapter" id="Built_in_JAXB_providers"><div class="titlepage"><div><div><h1 class="title">Chapter 22. JAXB providers</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="sect1"><a href="#decorators">22.1. JAXB Decorators</a></span></li><li><span class="sect1"><a href="#Pluggable_JAXBContext_s_with_ContextResolvers">22.2. Pluggable JAXBContext's with ContextResolvers</a></span></li><li><span class="sect1"><a href="#JAXB_+_XML_provider">22.3. JAXB + XML provider</a></span><ul><li><span class="sect2"><a href="#XmlHeader">22.3.1. @XmlHeader and @Stylesheet</a></span></li></ul></li><li><span class="sect1"><a href="#JAXB_+_JSON_provider">22.4. JAXB + JSON provider</a></span></li><li><span class="sect1"><a href="#JAXB_+_FastinfoSet_provider">22.5. JAXB + FastinfoSet provider</a></span></li><li><span class="sect1"><a href="#JAXB_Collections">22.6. Arrays and Collections of JAXB Objects</a></span><ul><li><span class="sect2"><a href="#collections_on_client">22.6.1. Retrieving Collections on the client side</a></span></li><li><span class="sect2"><a href="#json_list">22.6.2. JSON and JAXB Collections/arrays</a></span></li></ul></li><li><span class="sect1"><a href="#JAXB_Map">22.7. Maps of JAXB Objects</a></span><ul><li><span class="sect2"><a href="#maps_client_side">22.7.1. Retrieving Maps on the client side</a></span></li><li><span class="sect2"><a href="#json_map">22.7.2. JSON and JAXB maps</a></span></li></ul></li><li><span class="sect1"><a href="#JAXB_INTERFACES">22.8. Interfaces, Abstract Classes, and JAXB</a></span></li><li><span class="sect1"><a href="#configuration">22.9. Configurating JAXB Marshalling</a></span></li></ul></div>
   

   <p>
      As required by the specification, RESTEasy JAX-RS includes support for (un)marshalling JAXB annotated classes.
      RESTEasy provides multiple JAXB Providers to address some subtle differences between classes generated by XJC
      and classes which are simply annotated with @XmlRootElement, or working with JAXBElement classes directly.
   </p>
   <p>

      For the most part, developers using the JAX-RS API, the selection of which provider is invoked will be
      completely transparent. For developers wishing to access the providers directly (which most folks won't need to
      do), this document describes which provider is best suited for different configurations.
   </p>
   <p>
      A JAXB Provider is selected by RESTEasy when a parameter or return type is an object that is annotated with
      JAXB annotations (such as @XmlRootEntity or @XmlType) or if the type is a JAXBElement. Additionally, the
      resource class or resource method will be annotated with either a @Consumes or @Produces annotation and
      contain one or more of the following values:
   </p>
   <p>

      </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
            text/*+xml
         </li><li class="listitem">
            application/*+xml
         </li><li class="listitem">
            application/*+fastinfoset
         </li><li class="listitem">
            application/*+json
         </li></ul></div><p>

   </p>
   <p>

   </p>
   <p>

      RESTEasy will select a different provider based on the return type or parameter type used in the resource. This
      section describes how the selection process works.
   </p>
   <p>

      @XmlRootEntity
      When a class is annotated with a @XmlRootElement annotation, RESTEasy will select the
      JAXBXmlRootElementProvider. This provider handles basic marshaling and unmarshalling of custom JAXB
      entities.
   </p>
   <p>

      @XmlType
      Classes which have been generated by XJC will most likely not contain an @XmlRootEntity annotation. In order
      for these classes to marshalled, they must be wrapped within a JAXBElement instance. This is typically
      accomplished by invoking a method on the class which serves as the XmlRegistry and is named ObjectFactory.
   </p>
   <p>

      The JAXBXmlTypeProvider provider is selected when the class is annotated with an XmlType annotation and not an
      XmlRootElement annotation.
   </p>
   <p>

      This provider simplifies this task by attempting to locate the XmlRegistry for the target class. By default, a
      JAXB implementation will create a class called ObjectFactory and is located in the same package as the target
      class. When this class is located, it will contain a "create" method that takes the object instance
      as a parameter. For example, if the target type is called "Contact", then the ObjectFactory class
      will have a method:
   </p>
   <p>

      public JAXBElement createContact(Contact value) {..
   </p>
   <p>

      JAXBElement&lt;?&gt;
      If your resource works with the JAXBElement class directly, the RESTEasy runtime will select the
      JAXBElementProvider. This provider examines the ParameterizedType value of the JAXBElement in order to select
      the appropriate JAXBContext.
   </p>
   <p>

   </p>
   <p>


   </p>
    <section class="sect1" id="decorators"><div class="titlepage"><div><div><h2 class="title">22.1. JAXB Decorators</h2></div></div></div>
        
        <p>Resteasy's JAXB providers have a pluggable way to decorate Marshaller and Unmarshaller instances.
        The way it works is that you can write an annotation that can trigger the decoration of a
        Marshaller or Unmarshaller.  Your decorators can do things like set Marshaller or Unmarshaller properties,
        set up validation, stuff like that.  Here's an example.  Let's say we want to have an annotation
        that will trigger pretty-printing, nice formatting, of an XML document.  If we were doing raw
        JAXB, we would set a property on the Marshaller of Marshaller.JAXB_FORMATTED_OUTPUT.  Let's
        write a Marshaller decorator.</p>
        <p>First we define a annotation:</p>
<pre><code class="no-highlight">
import org.jboss.resteasy.annotations.Decorator;

@Target({ElementType.TYPE, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Decorator(processor = PrettyProcessor.class, target = Marshaller.class)
public @interface Pretty {}
</code></pre>
        <p>To get this to work, we must annotate our @Pretty annotation with a meta-annotation called
        @Decorator.  The target() attribute must be the JAXB Marshaller class.  The processor()
        attribute is a class we will write next.</p>
<pre><code class="no-highlight">
import org.jboss.resteasy.core.interception.DecoratorProcessor;
import org.jboss.resteasy.annotations.DecorateTypes;

import javax.xml.bind.Marshaller;
import javax.xml.bind.PropertyException;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.Produces;
import java.lang.annotation.Annotation;

/**
 * @author &lt;a href="mailto:bill@burkecentral.com"&gt;Bill Burke&lt;/a&gt;
 * @version $Revision: 1 $
 */
@DecorateTypes({"text/*+xml", "application/*+xml"})
public class PrettyProcessor implements DecoratorProcessor&lt;Marshaller, Pretty&gt;
{
    public Marshaller decorate(Marshaller target, Pretty annotation,
                  Class type, Annotation[] annotations, MediaType mediaType)
    {
       target.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);
    }
}
</code></pre>
    <p>
        The processor implementation must implement the DecoratorProcessor interface and should also be annotated
        with @DecorateTypes.  This annotation specifies what media types the processor can be used with. Now that
        we've defined our annotation and our Processor, we can use it on our JAX-RS resource methods
        or JAXB types as follows:
    </p>
<pre><code class="no-highlight">
@GET
@Pretty
@Produces("application/xml")
public SomeJAXBObject get() {...}
</code></pre>
        <p>If you are confused, check the RESTEasy source code for the implementation of @XmlHeader</p>
    </section>
   <section class="sect1" id="Pluggable_JAXBContext_s_with_ContextResolvers"><div class="titlepage"><div><div><h2 class="title">22.2. Pluggable JAXBContext's with ContextResolvers</h2></div></div></div>
      

      <p>

         You should not use this feature unless you know what you're doing.
      </p>
      <p>

         Based on the class you are marshalling/unmarshalling, RESTEasy will, by default create and cache JAXBContext
         instances per class type. If you do not want RESTEasy to create JAXBContexts, you can plug-in your own by
         implementing an instance of javax.ws.rs.ext.ContextResolver
      </p>
      <p>

</p><pre><code class="no-highlight">
public interface ContextResolver&lt;T&gt;
{
    T getContext(Class&lt;?&gt; type);
}

@Provider
@Produces("application/xml")
public class MyJAXBContextResolver implements ContextResolver&lt;JAXBContext&gt;
{
    JAXBContext getContext(Class&lt;?&gt; type)
    {
        if (type.equals(WhateverClassIsOverridedFor.class)) return JAXBContext.newInstance()...;
    }
}
</code></pre><p>
      </p>
      <p>

         You must provide a @Produces annotation to specify the media type the context is meant for. You must also
         make sure to implement ContextResolver&lt;JAXBContext&gt;. This helps the runtime match to the correct
         context resolver. You must also annotate the ContextResolver class with @Provider.
      </p>
      <p>

         There are multiple ways to make this ContextResolver available.
      </p>
      <p>

         </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
               Return it as a class or instance from a javax.ws.rs.core.Application implementation
            </li><li class="listitem">
               List it as a provider with resteasy.providers
            </li><li class="listitem">
               Let RESTEasy automatically scan for it within your WAR file. See Configuration Guide
            </li><li class="listitem">
               Manually add it via ResteasyProviderFactory.getInstance().registerProvider(Class) or
               registerProviderInstance(Object)
            </li></ol></div><p>

      </p>
      <p>


      </p>
   </section>
   <section class="sect1" id="JAXB_+_XML_provider"><div class="titlepage"><div><div><h2 class="title">22.3. JAXB + XML provider</h2></div></div></div>
      
       <p>
           RESTEasy is required to provide JAXB provider support for XML.  It has a few extra annotations
           that can help code your app.
       </p>
       <section class="sect2" id="XmlHeader"><div class="titlepage"><div><div><h3 class="title">22.3.1. @XmlHeader and @Stylesheet</h3></div></div></div>
           
           <p>Sometimes when outputting XML documents you may want to set an XML header. RESTEasy provides
           the @org.jboss.resteasy.annotations.providers.jaxb.XmlHeader annotation for this.  For example:</p>
<pre><code class="no-highlight">
@XmlRootElement
public static class Thing
{
    private String name;

    public String getName()
    {
        return name;
    }

    public void setName(String name)
    {
        this.name = name;
    }
}

@Path("/test")
public static class TestService
{
    @GET
    @Path("/header")
    @Produces("application/xml")
    @XmlHeader("&lt;?xml-stylesheet type='text/xsl' href='${baseuri}foo.xsl' ?&gt;")
    public Thing get()
    {
        Thing thing = new Thing();
        thing.setName("bill");
        return thing;
    }
}
</code></pre>
           <p>
               The @XmlHeader here forces the XML output to have an xml-stylesheet header.  This header
               could also have been put on the Thing class to get the same result.  See the javadocs for more
               details on how you can use substitution values provided by resteasy.
               </p>
           <p>
               RESTEasy also has a convenience annotation for stylesheet headers.  For example:
           </p>
<pre><code class="no-highlight">
@XmlRootElement
public static class Thing
{
    private String name;

    public String getName()
    {
        return name;
    }

    public void setName(String name)
    {
        this.name = name;
    }
}

@Path("/test")
public static class TestService
{
    @GET
    @Path("/stylesheet")
    @Produces("application/xml")
    @Stylesheet(type="text/css", href="${basepath}foo.xsl")
    @Junk
    public Thing getStyle()
    {
        Thing thing = new Thing();
        thing.setName("bill");
        return thing;
    }
}
</code></pre>
       </section>
   </section>
   <section class="sect1" id="JAXB_+_JSON_provider"><div class="titlepage"><div><div><h2 class="title">22.4. JAXB + JSON provider</h2></div></div></div>
      

      <p>
         RESTEasy allows you to marshall JAXB annotated POJOs to and from JSON. This provider wraps the Jackson2 library to accomplish this.
      </p>
      <p>
           To use this integration with Jackson you need to import the resteasy-jackson2-provider Maven module.
       </p>
      <p>
         For example, consider this JAXB class:
      </p>
<pre><code class="no-highlight">
@XmlRootElement(name = "book")
public class Book
{
    private String author;
    private String ISBN;
    private String title;

    public Book()
    {
    }

    public Book(String author, String ISBN, String title)
    {
        this.author = author;
        this.ISBN = ISBN;
        this.title = title;
    }

    @XmlElement
    public String getAuthor()
    {
        return author;
    }

    public void setAuthor(String author)
    {
    this.author = author;
    }

    @XmlElement
    public String getISBN()
    {
        return ISBN;
    }

    public void setISBN(String ISBN)
    {
        this.ISBN = ISBN;
    }

    @XmlAttribute
    public String getTitle()
    {
        return title;
    }

    public void setTitle(String title)
    {
        this.title = title;
    }
}
</code></pre>
       <p>
           And we can write a method to use the above entity:
       </p>
<pre><code class="no-highlight">
@Path("/test_json")
@GET
@Produces(MediaType.APPLICATION_JSON)
public Book test_json() {
    Book book = new Book();
    book.setTitle("EJB 3.0");
    book.setAuthor("Bill Burke");
    book.setISBN("596529260");
    return book;
}
</code></pre>
       <p>
           Requesting from the above method, and we can see the default Jackson2 marshaller would return JSON that looked like this:
       </p>
       <p>
</p><pre><code class="no-highlight">
$ http localhost:8080/dummy/test_json
HTTP/1.1 200
...
Content-Type: application/json

{
"ISBN": "596529260",
"author": "Bill Burke",
"title": "EJB 3.0"
}</code></pre><p>
       </p>
   </section>
   <section class="sect1" id="JAXB_+_FastinfoSet_provider"><div class="titlepage"><div><div><h2 class="title">22.5. JAXB + FastinfoSet provider</h2></div></div></div>
      

      <p>

         RESTEasy supports the FastinfoSet mime type with JAXB annotated classes. Fast infoset documents are faster
         to serialize and parse, and smaller in size, than logically equivalent XML documents. Thus, fast infoset
         documents may be used whenever the size and processing time of XML documents is an issue. It is configured
         the same way the XML JAXB provider is so really no other documentation is needed here.
      </p>
       <p>
           To use this integration with Fastinfoset you need to import the resteasy-fastinfoset-provider Maven module.  Older versions
           of RESTEasy used to include this within the resteasy-jaxb-provider but we decided to modularize it more.
       </p>
      <p>


      </p>
   </section>
   <section class="sect1" id="JAXB_Collections"><div class="titlepage"><div><div><h2 class="title">22.6. Arrays and Collections of JAXB Objects</h2></div></div></div>
      
      <p>
         RESTEasy will automatically
         marshal arrays, java.util.Set's, and java.util.List's of JAXB objects to and from XML, JSON, Fastinfoset (or any other new JAXB mapper Restasy comes up with).
      </p>
<pre><code class="no-highlight">
@XmlRootElement(name = "customer")
@XmlAccessorType(XmlAccessType.FIELD)
public class Customer
{
    @XmlElement
    private String name;

    public Customer()
    {
    }

    public Customer(String name)
    {
        this.name = name;
    }

    public String getName()
    {
        return name;
    }
}

@Path("/")
public class MyResource
{
    @PUT
    @Path("array")
    @Consumes("application/xml")
    public void putCustomers(Customer[] customers)
    {
        Assert.assertEquals("bill", customers[0].getName());
        Assert.assertEquals("monica", customers[1].getName());
    }

    @GET
    @Path("set")
    @Produces("application/xml")
    public Set&lt;Customer&gt; getCustomerSet()
    {
        HashSet&lt;Customer&gt; set = new HashSet&lt;Customer&gt;();
        set.add(new Customer("bill"));
        set.add(new Customer("monica"));

        return set;
    }

    @PUT
    @Path("list")
    @Consumes("application/xml")
    public void putCustomers(List&lt;Customer&gt; customers)
    {
        Assert.assertEquals("bill", customers.get(0).getName());
        Assert.assertEquals("monica", customers.get(1).getName());
    }
}
</code></pre>
   <p>
      The above resource can publish and receive JAXB objects.  It is assumed that are wrapped in a collection element
   </p>
<pre><code class="no-highlight">
&lt;collection&gt;
    &lt;customer&gt;&lt;name&gt;bill&lt;/name&gt;&lt;/customer&gt;
    &lt;customer&gt;&lt;name&gt;monica&lt;/name&gt;&lt;/customer&gt;
&lt;collection&gt;
</code></pre>
   <p>You can change the namespace URI, namespace tag, and collection element name by using the @org.jboss.resteasy.annotations.providers.jaxb.Wrapped annotation on a parameter or method</p>
<pre><code class="no-highlight">
@Target({ElementType.PARAMETER, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface Wrapped
{
    String element() default "collection";

    String namespace() default "http://jboss.org/resteasy";

    String prefix() default "resteasy";
}
</code></pre>
<p>So, if we wanted to output this XML</p>
<pre><code class="no-highlight">
&lt;foo:list xmlns:foo="http://foo.org"&gt;
    &lt;customer&gt;&lt;name&gt;bill&lt;/name&gt;&lt;/customer&gt;
    &lt;customer&gt;&lt;name&gt;monica&lt;/name&gt;&lt;/customer&gt;
&lt;/foo:list&gt;
</code></pre>
<p>We would use the @Wrapped annotation as follows: </p>
<pre><code class="no-highlight">
@GET
@Path("list")
@Produces("application/xml")
@Wrapped(element="list", namespace="http://foo.org", prefix="foo")
public List&lt;Customer&gt; getCustomerSet()
{
    List&lt;Customer&gt; list = new ArrayList&lt;Customer&gt;();
    list.add(new Customer("bill"));
    list.add(new Customer("monica"));

    return list;
}
</code></pre>

  <section class="sect2" id="collections_on_client"><div class="titlepage"><div><div><h3 class="title">22.6.1. Retrieving Collections on the client side</h3></div></div></div>
  
  <p>
  If you try to retrieve a <code class="classname">List</code>
  or <code class="classname">Set</code> of JAXB objects in the obvious way on the client side:
  </p>

<pre><code class="no-highlight">
      Response response = request.get();
      List&lt;Customer&gt; list = response.readEntity(List.class);
</code></pre>

  <p>
  the call to <code class="methodname">readEntity()</code> will fail because it has no way of knowing the
  element type <code class="classname">Customer</code>. The trick is to use an instance of
  <code class="classname">javax.ws.rs.core.GenericType</code>:
  </p>

<pre><code class="no-highlight">
      Response response = request.get();
      GenericType&lt;List&lt;Customer&gt;&gt; genericType = new GenericType&lt;List&lt;Customer&gt;&gt;() {};
      List&lt;Customer&gt; list = response.readEntity(genericType);
</code></pre>

  <p>
  For more information about <code class="classname">GenericType</code>, please see its javadoc.
  </p>

  <p>
  The same trick applies to retrieving a <code class="classname">Set</code>:
  </p>

<pre><code class="no-highlight">
      Response response = request.get();
      GenericType&lt;Set&lt;Customer&gt;&gt; genericType = new GenericType&lt;Set&lt;Customer&gt;&gt;() {};
      Set&lt;Customer&gt; set = response.readEntity(genericType);
</code></pre>

  <p>
  On the other hand, <code class="classname">GenericType</code> is not necessary to retrieve an array of JAXB objects:
  </p>

<pre><code class="no-highlight">
      Response response = request.get();
      Customer[] array = response.readEntity(Customer[].class);
</code></pre>
  </section>

  <section class="sect2" id="json_list"><div class="titlepage"><div><div><h3 class="title">22.6.2. JSON and JAXB Collections/arrays</h3></div></div></div>
    
    <p>RESTEasy supports using collections with JSON.  It encloses lists, sets, or arrays of returned JAXB objects within a simple
    JSON array.  For example:</p>
<pre><code class="no-highlight">
@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public static class Foo
{
    @XmlAttribute
    private String test;

    public Foo()
    {
    }

    public Foo(String test)
    {
        this.test = test;
    }

    public String getTest()
    {
        return test;
    }

    public void setTest(String test)
    {
        this.test = test;
    }
}
</code></pre>
 <p>This a List or array of this Foo class would be represented in JSON like this:</p>
<pre><code class="no-highlight">
[{"foo":{"@test":"bill"}},{"foo":{"@test":"monica}"}}]
</code></pre>
 <p>It also expects this format for input</p>
  </section>
</section>
   <section class="sect1" id="JAXB_Map"><div class="titlepage"><div><div><h2 class="title">22.7. Maps of JAXB Objects</h2></div></div></div>
      
      <p>
         RESTEasy will automatically
         marshal maps of JAXB objects to and from XML, JSON, Fastinfoset (or any other new JAXB mapper Restasy comes up with).
         Your parameter or method return type must be a generic with a String as the key and the JAXB object's type.
     </p>
<pre><code class="no-highlight">
@XmlRootElement(namespace = "http://foo.com")
public static class Foo
{
    @XmlAttribute
    private String name;

    public Foo()
    {
    }

    public Foo(String name)
    {
        this.name = name;
    }

    public String getName()
    {
        return name;
    }
}

@Path("/map")
public static class MyResource
{
    @POST
    @Produces("application/xml")
    @Consumes("application/xml")
    public Map&lt;String, Foo&gt; post(Map&lt;String, Foo&gt; map)
    {
        Assert.assertEquals(2, map.size());
        Assert.assertNotNull(map.get("bill"));
        Assert.assertNotNull(map.get("monica"));
        Assert.assertEquals(map.get("bill").getName(), "bill");
        Assert.assertEquals(map.get("monica").getName(), "monica");
        return map;
    }
}
</code></pre>
   <p>
      The above resource can publish and receive JAXB objects within a map.  By default, they are wrapped in a "map" element in the
      default namespace.  Also, each "map" element has zero or more "entry" elements with a "key" attribute.
   </p>
<pre><code class="no-highlight">
&lt;map&gt;
    &lt;entry key="bill" xmlns="http://foo.com"&gt;
        &lt;foo name="bill"/&gt;
    &lt;/entry&gt;
    &lt;entry key="monica" xmlns="http://foo.com"&gt;
        &lt;foo name="monica"/&gt;
    &lt;/entry&gt;
&lt;/map&gt;
</code></pre>
   <p>You can change the namespace URI, namespace prefix and map, entry, and key element and attribute names by using the @org.jboss.resteasy.annotations.providers.jaxb.WrappedMap annotation on a parameter or method</p>
<pre><code class="no-highlight">
@Target({ElementType.PARAMETER, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface WrappedMap
{
    /**
     * map element name
     */
    String map() default "map";

    /**
     * entry element name *
     */
    String entry() default "entry";

    /**
     * entry's key attribute name
     */
    String key() default "key";

    String namespace() default "";

    String prefix() default "";
}
</code></pre>
<p>So, if we wanted to output this XML</p>
<pre><code class="no-highlight">
&lt;hashmap&gt;
    &lt;hashentry hashkey="bill" xmlns:foo="http://foo.com"&gt;
        &lt;foo:foo name="bill"/&gt;
    &lt;/hashentry&gt;
&lt;/map&gt;
</code></pre>
<p>We would use the @WrappedMap annotation as follows: </p>
<pre><code class="no-highlight">
@Path("/map")
public static class MyResource
{
    @GET
    @Produces("application/xml")
    @WrappedMap(map="hashmap", entry="hashentry", key="hashkey")
    public Map&lt;String, Foo&gt; get()
    {
        ...
        return map;
    }
}
</code></pre>

  <section class="sect2" id="maps_client_side"><div class="titlepage"><div><div><h3 class="title">22.7.1. Retrieving Maps on the client side</h3></div></div></div>
  
  <p>
  If you try to retrieve a <code class="classname">Map</code>
  of JAXB objects in the obvious way on the client side:
  </p>

<pre><code class="no-highlight">
      Response response = request.get();
      Map&lt;String, Customer&gt; map = response.readEntity(Map.class);
</code></pre>

  <p>
  the call to <code class="methodname">readEntity()</code> will fail because it has no way of knowing the
  element type <code class="classname">Customer</code>. The trick is to use an instance of
  <code class="classname">javax.ws.rs.core.GenericType</code>:
  </p>

<pre><code class="no-highlight">
      Response response = request.get();
      GenericType&lt;Map&lt;String, Customer&gt; genericType = new GenericType&lt;Map&lt;String, Customer&gt;&gt;() {};
      Map&lt;String, Customer&gt; map = response.readEntity(genericType);
</code></pre>

  <p>
  For more information about <code class="classname">GenericType</code>, please see its javadoc.
  </p>
  </section>

  <section class="sect2" id="json_map"><div class="titlepage"><div><div><h3 class="title">22.7.2. JSON and JAXB maps</h3></div></div></div>
    
    <p>RESTEasy supports using maps with JSON.  It encloses maps returned JAXB objects within a simple
    JSON map.  For example:</p>
<pre><code class="no-highlight">
@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public static class Foo
{
    @XmlAttribute
    private String test;

    public Foo()
    {
    }

    public Foo(String test)
    {
        this.test = test;
    }

    public String getTest()
    {
        return test;
    }

    public void setTest(String test)
    {
        this.test = test;
    }
}
</code></pre>
 <p>This a List or array of this Foo class would be represented in JSON like this:</p>
<pre><code class="no-highlight">
{ "entry1" : {"foo":{"@test":"bill"}}, "entry2" : {"foo":{"@test":"monica}"}}}
</code></pre>
 <p>It also expects this format for input</p>
  </section>
</section>
<section class="sect1" id="JAXB_INTERFACES"><div class="titlepage"><div><div><h2 class="title">22.8. Interfaces, Abstract Classes, and JAXB</h2></div></div></div>
   
   <p>
    Some objects models use abstract classes and interfaces heavily.  Unfortunately, JAXB doesn't work with interfaces
    that are root elements and RESTEasy can't unmarshal parameters that are interfaces or raw abstract classes because
    it doesn't have enough information to create a JAXBContext.  For example:
   </p>
<pre><code class="no-highlight">
public interface IFoo {}

@XmlRootElement
public class RealFoo implements IFoo {}

@Path("/jaxb")
public class MyResource {

    @PUT
    @Consumes("application/xml")
    public void put(IFoo foo) {...}
}
</code></pre>
<p>
  In this example, you would get an error from RESTEasy of something like "Cannot find a MessageBodyReader for...".  This is because
  RESTEasy does not know that implementations of IFoo are JAXB classes and doesn't know how to create a JAXBContext for it.  As a workaround,
 RESTEasy allows you to use the JAXB annotation @XmlSeeAlso on the interface to correct the problem.  (NOTE, this will not work with manual, hand-coded JAXB).
</p>
<pre><code class="no-highlight">
@XmlSeeAlso(RealFoo.class)
public interface IFoo {}
</code></pre>
<p>
The extra @XmlSeeAlso on IFoo allows RESTEasy to create a JAXBContext that knows how to unmarshal RealFoo instances.
</p>
</section>

<section class="sect1" id="configuration"><div class="titlepage"><div><div><h2 class="title">22.9. Configurating JAXB Marshalling</h2></div></div></div>
   
   <p>
     As a consumer of XML datasets, JAXB is subject to a form of attack
     known as the XXE (Xml eXternal Entity) Attack
     (<a class="ulink" href="http://www.securiteam.com/securitynews/6D0100A5PU.html">http://www.securiteam.com/securitynews/6D0100A5PU.html</a>),
     in which expanding an external entity causes an unsafe file to be loaded.  Preventing the expansion of
     external entities is discussed in <a class="xref" href="#Configuring_Document_Marshalling" title="21.4. Configuring Document Marshalling">Section 21.4, “Configuring Document Marshalling”</a>.  The same
     parameter,
   </p>

   <div class="blockquote"><blockquote class="blockquote">
     resteasy.document.expand.entity.references
   </blockquote></div>

   <p>applies to JAXB unmarshallers as well.</p>


   <p>
     <a class="xref" href="#Configuring_Document_Marshalling" title="21.4. Configuring Document Marshalling">Section 21.4, “Configuring Document Marshalling”</a> also discusses the prohibition of DTDs and the
     imposition of limits on entity expansion and the number of attributes per element. The parameters
   </p>

   <div class="blockquote"><blockquote class="blockquote">
     resteasy.document.secure.disableDTDs
   </blockquote></div>

   <p>and</p>

   <div class="blockquote"><blockquote class="blockquote">
     resteasy.document.secure.processing.feature
   </blockquote></div>

   <p>
     discussed there, and their default values, also apply to the representation of JAXB objects.
   </p>
</section>
</section>

    <section class="chapter" id="Atom"><div class="titlepage"><div><div><h1 class="title">Chapter 23. RESTEasy Atom Support</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="sect1"><a href="#resteasy_atom">23.1. RESTEasy Atom API and Provider</a></span></li><li><span class="sect1"><a href="#jaxb_atom">23.2. Using JAXB with the Atom Provider</a></span></li></ul></div>
   
   <p>
      From W3.org (http://tools.ietf.org/html/rfc4287):
   </p>
   <p>
      "Atom is an XML-based document format that describes lists of related
      information known as "feeds". Feeds are composed of a number of
      items, known as "entries", each with an extensible set of attached
      metadata. For example, each entry has a title.

      The primary use case that Atom addresses is the syndication of Web
      content such as weblogs and news headlines to Web sites as well as
      directly to user agents."
   </p>
   <p>
      Atom is the next-gen RSS feed. Although it is used primarily for the syndication of blogs and news, many
      are starting to use this format as the envelope for Web Services, for example, distributed notifications, job
      queues, or simply a nice format for sending or receiving data in bulk from a service.
   </p>
   <section class="sect1" id="resteasy_atom"><div class="titlepage"><div><div><h2 class="title">23.1. RESTEasy Atom API and Provider</h2></div></div></div>
      
      <p>RESTEasy has defined a simple object model in Java to represent Atom and uses JAXB to marshal and unmarshal
         it. The
         main classes are in the org.jboss.resteasy.plugins.providers.atom package and are Feed, Entry, Content, and
         Link. If you
         look at the source, you'd see that these are annotated with JAXB annotations. The distribution contains
         the javadocs for this project and are a must to learn the model. Here is a simple example of sending
         an atom feed using the RESTEasy API.
      </p>
      <pre><code class="no-highlight">
import org.jboss.resteasy.plugins.providers.atom.Content;
import org.jboss.resteasy.plugins.providers.atom.Entry;
import org.jboss.resteasy.plugins.providers.atom.Feed;
import org.jboss.resteasy.plugins.providers.atom.Link;
import org.jboss.resteasy.plugins.providers.atom.Person;

@Path("atom")
public class MyAtomService
{
    @GET
    @Path("feed")
    @Produces("application/atom+xml")
    public Feed getFeed() throws URISyntaxException
    {
        Feed feed = new Feed();
        feed.setId(new URI("http://example.com/42"));
        feed.setTitle("My Feed");
        feed.setUpdated(new Date());
        Link link = new Link();
        link.setHref(new URI("http://localhost"));
        link.setRel("edit");
        feed.getLinks().add(link);
        feed.getAuthors().add(new Person("Bill Burke"));
        Entry entry = new Entry();
        entry.setTitle("Hello World");
        Content content = new Content();
        content.setType(MediaType.TEXT_HTML_TYPE);
        content.setText("Nothing much");
        entry.setContent(content);
        feed.getEntries().add(entry);
        return feed;
    }
}</code></pre>
      <p>Because RESTEasy's atom provider is JAXB based, you are not limited to sending atom objects using XML.
         You can automatically re-use all the other JAXB providers that RESTEasy has like JSON and fastinfoset.
         All you have to do is have "atom+" in front of the main subtype. i.e. @Produces("application/atom+json") or
         @Consumes("application/atom+fastinfoset")
      </p>
   </section>
   <section class="sect1" id="jaxb_atom"><div class="titlepage"><div><div><h2 class="title">23.2. Using JAXB with the Atom Provider</h2></div></div></div>
      
      <p>
         The org.jboss.resteasy.plugins.providers.atom.Content class allows you to unmarshal and marshal JAXB
         annotated objects that are the body of the content. Here's an example of sending an Entry with
         a Customer object attached as the body of the entry's content.
      </p>
      <pre><code class="no-highlight">
@XmlRootElement(namespace = "http://jboss.org/Customer")
@XmlAccessorType(XmlAccessType.FIELD)
public class Customer
{
    @XmlElement
    private String name;

    public Customer()
    {
    }

    public Customer(String name)
    {
        this.name = name;
    }

    public String getName()
    {
        return name;
    }
}

@Path("atom")
public static class AtomServer
{
    @GET
    @Path("entry")
    @Produces("application/atom+xml")
    public Entry getEntry()
    {
        Entry entry = new Entry();
        entry.setTitle("Hello World");
        Content content = new Content();
        content.setJAXBObject(new Customer("bill"));
        entry.setContent(content);
        return entry;
    }
}</code></pre>
      <p>
         The Content.setJAXBObject() method is used to tell the content object you are sending back
         a Java JAXB object and want it marshalled appropriately. If you are using a different base
         format other than XML, i.e. "application/atom+json", this attached JAXB object will be marshalled
         into that same format.
      </p>
      <p>
         If you have an atom document as your input, you can also extract JAXB objects from Content using the
         Content.getJAXBObject(Class clazz) method. Here is an example of an input atom document and extracting
         a Customer object from the content.
      </p>
      <pre><code class="no-highlight">
@Path("atom")
public static class AtomServer
{
    @PUT
    @Path("entry")
    @Produces("application/atom+xml")
    public void putCustomer(Entry entry)
    {
        Content content = entry.getContent();
        Customer cust = content.getJAXBObject(Customer.class);
    }
}
</code></pre>
   </section>

</section>

    <section class="chapter" id="json"><div class="titlepage"><div><div><h1 class="title">Chapter 24. JSON Support via Jackson</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="sect1"><a href="#d5e1441">24.1. Using Jackson 1.9.x Outside of WildFly</a></span></li><li><span class="sect1"><a href="#d5e1445">24.2. Using Jackson 1.9.x Inside WildFly 8</a></span></li><li><span class="sect1"><a href="#d5e1449">24.3. Using Jackson 2 Outside of WildFly</a></span></li><li><span class="sect1"><a href="#d5e1453">24.4. Using Jackson 2 Inside WildFly 9 and above</a></span></li><li><span class="sect1"><a href="#d5e1457">24.5. Additional RESTEasy Specifics</a></span></li><li><span class="sect1"><a href="#JSONP_Support">24.6. JSONP Support</a></span></li><li><span class="sect1"><a href="#Jackson_JSON_Decorator">24.7. Jackson JSON Decorator</a></span></li><li><span class="sect1"><a href="#JSON_Filter_Support">24.8. JSON Filter Support</a></span></li><li><span class="sect1"><a href="#Polymorphic_Typing_deserialization">24.9. Polymorphic Typing deserialization</a></span></li></ul></div>
    
    <p>RESTEasy supports integration with the Jackson project.
        For more on Jackson 2, see <a class="ulink" href="http://wiki.fasterxml.com/JacksonHome">http://wiki.fasterxml.com/JacksonHome</a>.
        Besides JAXB like APIs, it has a JavaBean based model, described at
        <a class="ulink" href="http://wiki.fasterxml.com/JacksonDataBinding">http://wiki.fasterxml.com/JacksonDataBinding</a>,
        which allows you to easily marshal Java objects to and from JSON.
        RESTEasy integrates with the JavaBean model.
        While Jackson does come with its own JAX-RS integration, RESTEasy expanded it a little, as decribed below.
    </p>
    <p>
    <span class="bold"><strong>NOTE.</strong></span> The resteasy-jackson-provider module, which is based on the outdated Jackson 1.9.x, is
    currently deprecated, and will be removed in a release subsequent to 3.1.0.Final. The resteasy-jackson2-provider
    module is based on Jackson 2.
    </p>

    <section class="sect1" id="d5e1441"><div class="titlepage"><div><div><h2 class="title">24.1. Using Jackson 1.9.x Outside of WildFly</h2></div></div></div>
        
        <p>If you're deploying RESTEasy outside of WildFly,
        add the RESTEasy Jackson provder to your WAR pom.xml build:</p>
        <pre><code class="no-highlight">
&lt;dependency&gt;
   &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
   &lt;artifactId&gt;resteasy-jackson-provider&lt;/artifactId&gt;
   &lt;version&gt;${version.resteasy}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
    </section>
    <section class="sect1" id="d5e1445"><div class="titlepage"><div><div><h2 class="title">24.2. Using Jackson 1.9.x Inside WildFly 8</h2></div></div></div>
        
        <p>If you're deploying RESTEasy with WildFly 8,
        there's nothing you need to do except to make sure
        you've updated your installation with the latest and greatest RESTEasy.  See the
        <a class="link" href="#Installation_Configuration" title="Chapter 3. Installation/Configuration">Installation/Configuration</a> section
        of this documentation for more details.</p>
    </section>
    <section class="sect1" id="d5e1449"><div class="titlepage"><div><div><h2 class="title">24.3. Using Jackson 2 Outside of WildFly</h2></div></div></div>
        
        <p>If you're deploying RESTEasy outside of WildFly,
        add the RESTEasy Jackson provder to your WAR pom.xml build:</p>
        <pre><code class="no-highlight">
&lt;dependency&gt;
   &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
   &lt;artifactId&gt;resteasy-jackson2-provider&lt;/artifactId&gt;
   &lt;version&gt;${version.resteasy}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
    </section>
    <section class="sect1" id="d5e1453"><div class="titlepage"><div><div><h2 class="title">24.4. Using Jackson 2 Inside WildFly 9 and above</h2></div></div></div>
        
        <p>If you're deploying RESTEasy with WildFly 9 or above,
        there's nothing you need to do except to make sure
        you've updated your installation with the latest and greatest RESTEasy.  See the
        <a class="link" href="#Installation_Configuration" title="Chapter 3. Installation/Configuration">Installation/Configuration</a> section
        of this documentation for more details.</p>
    </section>
    <section class="sect1" id="d5e1457"><div class="titlepage"><div><div><h2 class="title">24.5. Additional RESTEasy Specifics</h2></div></div></div>
        

    <p>The first extra piece that RESTEasy added to the integration was
        to support "application/*+json". Jackson would only accept "application/json" and "text/json" as valid
        media types. This allows you to create json-based media types and still
        let Jackson marshal things for you. For example:
    </p>
    <pre><code class="no-highlight">
@Path("/customers")
public class MyService {

    @GET
    @Produces("application/vnd.customer+json")
    public Customer[] getCustomers() {}
}
</code></pre>
    </section>

    <section class="sect1" id="JSONP_Support"><div class="titlepage"><div><div><h2 class="title">24.6. JSONP Support</h2></div></div></div>
        
        <p>
            If you're using Jackson, RESTEasy has <a class="ulink" href="http://en.wikipedia.org/wiki/JSONP">JSONP</a> that you can turn on by adding
            the provider <code class="literal">org.jboss.resteasy.plugins.providers.jackson.JacksonJsonpInterceptor</code> (Jackson2JsonpInterceptor if you're using the Jackson2 provider)
            to your deployments.
            If the media type of the response is json and a callback query parameter is given, the response will be a javascript snippet with
            a method call of the method defined by the callback parameter.
            For example:
</p><pre><code class="no-highlight">
GET /resources/stuff?callback=processStuffResponse
</code></pre><p>
            will produce this response:
</p><pre><code class="no-highlight">
processStuffResponse(&lt;nomal JSON body&gt;)
</code></pre><p>
            This supports the default behavior of <a class="ulink" href="http://api.jquery.com/jQuery.ajax/">jQuery</a>.
            To enable JacksonJsonpInterceptor in WildFly, you need to import annotations from <code class="literal">org.jboss.resteasy.resteasy-jackson-provider</code> module using jboss-deployment-structure.xml:
</p><pre><code class="no-highlight">
&lt;jboss-deployment-structure&gt;
  &lt;deployment&gt;
    &lt;dependencies&gt;
      &lt;module name="org.jboss.resteasy.resteasy-jackson-provider" annotations="true"/&gt;
    &lt;/dependencies&gt;
  &lt;/deployment&gt;
&lt;/jboss-deployment-structure&gt;
</code></pre><p>
        </p>
        <p>
            You can change the name of the callback parameter by setting the callbackQueryParameter property.
        </p>
        <p>
            JacksonJsonpInterceptor can wrap the response into a try-catch block:
</p><pre><code class="no-highlight">
try{processStuffResponse(&lt;normal JSON body&gt;)}catch(e){}
</code></pre><p>
            You can enable this feature by setting the resteasy.jsonp.silent property to true
        </p>
        <p>
        <span class="bold"><strong>Note.</strong></span> Because JSONP can be used in
        <span class="bold"><strong>Cross Site Scripting Inclusion (XSSI) attacks</strong></span>,
        <code class="methodname">Jackson2JsonpInterceptor</code>
        is disabled by default. Two steps are necessary to enable it:
        </p>
        <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">As noted above, <code class="methodname">Jackson2JsonpInterceptor</code> must be
           included in the deployment. For example,
           a service file META-INF/services/javax.ws.rs.ext.Providers with the line
<pre><code class="no-highlight">
org.jboss.resteasy.plugins.providers.jackson.Jackson2JsonpInterceptor
</code></pre>
           may be included on the classpath
           </li><li class="listitem">Also, the parameter parameter "resteasy.jsonp.enable" must be set to "true".
           [See <a class="xref" href="#microprofile_config" title="3.4. Configuration">Section 3.4, “Configuration”</a> for more information about application configuration.]
           </li></ol></div>
    </section>
    <section class="sect1" id="Jackson_JSON_Decorator"><div class="titlepage"><div><div><h2 class="title">24.7. Jackson JSON Decorator</h2></div></div></div>
        
        <p>
            If you are using the Jackson 2 provider, RESTEasy has provided a pretty-printing annotation simliar with the one in JAXB provider:
</p><pre><code class="no-highlight">
org.jboss.resteasy.annotations.providers.jackson.Formatted
</code></pre><p>
            Here is an example:
</p><pre><code class="no-highlight">
@GET
@Produces("application/json")
@Path("/formatted/{id}")
@Formatted
public Product getFormattedProduct()
{
    return new Product(333, "robot");
}
</code></pre><p>
            As the example shown above, the @Formatted annotation will enable the underlying Jackson option "SerializationFeature.INDENT_OUTPUT".
        </p>
    </section>

    <section class="sect1" id="JSON_Filter_Support"><div class="titlepage"><div><div><h2 class="title">24.8. JSON Filter Support</h2></div></div></div>
        
        <p>
            In Jackson2 , there is new feature <a class="ulink" href="http://wiki.fasterxml.com/JacksonFeatureJsonFilter">JsonFilter</a> to allow annotate class with @JsonFilter and doing dynamic filtering.
Here is an example which defines mapping from "nameFilter" to filter instances and filter bean properties when serilize to json format:
</p><pre><code class="no-highlight">
@JsonFilter(value="nameFilter")
public class Jackson2Product {
    protected String name;
    protected int id;
    public Jackson2Product() {
    }
    public Jackson2Product(final int id, final String name) {
        this.id = id;
        this.name = name;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
}
</code></pre><p>
@JsonFilter annotates resource class to filter out some property not to serialize in the json response. To map the filter id and instance we need to create another jackson class to add the id and filter instance map:
</p><pre><code class="no-highlight">

public class ObjectFilterModifier extends ObjectWriterModifier {
	public ObjectFilterModifier() {
	}
	@Override
	public ObjectWriter modify(EndpointConfigBase&lt;?&gt; endpoint,
			MultivaluedMap&lt;String, Object&gt; httpHeaders, Object valueToWrite,
			ObjectWriter w, JsonGenerator jg) throws IOException {

		FilterProvider filterProvider = new SimpleFilterProvider().addFilter(
				"nameFilter",
				SimpleBeanPropertyFilter.filterOutAllExcept("name"));
		return w.with(filterProvider);

	}
}

</code></pre><p>
       Here the method <code class="methodname">modify()</code> will take care of filtering all properties except "name" property before write. To make this work, we need let RESTEasy know this mapping info. This can be easily set in a WriterInterceptor using Jackson's <code class="methodname">ObjectWriterInjector</code>:
</p><pre><code class="no-highlight">

@Provider
public class JsonFilterWriteInterceptor implements WriterInterceptor{

	private ObjectFilterModifier modifier = new ObjectFilterModifier();
	@Override
	public void aroundWriteTo(WriterInterceptorContext context)
			throws IOException, WebApplicationException {
		//set a threadlocal modifier
	    ObjectWriterInjector.set(modifier);
		context.proceed();
	}

}

</code></pre><p>
Alternatively, Jackson's documentation suggest doing the same in a servlet filter; that however potentially leads to issues on RESTEasy, as the ObjectFilterModifier ends up being stored using a ThreadLocal object and there's no guarantee the same thread serving the servlet filter will be running the resource endpoint execution too. So, for the servlet filter scenario, RESTEasy offers its own injector that relies on the current thread context classloader for carrying over the specified modifier:
</p><pre><code class="no-highlight">

public class ObjectWriterModifierFilter implements Filter {
	private static ObjectFilterModifier modifier = new ObjectFilterModifier();

	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
	}

	@Override
	public void doFilter(ServletRequest request, ServletResponse response,
			FilterChain chain) throws IOException, ServletException {
		ResteasyObjectWriterInjector.set(Thread.currentThread().getContextClassLoader(), modifier);
		chain.doFilter(request, response);
	}

	@Override
	public void destroy() {
	}

}

</code></pre><p>
        </p>
    </section>

    <section class="sect1" id="Polymorphic_Typing_deserialization"><div class="titlepage"><div><div><h2 class="title">24.9. Polymorphic Typing deserialization</h2></div></div></div>
        
        <p>
           Due to numerous CVEs for a specific kind of Polymorphic Deserialization (see details in FasterXML Jackson documentation), starting from Jackson 2.10 users have a mean to allow only specified classes to be deserialized. RESTEasy enables this feature by default and allows controlling the contents of whitelist of allowed classes/packages using MicroProfile Config.

</p><div class="table" id="d5e1502"><div class="table-title">Table 24.1. </div><div class="table-contents">
                <table style="border-collapse: collapse;border-top: 1px solid ; border-bottom: 1px solid ; "><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 1px  ; border-bottom: 1px  ; ">
                                Property
                            </th><th style="border-right: 1px  ; border-bottom: 1px  ; ">
                                Description
                            </th><td style="border-bottom: 1px  ; " class="auto-generated"> </td></tr></thead><tbody><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                resteasy.jackson.deserialization.whitelist.allowIfBaseType
                            </td><td style="border-right: 1px  ; border-bottom: 1px  ; ">
                                Method for appending matcher that will allow all subtypes in cases where nominal base type's class name starts with specific prefix. "*" can be used for allowing any class.
                            </td><td style="border-bottom: 1px  ; " class="auto-generated"> </td></tr><tr><td style="border-right: 1px  ; ">
                                resteasy.jackson.deserialization.whitelist.allowIfSubType
                            </td><td style="border-right: 1px  ; ">
                                Method for appending matcher that will allow specific subtype (regardless of declared base type) in cases where subclass name starts with specified prefix. "*" can be used for allowing any class.
                            </td><td class="auto-generated"> </td></tr></tbody></table>
            </div></div><p><br class="table-break"/>
        </p>
    </section>

</section>

    <section class="chapter" id="json-p"><div class="titlepage"><div><div><h1 class="title">Chapter 25. JSON Support via Java EE 7 JSON-P API</h1></div></div></div>
    
    <p>No, this is not the JSONP you are thinking of!  JSON-P is a new Java EE 7 JSON parsing API.  Horrible name for
        a new JSON parsing API!  What were they thinking?  Anyways, RESTEasy has
        a provider for it.  If you are using WildFly, it is required by Java EE 7 so you will have it automatically bundled.
        Otherwise, use this maven dependency.
    </p>
    <pre><code class="no-highlight">
&lt;dependency&gt;
   &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
   &lt;artifactId&gt;resteasy-json-p-provider&lt;/artifactId&gt;
   &lt;version&gt;4.7.10.Final&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
    <p>
        It has built in support for JsonObject, JsonArray, and JsonStructure as request or response entities.  It should
        not conflict with Jackson if you have that in your path too.
    </p>
</section>

    <section class="chapter" id="Multipart"><div class="titlepage"><div><div><h1 class="title">Chapter 26. Multipart Providers</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="section"><a href="#multipart_mixed_group">26.1. Multipart/mixed</a></span><ul><li><span class="section"><a href="#multipart_output">26.1.1. Writing multipart/mixed messages</a></span></li><li><span class="section"><a href="#MultipartInput">26.1.2. Reading multipart/mixed messages</a></span></li><li><span class="section"><a href="#Simple_mulitpart_message_example">26.1.3. Simple multipart/mixed message example</a></span></li><li><span class="section"><a href="#message_with_GenericType_example">26.1.4. Multipart/mixed message with GenericType example</a></span></li><li><span class="section"><a href="#multipart_list_example">26.1.5. java.util.List with multipart/mixed data example</a></span></li></ul></li><li><span class="section"><a href="#multipart_related_group">26.2. Multipart/related</a></span><ul><li><span class="section"><a href="#Writing_multipart_related">26.2.1. Writing multipart/related messages</a></span></li><li><span class="section"><a href="#Reading_multipart_related">26.2.2. Reading multipart/related messages</a></span></li><li><span class="section"><a href="#multipart_related_example">26.2.3. Multipart/related message example</a></span></li><li><span class="section"><a href="#XML-binary_Optimized_Packaging">26.2.4. XML-binary Optimized Packaging (XOP)</a></span></li><li><span class="section"><a href="#XopWithMultipartRelated_return_object_example">26.2.5. @XopWithMultipartRelated return object example</a></span></li><li><span class="section"><a href="#XopWithMultipartRelated_input_parameter_example">26.2.6. @XopWithMultipartRelated input parameter example</a></span></li></ul></li><li><span class="section"><a href="#multipart_formData_group">26.3. Multipart/form-data</a></span><ul><li><span class="section"><a href="#Writing_multipart_formData">26.3.1. Writing multipart/form-data messages</a></span></li><li><span class="section"><a href="#Reading_multipart_formData">26.3.2. Reading multipart/form-data messages</a></span></li><li><span class="section"><a href="#simple_multipart_formData_example">26.3.3. Simple multipart/form-data message example</a></span></li><li><span class="section"><a href="#Map_with_multipart_formData">26.3.4. java.util.Map with multipart/form-data</a></span></li><li><span class="section"><a href="#Multipart_FormData_Output">26.3.5. Multipart/form-data java.util.Map as method return type</a></span></li><li><span class="section"><a href="#multipartform_annotation">26.3.6. @MultipartForm and POJOs</a></span></li></ul></li><li><span class="section"><a href="#multipart_parsing_note">26.4. Note about multipart parsing and working with other frameworks</a></span></li><li><span class="section"><a href="#multipart_overwrite_default_content_type">26.5. Overwriting the default fallback content type for multipart messages</a></span></li><li><span class="section"><a href="#multipart_overwrite_content_type">26.6. Overwriting the content type for multipart messages</a></span></li><li><span class="section"><a href="#multipart_overwrite_default_charset">26.7. Overwriting the default fallback charset for multipart messages</a></span></li></ul></div>
    
    <p>RESTEasy has rich support for the "multipart/*" and "multipart/form-data" mime types.
        The multipart mime
        format is used to pass lists of content bodies. Multiple content bodies are embedded
        in one message.
        "multipart/form-data" is often found in web application HTML Form documents and is generally
        used to
        upload files. The form-data format is the same as other multipart formats, except that
        each inlined piece
        of content has a name associated with it.
    </p>
    <p>RESTEasy provides
        a custom API for reading and writing multipart types as well as marshalling arbitrary List
       (for any multipart type) and Map (multipart/form-data only) objects
    </p>
    <p>Classes <code class="code">MultipartInput</code> and <code class="code">MultipartOutput</code> provides read and write
        support for mime type "multipart/mixed" messages respectively.  They provide for
        multiple part messages, in which one or more different sets of data are combined in a single body.
    </p>
    <p><code class="code">MultipartRelatedInput</code> and <code class="code">MultipartRelatedOutput</code> classes
        provide read and write
        support for mime type "multipart/related" messages.  These are messages that contain
        multiple body parts that are inter-related.
    </p>
    <p><code class="code">MultipartFormDataInput</code> and <code class="code">MultipartFormDataOutput</code> classes
        provide read and write
        support for mine type "multipart/form-data".  This type is used when returning
        a set of values as the the result of a user filling out a form or for uploading files.
    </p>

   <section class="section" id="multipart_mixed_group"><div class="titlepage"><div><div><h2 class="title">26.1. Multipart/mixed</h2></div></div></div>
      

   <section class="section" id="multipart_output"><div class="titlepage"><div><div><h3 class="title">26.1.1. Writing multipart/mixed messages</h3></div></div></div>
      

      <p><code class="code">MultipartOutput</code> provides a set of addPart methods for
         registering message content
         and specifying special marshalling requirements.  In all cases the addPart
         methods require
         an input parameter, Object and a MediaType that declares the mime type of the object.
         Sometimes you may have an object in which marshalling is sensitive to generic type metadata.
         In such cases, use an addPart method in which you declare the GenericType of the entity Object.
         Perhaps a file will be passed as content and it will require UTF-8 encoding.
         Setting input parameter, utf8Encode to <code class="code">true</code> will indicate to RESTEasy to process the
         filename according to the character set and language encoding rules of <code class="code">rfc5987</code>.
         This flag is only processed when mime type "multipart/form-data" is specified.
      </p>
      <p><code class="code">MultipartOutput</code> automatically generates a unique message boundary identifier
         when it is created.  Method setBoundary is provided in case you wish to declare
         a different identifier.
      </p>
      <pre><code class="no-highlight">
public class MultipartOutput
{
   public OutputPart addPart(Object entity, MediaType mediaType);
   public OutputPart addPart(Object entity, MediaType mediaType,
        String filename);
   public OutputPart addPart(Object entity, MediaType mediaType,
        String filename, boolean utf8Encode);
   public OutputPart addPart(Object entity, GenericType&lt;?&gt; type,
        MediaType mediaType);
   public OutputPart addPart(Object entity, GenericType&lt;?&gt; type,
        MediaType mediaType, String filename);
   public OutputPart addPart(Object entity, GenericType&lt;?&gt; type,
        MediaType mediaType, String filename, boolean utf8Encode);
   public OutputPart addPart(Object entity, Class&lt;?&gt; type, Type genericType,
        MediaType mediaType);
   public OutputPart addPart(Object entity, Class&lt;?&gt; type, Type genericType,
        MediaType mediaType, String filename);
   public OutputPart addPart(Object entity, Class&lt;?&gt; type, Type genericType,
        MediaType mediaType, String filename, boolean utf8Encode);
   public List&lt;OutputPart&gt; getParts();
   public String getBoundary();
   public void setBoundary(String boundary);
}</code></pre>

      <p>Each message part registered with <code class="code">MultipartOutput</code> is represented by an
      <code class="code">OutputPart</code> object.  Class <code class="code">MultipartOutput</code> generates an
      <code class="code">OutputPart</code> object for each addPart method call.
      </p>
      <pre><code class="no-highlight">
public class OutputPart {
   public OutputPart(final Object entity, final Class&lt;?&gt; type,
        final Type genericType, final MediaType mediaType);
   public OutputPart(final Object entity, final Class&lt;?&gt; type,
        final Type genericType, final MediaType mediaType,
        final String filename);
   public OutputPart(final Object entity, final Class&lt;?&gt; type,
        final Type genericType, final MediaType mediaType,
        final String filename, final boolean utf8Encode);
   public MultivaluedMap&lt;String, Object&gt; getHeaders();
   public Object getEntity();
   public Class&lt;?&gt; getType();
   public Type getGenericType();
   public MediaType getMediaType();
   public String getFilename();
   public boolean isUtf8Encode();
}</code></pre>
   </section>

      <section class="section" id="MultipartInput"><div class="titlepage"><div><div><h3 class="title">26.1.2. Reading multipart/mixed messages</h3></div></div></div>
         
         <p><code class="code">MultipartInput</code> and <code class="code">InputPart</code> are interface
            classes that provide
            access to multipart/mixed message data.  RESTEasy provides an implementation
            of these classes.  They perform the work to retrieve message data.
         </p>
         <pre><code class="no-highlight">

package org.jboss.resteasy.plugins.providers.multipart;

import java.util.List;

public interface MultipartInput {
   List&lt;InputPart&gt; getParts();
   String getPreamble();
   /**
    * Call this method to delete any temporary files created from unmarshalling
    * this multipart message
    * Otherwise they will be deleted on Garbage Collection or JVM exit.
    */
   void close();
}</code></pre>


    <pre><code class="no-highlight">

package org.jboss.resteasy.plugins.providers.multipart;

import javax.ws.rs.core.GenericType;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.MultivaluedMap;
import java.io.IOException;
import java.lang.reflect.Type;

/**
 * Represents one part of a multipart message.
 */
public interface InputPart {
   /**
    * If no content-type header is sent in a multipart message part
    * "text/plain; charset=ISO-8859-1" is assumed.
    *
    * This can be overwritten by setting a different String value in
    * {@link org.jboss.resteasy.spi.HttpRequest#setAttribute(String, Object)}
    * with this ("resteasy.provider.multipart.inputpart.defaultContentType")
    * String as key. It should be done in a
    * {@link javax.ws.rs.container.ContainerRequestFilter}.
    */
   String DEFAULT_CONTENT_TYPE_PROPERTY =
    "resteasy.provider.multipart.inputpart.defaultContentType";

   /**
    * If there is a content-type header without a charset parameter,
    * charset=US-ASCII is assumed.
    *
    * This can be overwritten by setting a different String value in
    * {@link org.jboss.resteasy.spi.HttpRequest#setAttribute(String, Object)}
    * with this ("resteasy.provider.multipart.inputpart.defaultCharset")
    * String as key. It should be done in a
    * {@link javax.ws.rs.container.ContainerRequestFilter}.
    */
   String DEFAULT_CHARSET_PROPERTY =
    "resteasy.provider.multipart.inputpart.defaultCharset";

   /**
    * @return headers of this part
    */
   MultivaluedMap&lt;String, String&gt; getHeaders();
   String getBodyAsString() throws IOException;
   &lt;T&gt; T getBody(Class&lt;T&gt; type, Type genericType) throws IOException;
   &lt;T&gt; T getBody(GenericType&lt;T&gt; type) throws IOException;

   /**
    * @return "Content-Type" of this part
    */
   MediaType getMediaType();

   /**
    * @return true if the Content-Type was resolved from the message, false if
    *         it was resolved from the server default
    */
   boolean isContentTypeFromMessage();

   /**
    * Change the media type of the body part before you extract it.
    * Useful for specifying a charset.
    * @param mediaType media type
    */
   void setMediaType(MediaType mediaType);
}}</code></pre>

      </section>

      <section class="section" id="Simple_mulitpart_message_example"><div class="titlepage"><div><div><h3 class="title">26.1.3. Simple multipart/mixed message example</h3></div></div></div>
         
      <p>The following example shows how to read and write a simple multipart/mixed
         message.
      </p>
      <p>The data to be transfered is a very simple class, Soup.
      </p>
      <pre><code class="no-highlight">

package org.jboss.resteasy.test.providers.multipart.resource;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;

@XmlRootElement(name = "soup")
@XmlAccessorType(XmlAccessType.FIELD)
public class Soup {
    @XmlElement
    private String id;

    public Soup(){}
    public Soup(final String id){this.id = id;}
    public String getId(){return id;}
}
</code></pre>


         <p>This code fragment creates a multipart/mixed message passing
            Soup information using class, <code class="code">MultipartOutput</code>.
         </p>
         <pre><code class="no-highlight">
 
      MultipartOutput multipartOutput = new MultipartOutput();
      multipartOutput.addPart(new Soup("Chicken Noodle"),
            MediaType.APPLICATION_XML_TYPE);
      multipartOutput.addPart(new Soup("Vegetable"),
            MediaType.APPLICATION_XML_TYPE);
      multipartOutput.addPart("Granny's Soups", MediaType.TEXT_PLAIN_TYPE);
 </code></pre>

         <p>This code fragment uses class <code class="code">MultipartInput</code>
            to extract the Soup information provided by multipartOutput
            above.
         </p>
         <pre><code class="no-highlight">
            
      // MultipartInput multipartInput, the entity returned in the client in a
      // Response object or the input value of an endpoint method parameter.
      for (InputPart inputPart : multipartInput.getParts()) {
          if (MediaType.APPLICATION_XML_TYPE.equals(inputPart.getMediaType())) {
              Soup c = inputPart.getBody(Soup.class, null);
              String name = c.getId();
          } else {
              String s = inputPart.getBody(String.class, null);
          }
      }
 </code></pre>

         <p>Returning a multipart/mixed message from an endpoint can be done
            in two ways.  <code class="code">MultipartOutput</code> can be returned as the method's
            return object or as an entity in a <code class="code">Response</code> object.
         </p>
    <pre><code class="no-highlight">

    @GET
    @Path("soups/obj")
    @Produces("multipart/mixed")
    public MultipartOutput soupsObj() {
        return multipartOutput;
    }

    @GET
    @Path("soups/resp")
    @Produces("multipart/mixed")
    public Response soupsResp() {
      return Response.ok(multipartOutput, MediaType.valueOf("multipart/mixed"))
                     .build();
    }
</code></pre>

      <p>There is no difference in the way a client retrieves the message
         from the endpoint.  It is done as follows.
      </p>
         <pre><code class="no-highlight">
            
      ResteasyClient client = (ResteasyClient)ClientBuilder.newClient();
      ResteasyWebTarget target = client.target(THE_URL);
      Response response = target.request().get();
      MultipartInput multipartInput = response.readEntity(MultipartInput.class);

      for (InputPart inputPart : multipartInput.getParts()) {
          if (MediaType.APPLICATION_XML_TYPE.equals(inputPart.getMediaType())) {
              Soup c = inputPart.getBody(Soup.class, null);
              String name = c.getId();
          } else {
              String s = inputPart.getBody(String.class, null);
          }
      }

      client.close();
 </code></pre>


      <p>
         A client sends the message, multipartOutput, to an endpoint
         as an entity object in an HTTP method call in this code fragment.
      </p>
         <pre><code class="no-highlight">

        ResteasyClient client = (ResteasyClient)ClientBuilder.newClient();
        ResteasyWebTarget target = client.target(SOME_URL + "/register/soups");
        Entity&lt;MultipartOutput&gt; entity = Entity.entity(multipartOutput,
                new MediaType("multipart", "mixed"));
        Response response = target.request().post(entity);
 </code></pre>

   <p>Here is the endpoint receiving the message and extracting the contents.
   </p>
   <pre><code class="no-highlight">
       
 @POST
 @Consumes("multipart/mixed")
 @Path("register/soups")
  public void registerSoups(MultipartInput multipartInput) throws IOException {

      for (InputPart inputPart : multipartInput.getParts()) {
         if (MediaType.APPLICATION_XML_TYPE.equals(inputPart.getMediaType())) {
                Soup c = inputPart.getBody(Soup.class, null);
                String name = c.getId();
         } else {
                String s = inputPart.getBody(String.class, null);
         }
      }
  }
 </code></pre>

      </section>

      <section class="section" id="message_with_GenericType_example"><div class="titlepage"><div><div><h3 class="title">26.1.4. Multipart/mixed message with GenericType example</h3></div></div></div>
         
         <p>This example shows how to read and write a multipart/mixed message
            whose content consists of a generic type, in this case a List&lt;Soup&gt;.
            The <code class="code">MultipartOutput</code> and <code class="code">MultipartIntput</code> methods
            that use <code class="code">GenericType</code> parameters are used.
         </p>
         <p>The multipart/mixed message is created using <code class="code">MultipartOutput</code>
            as follows.
         </p>
         <pre><code class="no-highlight">
            
        MultipartOutput multipartOutput = new MultipartOutput();
        List&lt;Soup&gt; soupList = new ArrayList&lt;Soup&gt;();
        soupList.add(new Soup("Chicken Noodle"));
        soupList.add(new Soup("Vegetable"));
        multipartOutput.addPart(soupList, new GenericType&lt;List&lt;Soup&gt;&gt;(){},
               MediaType.APPLICATION_XML_TYPE );
        multipartOutput.addPart("Granny's Soups", MediaType.TEXT_PLAIN_TYPE);
 </code></pre>
         <p>The message data is extracted with <code class="code">MultipartInput</code>.
            Note there are two <code class="code">MultipartInput</code> getBody methods that
            can be used to retrieve data specifying <code class="code">GenericType</code>.
            This code fragment uses the second one but shows the first one in comments.
         </p>
         <pre><code class="no-highlight">
            
   &lt;T&gt; T getBody(Class&lt;T&gt; type, Type genericType) throws IOException;
   &lt;T&gt; T getBody(GenericType&lt;T&gt; type) throws IOException;
 </code></pre>
         <pre><code class="no-highlight">
            
   // MultipartInput multipartInput, the entity returned in the client in a
   // Response object or the input value of an endpoint method parameter.
   GenericType&lt;List&lt;Soup&gt;&gt; gType = new GenericType&lt;List&lt;Soup&gt;&gt;(){};

   for (InputPart inputPart : multipartInput.getParts()) {
      if (MediaType.APPLICATION_XML_TYPE.equals(inputPart.getMediaType())) {
         List&lt;Soup&gt; c = inputPart.getBody(gType);
      // List&lt;Soup&gt; c = inputPart.getBody(gType.getRawType(), gType.getType());
      } else {
         String s = inputPart.getBody(String.class, null);;
      }
   }
 </code></pre>

      </section>

      <section class="section" id="multipart_list_example"><div class="titlepage"><div><div><h3 class="title">26.1.5. java.util.List with multipart/mixed data example</h3></div></div></div>
         

         <p>When a set of message parts are uniform they do not need to be
            written using <code class="code">MultipartOutput</code> or read with
            <code class="code">MultipartInput</code>.  They can be sent and received as a
            <code class="code">List</code>.
            RESTEasy performs the necessary work to read and write the message data.
         </p>
   <p>For this example the data to be transmitted is class,
      <code class="code">ContextProvidersCustomer</code>
   </p>
         <pre><code class="no-highlight">
            
    package org.jboss.resteasy.test.providers.multipart.resource;

    import javax.xml.bind.annotation.XmlAccessType;
    import javax.xml.bind.annotation.XmlAccessorType;
    import javax.xml.bind.annotation.XmlElement;
    import javax.xml.bind.annotation.XmlRootElement;

    @XmlRootElement(name = "customer")
    @XmlAccessorType(XmlAccessType.FIELD)
    public class ContextProvidersCustomer {
       @XmlElement
       private String name;

       public ContextProvidersCustomer() { }
       public ContextProvidersCustomer(final String name) {
          this.name = name;
      }
       public String getName() { return name;}
    }
 </code></pre>

         <p>In this code fragment the client creates and sends of list
            <code class="code">ContextProvidersCustomers</code>.
         </p>
         <pre><code class="no-highlight">
            
      List&lt;ContextProvidersCustomer&gt; customers =
            new ArrayList&lt;ContextProvidersCustomer&gt;();
      customers.add(new ContextProvidersCustomer("Bill"));
      customers.add(new ContextProvidersCustomer("Bob"));

      Entity&lt;ContextProvidersCustomer&gt; entity = Entity.entity(customers,
        new MediaType("multipart", "mixed"));

      Client client = ClientBuilder.newClient();
      WebTarget target = client.target(SOME_URL);
      Response response = target.request().post(entity);
 </code></pre>

    <p>The endpoint receives the list, alters the contents and returns a new list.
    </p>
         <pre><code class="no-highlight">
            
   @POST
   @Consumes("multipart/mixed")
   @Produces(MediaType.APPLICATION_XML)
   @Path("post/list")
   public List&lt;ContextProvidersName&gt; postList(
         List&lt;ContextProvidersCustomer&gt; customers) throws IOException {

      List&lt;ContextProvidersName&gt; names = new ArrayList&lt;ContextProvidersName&gt;();

      for (ContextProvidersCustomer customer : customers) {
         names.add(new ContextProvidersName("Hello " + customer.getName()));
      }
      return names;
   }
 </code></pre>

         <p>The client receives the altered message data and processes it.
         </p>
         <pre><code class="no-highlight">
            
    Response response = target.request().post(entity);
    List&lt;ContextProvidersCustomer&gt; rtnList =
      response.readEntity(new GenericType&lt;List&lt;ContextProvidersCustomer&gt;&gt;(){});
        :
        :
 </code></pre>

      </section>
   </section>



   <section class="section" id="multipart_related_group"><div class="titlepage"><div><div><h2 class="title">26.2. Multipart/related</h2></div></div></div>
      
      <p>The Multipart/Related mime type is intended for compound objects
         consisting of several inter-related body parts, (RFC2387).  There is a root or
         start part.  All other parts are referenced from the root part.  Each
         part has a unique id.  The type and the id of the start part is presented
         in parameters in the message content-type header.
      </p>

   <section class="section" id="Writing_multipart_related"><div class="titlepage"><div><div><h3 class="title">26.2.1. Writing multipart/related messages</h3></div></div></div>
      

      <p>RESTEasy provides class <code class="code">MultipartRelatedOutput</code> to assist
         the user in specifying the required information and generating a properly
         formatted message.  <code class="code">MultipartRelatedOutput</code> is a subclass of
         <code class="code">MultipartOutput</code>.
      </p>
      <pre><code class="no-highlight">
         
package org.jboss.resteasy.plugins.providers.multipart;

import javax.ws.rs.core.MediaType;

public class MultipartRelatedOutput extends MultipartOutput {
   private String startInfo;

   /**
    * The part used as the root.
    */
   public OutputPart getRootPart();

   /**
    * entity  object representing the part's body
    * mediaType Content-Type of the part
    * contentId  Content-ID to be used as identification for the current
    *            part, optional, if null one will be generated
    * contentTransferEncoding
    *            value used for the Content-Transfer-Encoding header
    *            field of the part. It's optional, if you don't want to set
    *            this pass null. Example values are: "7bit",
    *            "quoted-printable", "base64", "8bit", "binary"
    */
   public OutputPart addPart(Object entity, MediaType mediaType,
         String contentId, String contentTransferEncoding);

   /**
    * start-info parameter of the Content-Type.  An optional parameter.
    * As described in RFC2387, section 3.3. The Start-Info Parameter
    */
   public String getStartInfo();
}
 </code></pre>

   </section>

   <section class="section" id="Reading_multipart_related"><div class="titlepage"><div><div><h3 class="title">26.2.2. Reading multipart/related messages</h3></div></div></div>
      
      <p><code class="code">MultipartRelatedInput</code> is an interface class that provides
         access to multipart/related message data.  It is a subclass of
         <code class="code">MultipartInput</code>.  RESTEasy provides an implementation of
         this class. It performs the work to retrieve message data.
      </p>
      <pre><code class="no-highlight">
         
package org.jboss.resteasy.plugins.providers.multipart;

import javax.ws.rs.core.MediaType;

public class MultipartRelatedOutput extends MultipartOutput {
   private String startInfo;

   /**
    * The part used as the root.
    */
   public OutputPart getRootPart();

   /**
    * entity  object representing the part's body
    * mediaType Content-Type of the part
    * contentId  Content-ID to be used as identification for the current
    *            part, optional, if null one will be generated
    * contentTransferEncoding
    *            value used for the Content-Transfer-Encoding header
    *            field of the part. It's optional, if you don't want to set
    *            this pass null. Example values are: "7bit",
    *            "quoted-printable", "base64", "8bit", "binary"
    */
   public OutputPart addPart(Object entity, MediaType mediaType,
         String contentId, String contentTransferEncoding);

   /**
    * start-info parameter of the Content-Type.  An optional parameter.
    * As described in RFC2387, section 3.3. The Start-Info Parameter
    */
   public String getStartInfo();
}
 </code></pre>
   </section>

   <section class="section" id="multipart_related_example"><div class="titlepage"><div><div><h3 class="title">26.2.3. Multipart/related message example</h3></div></div></div>
      
   <p>The client in this example creates a multipart/related message,
      POSTs it to the endpoint and processes the multipart/related message
      returned by the endpoint.
   </p>
      <pre><code class="no-highlight">
         
MultipartRelatedOutput mRelatedOutput = new MultipartRelatedOutput();
mRelatedOutput.setStartInfo("text/html");
mRelatedOutput.addPart("Bill", new MediaType("image", "png"), "bill", "binary");
mRelatedOutput.addPart("Bob", new MediaType("image", "png"), "bob", "binary");

Entity&lt;MultipartRelatedOutput&gt; entity = Entity.entity(mRelatedOutput,
    new MediaType("multipart", "related"));

Client client = ClientBuilder.newClient();
WebTarget target = client.target(SOME_URL);
Response response = target.request().post(entity);

MultipartRelatedInput result = response.readEntity(
      MultipartRelatedInput.class);
Map&lt;String, InputPart&gt; map = result.getRelatedMap();
Set&lt;String&gt; keys = map.keySet();
boolean a = keys.contains("Bill");
boolean b = keys.contains("Bob");
for (InputPart inputPart : map.values()) {
    String alterName = inputPart.getBody(String.class, null);
}
 </code></pre>
      <p>Here is the endpoint the client above is calling.
      </p>

      <pre><code class="no-highlight">
         
@POST
@Consumes("multipart/related")
@Produces("multipart/related")
@Path("post/related")
public MultipartRelatedOutput postRelated(MultipartRelatedInput input)
        throws IOException {

  MultipartRelatedOutput rtnMRelatedOutput = new MultipartRelatedOutput();
        rtnMRelatedOutput.setStartInfo("text/html");

  for (Iterator&lt;InputPart&gt; it = input.getParts().iterator(); it.hasNext(); ) {
      InputPart part = it.next();
      String name = part.getBody(String.class, null);
      rtnMRelatedOutput.addPart("Hello " + name,
                    new MediaType("image", "png"), name, null);
  }
  return rtnMRelatedOutput;
}
 </code></pre>

   </section>

      <section class="section" id="XML-binary_Optimized_Packaging"><div class="titlepage"><div><div><h3 class="title">26.2.4. XML-binary Optimized Packaging (XOP)</h3></div></div></div>
         
         <p>RESTEasy supports XOP messages packaged as multipart/related messages
            (<a class="link" href="#">http://www.w3.org/TR/xop10/</a>).
            A JAXB annotated POJO that also holds binary content can be transmitted using XOP.
            XOP allows the binary data to skip going through the XML serializer because
            binary data can be serialized differently from text and this can result in faster
            transport time.
         </p>
         <p>RESTEasy requires annotation @XopWithMultipartRelated to be placed on any
            endpoint method that returns an object that is to be to be processed with XOP
            and on any endpoint input parameter that is to be processed by XOP.
         </p>
         <p>RESTEasy highly recommends, if you know the exact mime type of the POJO's
            binary data, tag the field with annotation @XmlMimeType.  This annotation tells
            JAXB the mime type of the binary content, however this is not required in order
            to do XOP packaging.
         </p>
      </section>

      <section class="section" id="XopWithMultipartRelated_return_object_example"><div class="titlepage"><div><div><h3 class="title">26.2.5. @XopWithMultipartRelated return object example</h3></div></div></div>
         

         <p>The data to be transmitted is class, <code class="code">ContextProvidersXop</code>.
            Note that field <code class="code">bytes</code> is identified as an application/octet-stream
            mime type using annotation @XmlMimeType
         </p>

         <pre><code class="no-highlight">
            
package org.jboss.resteasy.test.providers.multipart.resource;

import javax.ws.rs.core.MediaType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlMimeType;
import javax.xml.bind.annotation.XmlRootElement;

@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public class ContextProvidersXop {

   @XmlMimeType(MediaType.APPLICATION_OCTET_STREAM)
   private byte[] bytes;

   public ContextProvidersXop(final byte[] bytes) {
      this.bytes = bytes;
   }

   public ContextProvidersXop() {}
   public byte[] getBytes() {return bytes;}
   public void setBytes(byte[] bytes) {this.bytes = bytes;}
}
 </code></pre>

         <p>The endpoint returns an instance of <code class="code">ContextProvidersXop</code>.
            Note annotation @XopWithMultipartRelated declared on the method because
            we want the return object to use XOP packaging.
         </p>

         <pre><code class="no-highlight">
            
   @GET
   @Path("get/xop")
   @Produces("multipart/related")
   @XopWithMultipartRelated
   public ContextProvidersXop getXop() {
      return new ContextProvidersXop("goodbye world".getBytes());
   }
 </code></pre>

         <p>The client retreives the data as follows
         </p>
         <pre><code class="no-highlight">
            
Client client = ClientBuilder.newClient();
WebTarget target = client.target(SOME_URL);
Response response = target.request().get();
ContextProvidersXo entity = response.readEntity(ContextProvidersXop.class);
client.close();
 </code></pre>

      </section>

      <section class="section" id="XopWithMultipartRelated_input_parameter_example"><div class="titlepage"><div><div><h3 class="title">26.2.6. @XopWithMultipartRelated input parameter example</h3></div></div></div>
         
         <p>Here is an endpoint that has an input parameter that is
            transmitted as an XOP package.  Note the @XopWithMultipartRelated
            annotation on input parameter xop.
         </p>
         <pre><code class="no-highlight">
            
   @POST
   @Path("post/xop")
   @Consumes("multipart/related")
   public String postXop(@XopWithMultipartRelated ContextProvidersXop xop) {
      return new String(xop.getBytes());
   }
 </code></pre>

         <p>This client is sending the data to the endpoint above.</p>
         <pre><code class="no-highlight">
            
ContextProvidersXop xop = new ContextProvidersXop("hello world".getBytes());
Entity&lt;ContextProvidersXop&gt; entity = Entity.entity(xop,
    new MediaType("multipart", "related"));

Client client = ClientBuilder.newClient();
WebTarget target = client.target(SOME_URL);
Response response = target.request().post(entity);
 </code></pre>

      </section>


</section>




   <section class="section" id="multipart_formData_group"><div class="titlepage"><div><div><h2 class="title">26.3. Multipart/form-data</h2></div></div></div>
      
      <p>The MultiPart/Form-Data mime type is used in sending form data (rfc2388).
         It can include data generated by user input, information that is typed, or
         included from files that the user has selected.  "multipart/form-data" is
         often found in web application HTML Form documents and is generally used
         to upload files. The form-data format is the same as other multi-part formats,
         except that each inlined piece of content has a name associated with it.
      </p>


   <section class="section" id="Writing_multipart_formData"><div class="titlepage"><div><div><h3 class="title">26.3.1. Writing multipart/form-data messages</h3></div></div></div>
      

      <p>Form data consists of key/value pairs.  RESTEasy provides class
         <code class="code">MultipartFormDataOutput</code> to assist the user in specifying
         the required information and generating a properly formatted message.
         It is a subclass of <code class="code">MultipartOutput</code>.  And as with
         multipart/mixed data sometimes there may be marshalling which is
         sensitive to generic type metadata, in those cases use the methods
         containing input parameter GenericType.
      </p>

      <pre><code class="no-highlight">
         
package org.jboss.resteasy.plugins.providers.multipart;

public class MultipartFormDataOutput extends MultipartOutput
{
    public OutputPart addFormData(String key, Object entity,
            MediaType mediaType)
    public OutputPart addFormData(String key, Object entity, GenericType type,
            MediaType mediaType)
    public OutputPart addFormData(String key, Object entity, Class type,
            Type genericType, MediaType mediaType)
    public Map&lt;String, OutputPart&gt; getFormData()
    public Map&lt;String, List&lt;OutputPart&gt;&gt; getFormDataMap()
}
</code></pre>
   </section>


   <section class="section" id="Reading_multipart_formData"><div class="titlepage"><div><div><h3 class="title">26.3.2. Reading multipart/form-data messages</h3></div></div></div>
      
      <p><code class="code">MultipartFormDataInput</code> is an interface class that
         provides access to multipart/form-data message data. It is a subclass
         of <code class="code">MultipartInput</code>. RESTEasy provides an implementation
         of this class. It performs the work to retrieve message data.
      </p>
      <pre><code class="no-highlight">
         
package org.jboss.resteasy.plugins.providers.multipart;

import java.io.IOException;
import java.lang.reflect.Type;
import java.util.List;
import java.util.Map;

import javax.ws.rs.core.GenericType;

public interface MultipartFormDataInput extends MultipartInput {
   /**
    * @return A parameter map containing a list of values per name.
    */
   Map&lt;String, List&lt;InputPart&gt;&gt; getFormDataMap();
   &lt;T&gt; T getFormDataPart(String key, Class&lt;T&gt; rawType, Type genericType)
         throws IOException;
   &lt;T&gt; T getFormDataPart(String key, GenericType&lt;T&gt; type) throws IOException;
}</code></pre>
   </section>


   <section class="section" id="simple_multipart_formData_example"><div class="titlepage"><div><div><h3 class="title">26.3.3. Simple multipart/form-data message example</h3></div></div></div>
      
      <p>The following example show how to read and write a simple
         multipart/form-data message.
      </p>
      <p>The multipart/mixed message is created on the clientside using the
         <code class="code">MultipartFormDataOutput</code> object.  One piece of form data
         to be transfered is a very simple class, <code class="code">ContextProvidersName</code>.
      </p>
      <pre><code class="no-highlight">
         
package org.jboss.resteasy.test.providers.multipart.resource;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;

@XmlRootElement(name = "name")
@XmlAccessorType(XmlAccessType.FIELD)
public class ContextProvidersName {
   @XmlElement
   private String name;

   public ContextProvidersName() {}
   public ContextProvidersName(final String name) {this.name = name;}
   public String getName() {return name;}
}
 </code></pre>
     <p>The client creates and sends the message as follows:
     </p>
      <pre><code class="no-highlight">
         
      MultipartFormDataOutput output = new MultipartFormDataOutput();
      output.addFormData("bill", new ContextProvidersCustomer("Bill"),
         MediaType.APPLICATION_XML_TYPE);
      output.addFormData("bob", "Bob", MediaType.TEXT_PLAIN_TYPE);

      Entity&lt;MultipartFormDataOutput&gt; entity = Entity.entity(output,
          new MediaType("multipart", "related"));

      Client client = ClientBuilder.newClient();
      WebTarget target = client.target(SOME_URL);
      Response response = target.request().post(entity);
 </code></pre>

      <p>The endpoint receives the message and processes it.
      </p>
      <pre><code class="no-highlight">
         
   @POST
   @Consumes("multipart/form-data")
   @Produces(MediaType.APPLICATION_XML)
   @Path("post/form")
   public Response postForm(MultipartFormDataInput input)
         throws IOException {

      Map&lt;String, List&lt;InputPart&gt;&gt; map = input.getFormDataMap();
      List&lt;ContextProvidersName&gt; names = new ArrayList&lt;ContextProvidersName&gt;();

      for (Iterator&lt;String&gt; it = map.keySet().iterator(); it.hasNext(); ) {
         String key = it.next();
         InputPart inputPart = map.get(key).iterator().next();
         if (MediaType.APPLICATION_XML_TYPE.equals(inputPart.getMediaType())) {
            names.add(new ContextProvidersName(inputPart.getBody(
                  ContextProvidersCustomer.class, null).getName()));
         } else {
            names.add(new ContextProvidersName(inputPart.getBody(
                  String.class, null)));
         }
      }
      return Response.ok().build();
   }
 </code></pre>


   </section>


      <section class="section" id="Map_with_multipart_formData"><div class="titlepage"><div><div><h3 class="title">26.3.4. java.util.Map with multipart/form-data</h3></div></div></div>
         
         <p>When the data of a multipart/form-data message is uniform it
            does not need to be written in a <code class="code">MultipartFormDataOutput</code>
            object.  It can be sent and received as a <code class="code">java.util.Map</code>
            object.  RESTEasy performs the necessary work to read and write the
            message data, however the Map object must declare the type it
            is unmarshalling via the generic parameters in the Map type declaration.
         </p>
      <p>Here is an example of a client creating and sending a multipart/form-data
         message.
      </p>
         <pre><code class="no-highlight">
            
      Map&lt;String, ContextProvidersCustomer&gt; customers =
              new HashMap&lt;String, ContextProvidersCustomer&gt;();
      customers.put("bill", new ContextProvidersCustomer("Bill"));
      customers.put("bob", new ContextProvidersCustomer("Bob"));

      Entity&lt;Map&lt;String, ContextProvidersCustomer&gt;&gt; entity =
        Entity.entity(customers, new MediaType("multipart", "form-data"));

      Client client = ClientBuilder.newClient();
      WebTarget target = client.target(SOME_URL);
      Response response = target.request().post(entity)
 </code></pre>

   <p>This is the endpoint the client above is calling.  It receives
      the message and processes it.
   </p>

         <pre><code class="no-highlight">
            
 @POST
 @Consumes("multipart/form-data")
 @Produces(MediaType.APPLICATION_XML)
 @Path("post/map")
 public Response postMap(Map&lt;String, ContextProvidersCustomer&gt; customers)
         throws IOException {

   List&lt;ContextProvidersName&gt; names = new ArrayList&lt;ContextProvidersName&gt;();
   for (Iterator&lt;String&gt; it = customers.keySet().iterator(); it.hasNext(); ) {
       String key = it.next();
       ContextProvidersCustomer customer = customers.get(key);
       names.add(new ContextProvidersName(key + ":" + customer.getName()));
   }
   return Response.ok().build();
 }
 </code></pre>

      </section>



      <section class="section" id="Multipart_FormData_Output"><div class="titlepage"><div><div><h3 class="title">26.3.5. Multipart/form-data java.util.Map as method return type</h3></div></div></div>
         
         <p>A <code class="code">java.util.Map</code> object representing a multipart/form-data
            message can be returned from an endpoint as long as the message data
            is uniform,  however the endpoint method MUST be annotated with
            @PartType which declares the media type of the Map entries and the
            Map object must declare the type it is unmarshalling via the generic
            parameters in the Map type declaration.  RESTEasy requires this
            information so it can generate the message properly.</p>

      <p>Here is an example of an endpoint returning a Map of
         <code class="code">ContextProvidersCustomer</code> to the client.
      </p>
         <pre><code class="no-highlight">
            
   @GET
   @Produces("multipart/form-data")
   @PartType("application/xml")
   @Path("get/map")
   public Map&lt;String, ContextProvidersCustomer&gt; getMap() {

      Map&lt;String, ContextProvidersCustomer&gt; map =
          new HashMap&lt;String, ContextProvidersCustomer&gt;();
      map.put("bill", new ContextProvidersCustomer("Bill"));
      map.put("bob", new ContextProvidersCustomer("Bob"));
      return map;
   }
 </code></pre>

         <p>The client would retrieve the data as follows.</p>
         <pre><code class="no-highlight">
            
      Client client = ClientBuilder.newClient();
      WebTarget target = client.target(SOME_URL);
      Response response = target.request().get();
      MultipartFormDataInput entity = response.readEntity(
            MultipartFormDataInput.class);
      client.close();

      ContextProvidersCustomer bill = entity.getFormDataPart("bill",
            ContextProvidersCustomer.class, null);
      ContextProvidersCustomer bob = entity.getFormDataPart("bob",
            ContextProvidersCustomer.class, null);
 </code></pre>

      </section>



      <section class="section" id="multipartform_annotation"><div class="titlepage"><div><div><h3 class="title">26.3.6. @MultipartForm and POJOs</h3></div></div></div>
         
         <p>If you have an exact knowledge of your multipart/form-data packets,
            you can map them to and from a POJO class using the annotation
            <code class="code">@org.jboss.resteasy.annotations.providers.multipart.MultipartForm</code>
            and the JAX-RS <code class="code">@FormParam</code> annotation. Simply define a POJO with
            at least a default constructor and annotate its fields and/or properties
            with <code class="code">@FormParams</code>. These <code class="code">@FormParams</code> must
            also be annotated with
            <code class="code">@org.jboss.resteasy.annotations.providers.multipart.PartType</code>
            if you are doing output. For example:
         </p>
         <pre><code class="no-highlight">
            public class CustomerProblemForm {
    @FormParam("customer")
    @PartType("application/xml")
    private Customer customer;

    @FormParam("problem")
    @PartType("text/plain")
    private String problem;

    public Customer getCustomer() { return customer; }
    public void setCustomer(Customer cust) { this.customer = cust; }
    public String getProblem() { return problem; }
    public void setProblem(String problem) { this.problem = problem; }
}</code></pre>
         <p>After defining the POJO class you can use it to represent multipart/form-data. Here's
            an example of sending a <code class="code">CustomerProblemForm</code> using the
            RESTEasy client framework:
         </p>
         <pre><code class="no-highlight">
            
@Path("portal")
public interface CustomerPortal {

   @Path("issues/{id}")
   @Consumes("multipart/form-data")
   @PUT
   public void putProblem(@MultipartForm CustomerProblemForm,
                          @PathParam("id") int id) {
      CustomerPortal portal = ProxyFactory.create(
            CustomerPortal.class, "http://example.com");
      CustomerProblemForm form = new CustomerProblemForm();
      form.setCustomer(...);
      form.setProblem(...);

      portal.putProblem(form, 333);
   }
}</code></pre>
         <p>Note that the <code class="code">@MultipartForm</code> annotation was used to tell RESTEasy
            that the object has a <code class="code">@FormParam</code>
            and that it should be marshalled from that. You can also use the same
            object to receive multipart data.
            Here is an example of the server side counterpart of our customer portal.
         </p>
         <pre><code class="no-highlight">
            @Path("portal")
public class CustomerPortalServer {

    @Path("issues/{id})
    @Consumes("multipart/form-data")
    @PUT
    public void putIssue(@MultipartForm CustoemrProblemForm,
                         @PathParam("id") int id) {
       ... write to database...
    }
}</code></pre>
         <p>In addition to the XML data format, JSON formatted data can be
            used to represent POJO classes.
            To achieve this goal, plug in a JSON provider into your project. For example,
            add the RESTEasy Jackson2 Provider into your project's dependency scope:
         </p>
         <pre><code class="no-highlight">
            
&lt;dependency&gt;
    &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
    &lt;artifactId&gt;resteasy-jackson2-provider&lt;/artifactId&gt;
    &lt;version&gt;${resteasy.ver}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
         <p>
            Now you can write an ordinary POJO class, which Jackson2 will
            automatically serialize/deserialize into JSON format:
         </p>
         <pre><code class="no-highlight">
            
public class JsonUser {
   private String name;

   public JsonUser() {}
   public JsonUser(final String name) { this.name = name; }
   public String getName() { return name; }
   public void setName(String name) { this.name = name; }
}</code></pre>
         <p>The resource class can be written like this:</p>
         <pre><code class="no-highlight">
            
import org.jboss.resteasy.annotations.providers.multipart.MultipartForm;
import org.jboss.resteasy.annotations.providers.multipart.PartType;

import javax.ws.rs.Consumes;
import javax.ws.rs.FormParam;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;

@Path("/")
public class JsonFormResource {

    public JsonFormResource() {
    }

    public static class Form {

    @FormParam("user")
    @PartType("application/json")
    private JsonUser user;

    public Form() {
    }

    public Form(final JsonUser user) {
    this.user = user;
    }

    public JsonUser getUser() {
      return user;
    }
}

    @PUT
    @Path("form/class")
    @Consumes("multipart/form-data")
    public String putMultipartForm(@MultipartForm Form form) {
         return form.getUser().getName();
    }
}</code></pre>
         <p>As the code shown above, you can see the PartType of JsonUser is marked as "application/json",
            and it's included in the "@MultipartForm Form" class instance.
         </p>
         <p>To send the request to the resource method, you need to send JSON formatted data
            that is corresponding with the JsonUser class. The easiest way to do
            this is to use a proxy class that has
            the same definition of the resource class. Here is the sample code
            of the proxy class that is corresponding with the JsonFormResource class:
         </p>
         <pre><code class="no-highlight">
            
import org.jboss.resteasy.annotations.providers.multipart.MultipartForm;

import javax.ws.rs.Consumes;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;

@Path("/")
public interface JsonForm {

@PUT
@Path("form/class")
@Consumes("multipart/form-data")
  String putMultipartForm(@MultipartForm JsonFormResource.Form form);
}</code></pre>
         <p>And then use the proxy class above to send the request to the
            resource method correctly.  Here is the sample code:
         </p>
         <pre><code class="no-highlight">
            
ResteasyClient client = (ResteasyClient)ClientBuilder.newClient();
...
JsonForm proxy = client.target("your_request_url_address")
                       .proxy(JsonForm.class);
String name = proxy.putMultipartForm(new JsonFormResource
                   .Form(new JsonUser("bill")));
...</code></pre>
         <p>If your client side has the Jackson2 provider included, the
            request will be marshaled correctly.
            The JsonUser data will be converted into JSON format and sent
            to the server side.
            You can also use hand-crafted JSON data as your request and send
            it to server side, but you have to
            make sure the request data is in the correct form.
         </p>
      </section>

</section>

    <section class="section" id="multipart_parsing_note"><div class="titlepage"><div><div><h2 class="title">26.4. Note about multipart parsing and working with other frameworks</h2></div></div></div>
        
        <p>There are a lot of frameworks doing multipart parsing automatically
           with the help of filters and interceptors, like
           <code class="code">org.jboss.seam.web.MultipartFilter</code> in Seam and
           <code class="code">org.springframework.web.multipart.MultipartResolver</code> in Spring,
            however these incoming multipart request stream can be parsed only once.
           RESTEasy users working with multipart should
            make sure that nothing parses the stream before RESTEasy gets it.
        </p>
    </section>
    <section class="section" id="multipart_overwrite_default_content_type"><div class="titlepage"><div><div><h2 class="title">26.5. Overwriting the default fallback content type for multipart messages</h2></div></div></div>
        
        <p>By default if no Content-Type header is present in a part,
           <code class="code">"text/plain; charset=us-ascii"</code> is used as the fallback.
           This is the value defined by the MIME RFC. However some web clients,
           like most, if not all, web browsers,
            do not send Content-Type headers for all fields in a multipart/form-data
           request.  They send them only for the file parts.  This can cause
           character encoding and unmarshalling errors on the server side. To correct
           this there is an option to define an other, non-rfc compliant fallback value.
           This can be done dynamically per request with the filter facility of JAX-RS
           3.0. In the following example we will set
           <code class="code">"*/*; charset=UTF-8"</code> as the new default fallback:
            </p><pre><code class="no-highlight">

import org.jboss.resteasy.plugins.providers.multipart.InputPart;

@Provider
public class InputPartDefaultCharsetOverwriteContentTypeCharsetUTF8
   implements ContainerRequestFilter {

   @Override
   public void filter(ContainerRequestContext requestContext) throws IOException
   {
      requestContext.setProperty(InputPart.DEFAULT_CONTENT_TYPE_PROPERTY, "*/*; charset=UTF-8");
   }
}</code></pre><p>
        </p>
    </section>

    <section class="section" id="multipart_overwrite_content_type"><div class="titlepage"><div><div><h2 class="title">26.6. Overwriting the content type for multipart messages</h2></div></div></div>
        
       <p>Using attribute, InputPart.DEFAULT_CONTENT_TYPE_PROPERTY
          and a filter enables the setting of a default Content-Type,
          It is also possible to override the Content-Type by setting a
          different media type with method <code class="code">InputPart.setMediaType()</code>.
           Here is an example:
       </p>

        <pre><code class="no-highlight">

@POST
@Path("query")
@Consumes(MediaType.MULTIPART_FORM_DATA)
@Produces(MediaType.TEXT_PLAIN)
public Response setMediaType(MultipartInput input) throws IOException
{
    List&lt;InputPart&gt; parts = input.getParts();
    InputPart part = parts.get(0);
    part.setMediaType(MediaType.valueOf("application/foo+xml"));
    String s = part.getBody(String.class, null);
    ...
}</code></pre>

    </section>

    <section class="section" id="multipart_overwrite_default_charset"><div class="titlepage"><div><div><h2 class="title">26.7. Overwriting the default fallback charset for multipart messages</h2></div></div></div>
        

        <p>Sometimes, a part may have a Content-Type header with no charset parameter. If the
            <code class="code">InputPart.DEFAULT_CONTENT_TYPE_PROPERTY</code>
            property is set and the value has a charset parameter,
            that value will be appended to an existing Content-Type header that has no charset parameter.
            It is also possible to specify a default charset using the constant
            <code class="code">InputPart.DEFAULT_CHARSET_PROPERTY</code>
            (actual value "resteasy.provider.multipart.inputpart.defaultCharset"):
        </p>

        <pre><code class="no-highlight">
import org.jboss.resteasy.plugins.providers.multipart.InputPart;

@Provider
public class InputPartDefaultCharsetOverwriteContentTypeCharsetUTF8
   implements ContainerRequestFilter {

   @Override
   public void filter(ContainerRequestContext requestContext) throws IOException
   {
      requestContext.setProperty(InputPart.DEFAULT_CHARSET_PROPERTY, "UTF-8");
   }
}</code></pre>

        <p>If both <code class="code">InputPart.DEFAULT_CONTENT_TYPE_PROPERTY</code> and
        </p>
        <p>
            <code class="code">InputPart.DEFAULT_CHARSET_PROPERTY</code>
            are set, then the value of
        </p>
        <p>
            <code class="code">InputPart.DEFAULT_CHARSET_PROPERTY</code>
            will override any charset in the value of
        </p>
        <p>
            <code class="code">InputPart.DEFAULT_CONTENT_TYPE_PROPERTY</code>.
        </p>
    </section>
</section>

   <section class="chapter" id="JAX-RS_2.1_additions"><div class="titlepage"><div><div><h1 class="title">Chapter 27. JAX-RS 2.1 Additions</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="sect1"><a href="#d5e1759">27.1. <code class="code">CompletionStage</code> support</a></span></li><li><span class="sect1"><a href="#d5e1769">27.2. Reactive Clients API</a></span></li><li><span class="sect1"><a href="#SSE-Server">27.3. Server-Sent Events (SSE)</a></span><ul><li><span class="sect2"><a href="#d5e1778">27.3.1. SSE Server</a></span></li><li><span class="sect2"><a href="#d5e1787">27.3.2. SSE Broadcasting</a></span></li><li><span class="sect2"><a href="#d5e1793">27.3.3. SSE Client</a></span></li></ul></li><li><span class="sect1"><a href="#d5e1799">27.4. Java API for JSON Binding</a></span></li><li><span class="sect1"><a href="#d5e1810">27.5. JSON Patch and JSON Merge Patch</a></span></li></ul></div>
    
    <p>JAX-RS 2.1 adds more asynchronous processing support in both the
        Client and the Server API.  The specification adds a Reactive programming
        style to the Client side and Server-Sent Events (SSE) protocol support to
        both client and server.
    </p>

    <section class="sect1" id="d5e1759"><div class="titlepage"><div><div><h2 class="title">27.1. <code class="code">CompletionStage</code> support</h2></div></div></div>
        
        <p>
            The specification adds support for declaring <a class="link" href="#CompletionStage">asynchronous resource methods by
            returning a <code class="code">CompletionStage</code></a> instead of using the <code class="code">@Suspended</code>
            annotation.
        </p>
        <div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2>
            <p>
                RESTEasy <a class="link" href="#Reactive" title="Chapter 40. Reactive programming support">supports more reactive types than the specification</a>.
            </p>
        </div>
    </section>

    <section class="sect1" id="d5e1769"><div class="titlepage"><div><div><h2 class="title">27.2. Reactive Clients API</h2></div></div></div>
        
        <p>The specification defines a new type of invoker named RxInvoker, and a default
            implementation of this type named CompletionStageRxInvoker.
            CompletionStageRxInvoker implements Java 8's interface CompletionStage.
            This interface declares a large number of methods dedicated to managing
            asynchronous computations.
        </p>
        <p>There is also a new rx method which is used in a similar manner to async.
        </p>
    </section>

    <section class="sect1" id="SSE-Server"><div class="titlepage"><div><div><h2 class="title">27.3. Server-Sent Events (SSE)</h2></div></div></div>
        
        <p>
             SSE is part of HTML standard, currently supported by many browsers. 
             It is a server push technology, which provides a way to establish 
             a one-way channel to continuously send data to clients. SSE events are pushed 
             to the client via a long-running HTTP connection.
             In case of lost connection, clients can retrieve missed events by setting a
             "Last-Event-ID" HTTP header in a new request.
        </p>
        <p> 
             SSE stream has text/event-stream media type and contains multiple SSE events. 
             SSE event is a data structure encoded with UTF-8 and contains fields and comment. 
             The field can be event, data, id, retry and other kinds of field will be ignored.
        </p>
        <p>
             From JAX-RS 2.1, Server-sent Events APIs are introduced to support sending, receiving and broadcasting SSE events.
        </p>
        <section class="sect2" id="d5e1778"><div class="titlepage"><div><div><h3 class="title">27.3.1. SSE Server</h3></div></div></div>
            
            <p>
              As shown in the following example, a SSE resource method has the text/event-stream produce 
              media type and an injected context parameter SseEventSink. The injected SseEventSink is 
              the connected SSE stream where events can be sent. Another injected context Sse is an 
              entry point for creating and broadcasting SSE events. Here is an example to 
              demonstrate how to send SSE events every 200ms and close the stream after a "done" event.             
            </p>
            <p>
            </p><div class="example" id="d5e1782"><div class="example-title">Example 27.1. </div><div class="example-contents">
               <pre><code class="no-highlight">
   @GET
   @Path("domains/{id}")
   @Produces(MediaType.SERVER_SENT_EVENTS)
   public void startDomain(@PathParam("id") final String id, @Context SseEventSink sink @Context Sse sse)
   {
      ExecutorService service = (ExecutorService) servletContext
            .getAttribute(ExecutorServletContextListener.TEST_EXECUTOR);
      service.execute(new Thread()
      {
         public void run()
         {
            try
            {
               sink.send(sse.newEventBuilder().name("domain-progress")
                     .data(String.class, "starting domain " + id + " ...").build());
               Thread.sleep(200);
               sink.send(sse.newEvent("domain-progress", "50%"));
               Thread.sleep(200);
               sink.send(sse.newEvent("domain-progress", "60%"));
               Thread.sleep(200);
               sink.send(sse.newEvent("domain-progress", "70%"));
               Thread.sleep(200);
               sink.send(sse.newEvent("domain-progress", "99%"));
               Thread.sleep(200);
               sink.send(sse.newEvent("domain-progress", "Done.")).thenAccept((Object obj) -&gt; {
                  sink.close();
               });
            }
            catch (final InterruptedException e)
            {
               logger.error(e.getMessage(), e);
            }
         }
      });
   }              
                
                </code></pre>
             </div></div><p><br class="example-break"/>
            </p>
            <div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2>
               <p>
                  RESTEasy <a class="link" href="#Reactive" title="Chapter 40. Reactive programming support">supports sending SSE events via reactive types</a>.
               </p>
            </div>
        </section>
        <section class="sect2" id="d5e1787"><div class="titlepage"><div><div><h3 class="title">27.3.2. SSE Broadcasting</h3></div></div></div>
            
            <p>
               With SseBroadcaster, SSE events can be broadcasted to multiple clients simultaneously. 
               It will iterate over all registered SseEventSinks and send events to all requested SSE Stream.  
               An application can create a SseBroadcaster from an injected context Sse. The broadcast 
               method on a SseBroadcaster is used to send SSE events to all registered clients.
               The following code snippet is an example on how to create SseBroadcaster, subscribe 
               and broadcast events to all subscribed consumers. 
            </p>
            <p>
            </p><div class="example" id="d5e1791"><div class="example-title">Example 27.2. </div><div class="example-contents">
               <pre><code class="no-highlight">
   @GET
   @Path("/subscribe")
   @Produces(MediaType.SERVER_SENT_EVENTS)
   public void subscribe(@Context SseEventSink sink) throws IOException
   {
      if (sink == null)
      {
         throw new IllegalStateException("No client connected.");
      }
      if (sseBroadcaster == null)
      {
         sseBroadcaster = sse.newBroadcaster();
      }
      sseBroadcaster.register(sink);
   }

   @POST
   @Path("/broadcast")
   public void broadcast(String message) throws IOException
   {
      if (sseBroadcaster == null)
      {
         sseBroadcaster = sse.newBroadcaster();
      }
      sseBroadcaster.broadcast(sse.newEvent(message));

   }          
                
                </code></pre>
             </div></div><p><br class="example-break"/>
            </p>
        </section>
        <section class="sect2" id="d5e1793"><div class="titlepage"><div><div><h3 class="title">27.3.3. SSE Client</h3></div></div></div>
            
            <p>
                SseEventSource is the entry point to read and process incoming SSE events. 
                A SseEventSource instance can be initialized with a WebTarget. Once SseEventSource 
                is created and connected to a server, registered event consumer will be invoked when 
                an inbound event arrives. In case of errors, an exception will be passed 
                to a registered consumer so that it can be processed. SseEventSource can automatically reconnect the server 
                and continuously receive pushed events after the connection has been lost. SseEventSource 
                can send lastEventId to the server by default when it is reconnected, and server may use 
                this id to replay all missed events. But reply event is really upon on SSE resource 
                method implementation.  If the server responds HTTP 503 with a RETRY_AFTER header, 
                SseEventSource will automatically schedule a reconnect task with this RETRY_AFTER 
                value. The following code snippet is to create a SseEventSource and print the 
                inbound event data value and error if it happens.
            </p>
          <p>
            </p><div class="example" id="d5e1797"><div class="example-title">Example 27.3. </div><div class="example-contents">
               <pre><code class="no-highlight">
    public void printEvent() throws Exception
    {
      WebTarget target = client.target("http://localhost:8080/service/server-sent-events"));
      SseEventSource msgEventSource = SseEventSource.target(target).build();
      try (SseEventSource eventSource = msgEventSource)
      {
         eventSource.register(event -&gt; {
            System.out.println(event.readData(String.class));
         }, ex -&gt; {
            ex.printStackTrace();
         });
         eventSource.open();
      } 
    }   
                
                </code></pre>
             </div></div><p><br class="example-break"/>
            </p>
        </section>
    </section>
    <section class="sect1" id="d5e1799"><div class="titlepage"><div><div><h2 class="title">27.4. Java API for JSON Binding</h2></div></div></div>
        
        <p>
            RESTEasy supports both JSON-B and JSON-P.  In accordance with the specification,
            entity providers for JSON-B take precedence over those for JSON-P for all types
            except JsonValue and its sub-types.
        </p>
        <p>
            The support for JSON-B is provided by the <code class="code">JsonBindingProvider</code> from <code class="code">resteasy-json-binding-provider</code> module.
            To satisfy JAX-RS 2.1 requirements, JsonBindingProvider takes precedence over the other providers for dealing with JSON payloads,
            in particular the Jackson one. The JSON outputs (for the same input) from Jackson and JSON-B reference implementation can be slightly
            different.  As a consequence, in order to allow retaining backward compatibility, RESTEasy offers a
            <code class="code">resteasy.preferJacksonOverJsonB</code> context property that can be set to <code class="code">true</code> to disable JsonBindingProvider
            for the current deloyment.
        </p>
        <p>
            WildFly 14 supports specifying the default value for the <code class="code">resteasy.preferJacksonOverJsonB</code> context property by setting
            a system property with the same name. Moreover, if no value is set for the context and system properties, it scans JAX-RS deployments
            for Jackson annotations and sets the property to <code class="code">true</code> if any of those annotations is found.
        </p>
    </section>
    <section class="sect1" id="d5e1810"><div class="titlepage"><div><div><h2 class="title">27.5. JSON Patch and JSON Merge Patch</h2></div></div></div>
        
        <p>
            RESTEasy supports apply partial modification to target resource with JSON Patch/JSON Merge Patch.
            Instead of sending json request which represents the whole modified resource with HTTP PUT method, the json request only
            contains the modified part with HTTP PATCH method can do the same job.
        </p>
        <p>
            JSON Patch request has an array of json object and each JSON object gives the operation to execute against the target resource.
            Here is an example to modify the target Student resource which has these fields and values:
            {"firstName":"Alice","id":1,"school":"MiddleWood School"}:
                </p><pre><code class="no-highlight">
            PATCH /StudentPatchTest/students/1 HTTP/1.1
            Content-Type: application/json-patch+json
            Content-Length: 184
            Host: localhost:8090
            Connection: Keep-Alive

            [{"op":"copy","from":"/firstName","path":"/lastName"},
             {"op":"replace","path":"/firstName","value":"John"},
             {"op":"remove","path":"/school"},
             {"op":"add","path":"/gender","value":"male"}]
                 
                </code></pre><p>
            This JSON Patch request will copy the firstName to lastName field , then change the firstName value to "John".
            The next operation is remove the school value and add male gender to this "id=1" student resource.
            After this JSON Path is applied, the target resource will be modified to:
             {"firstName":"John","gender":"male","id":1,"lastName":"Taylor"}.
            The operation keyword here can be "add", "remove", "replace", "move", "copy", or "test". The "path" value
            must be a JSON Pointer value to point the part to apply this JSON Patch.
        </p>
        <p>
            Unlike use the operation keyword to patch the target resource, JSON Merge Patch request directly send the expect
            json change and RestEasy merge this change to target resource which identified by the request URI. Like the below JSON Merge Patch request, it remove
            the "school" value and change the "firstName" to "Green". This is much straightforward:
            </p><pre><code class="no-highlight">
             PATCH /StudentPatchTest/students/1 HTTP/1.1
             Content-Type: application/merge-patch+json
             Content-Length: 34
             Host: localhost:8090
             Connection: Keep-Alive
             {"firstName":"Green","school":null}
             
            </code></pre><p>
        </p>
        <p>
            Enable JSON Patch or JSON Merge Patch only needs correctly annotate the resource method with mediaType:
            @Consumes(MediaType.APPLICATION_JSON_PATCH_JSON) is to enable JSON Patch and @Consumes("application/merge-patch+json")
            to enable JSON Merge Patch:
            </p><pre><code class="no-highlight">
            @GET
            @Path("/{id}")
            @Consumes(MediaType.APPLICATION_JSON)
            @Produces(MediaType.APPLICATION_JSON)
            public Student getStudent(@PathParam("id") long id)
            {
            Student student = studentsMap.get(id);
            if (student == null)
            {
            throw new NotFoundException();
            }
            return student;
            }
            @PATCH
            @Path("/{id}")
            @Consumes(MediaType.APPLICATION_JSON_PATCH_JSON)
            @Produces(MediaType.APPLICATION_JSON)
            public Student patchStudent(@PathParam("id") long id, Student student)
            {
            if (studentsMap.get(id) == null)
            {
            throw new NotFoundException();
            }
            studentsMap.put(id, student);
            return student;
            }
            @PATCH
            @Path("/{id}")
            @Consumes("application/merge-patch+json")
            @Produces(MediaType.APPLICATION_JSON)
            public Student mergePatchStudent(@PathParam("id") long id, Student student)
            {
            if (studentsMap.get(id) == null)
            {
            throw new NotFoundException();
            }
            studentsMap.put(id, student);
            return student;
            }
            
            </code></pre><p>
            </p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2>
                <p>
                 Before create JSON Patch or JSON Merge Patch resource method, there must be a GET method to get this
                  target resource. As above code example, the first resource method is responsible for getting the target
                resource to apply patch.
                </p>
                <p>
                 It requires the patch filter to enable JSON Patch or JSON Merge Patch. The RestEasy PatchMethodFilter
                    is enabled by default. This filter can be disabled by setting "resteasy.patchfilter.disabled" to true
                    as described in <a class="xref" href="#configuration_switches" title="3.5. Configuration switches">Section 3.5, “Configuration switches”</a>.
                </p>
            </div><p>

            Client side needs create these json objects and send it with http PATCH method.
            </p><pre><code class="no-highlight">
            //send JSON Patch request
            WebTarget patchTarget = client.target("http://localhost:8090/StudentPatchTest/students/1"));
            javax.json.JsonArray patchRequest = Json.createArrayBuilder()
            .add(Json.createObjectBuilder().add("op", "copy").add("from", "/firstName").add("path", "/lastName").build())
            .build();
            patchTarget.request().build(HttpMethod.PATCH, Entity.entity(patchRequest, MediaType.APPLICATION_JSON_PATCH_JSON)).invoke();
            //send JSON Merge Patch request
            WebTarget patchTarget = client.target("http://localhost:8090/StudentPatchTest/students/1");
            JsonObject object = Json.createObjectBuilder().add("lastName", "Green").addNull("school").build();
            Response result = patchTarget.request().build(HttpMethod.PATCH, Entity.entity(object, "application/merge-patch+json")).invoke();
                        
            </code></pre><p>
        </p>
    </section>
</section>

   <section class="chapter" id="StringConverter"><div class="titlepage"><div><div><h1 class="title">Chapter 28. String marshalling for String based @*Param</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="sect1"><a href="#d5e1826">28.1. Simple conversion</a></span></li><li><span class="sect1"><a href="#d5e1839">28.2. ParamConverter</a></span></li><li><span class="sect1"><a href="#d5e1857">28.3. StringParameterUnmarshaller</a></span></li><li><span class="sect1"><a href="#d5e1883">28.4. Collections</a></span><ul><li><span class="sect2"><a href="#d5e1907">28.4.1. @QueryParam</a></span></li><li><span class="sect2"><a href="#d5e1915">28.4.2. @MatrixParam</a></span></li><li><span class="sect2"><a href="#d5e1927">28.4.3. @HeaderParam</a></span></li><li><span class="sect2"><a href="#d5e1936">28.4.4. @CookieParam</a></span></li><li><span class="sect2"><a href="#d5e1944">28.4.5. @PathParam</a></span></li></ul></li><li><span class="sect1"><a href="#d5e1960">28.5. Extension to <code class="classname">ParamConverter</code> semantics</a></span></li><li><span class="sect1"><a href="#d5e1996">28.6. Default multiple valued <code class="classname">ParamConverter</code></a></span></li></ul></div>
   
   
   <section class="sect1" id="d5e1826"><div class="titlepage"><div><div><h2 class="title">28.1. Simple conversion</h2></div></div></div>
   
   
   <p>
   Parameters and properties annotated with <code class="classname">@CookieParam</code>, 
   <code class="classname">@HeaderParam</code>, <code class="classname">@MatrixParam</code>, <code class="classname">@PathParam</code>, or 
   <code class="classname">@QueryParam</code> are represented as strings in a raw HTTP request. The specification
   says that any of these injected parameters can be converted to an object if the object's class has
   a <code class="methodname">valueOf(String)</code> static method or a constructor that takes one <code class="classname">String</code>parameter.
   In the following, for example,
   </p>
   <pre><code class="no-highlight">
public static class Customer {
   private String name;

   public Customer(String name) {
      this.name = name;
   }
   
   public String getName() {
      return name;
   }
}

@Path("test")
public static class TestResource {

   @GET
   @Path("")
   public Response test(@QueryParam("cust") Customer cust) {
      return Response.ok(cust.getName()).build();
   }
}

@Test
public void testQuery() throws Exception {
   Invocation.Builder request = ClientBuilder.newClient().target("http://localhost:8081/test?cust=Bill").request();
   Response response = request.get();
   ...
}
   </code></pre>
   <p>
   the query "?cust=Bill" will be transformed automatically to an instance of <code class="classname">Customer</code> with name
   == "Bill".  
   </p>
   </section>
   
   <section class="sect1" id="d5e1839"><div class="titlepage"><div><div><h2 class="title">28.2. ParamConverter</h2></div></div></div>
   
   
   <p>
   What if you have a class where <code class="methodname">valueOf()</code>or this string constructor don't exist or are inappropriate
   for an HTTP request? JAX-RS 2.0 has the <code class="classname">javax.ws.rs.ext.ParamConverterProvider</code> to help
   in this situation.
   </p>
   
   <p>
   A <code class="classname">ParamConverterProvider</code> is a provider defined as follows:
   </p>
      
   <pre><code class="no-highlight">
public interface ParamConverterProvider {

   public &lt;T&gt; ParamConverter&lt;T&gt; getConverter(Class&lt;T&gt; rawType, Type genericType, Annotation annotations[]);
}
   </code></pre>
   
   <p>
   where a <code class="classname">ParamConverter</code> is defined:
   </p>
   
   <pre><code class="no-highlight">
public interface ParamConverter&lt;T&gt; {
   ...
   public T fromString(String value);
   public String toString(T value);
}
   </code></pre>
   
   <p>
   For example, consider <code class="classname">DateParamConverterProvider</code> and <code class="classname">DateParamConverter</code>:
   </p>
   
   <pre><code class="no-highlight">
@Provider
public class DateParamConverterProvider implements ParamConverterProvider {

   @SuppressWarnings("unchecked")
   @Override
   public &lt;T&gt; ParamConverter&lt;T&gt; getConverter(Class&lt;T&gt; rawType, Type genericType, Annotation[] annotations) {
      if (rawType.isAssignableFrom(Date.class)) {
         return (ParamConverter&lt;T&gt;) new DateParamConverter();
      }
      return null;
   }
}

public class DateParamConverter implements ParamConverter&lt;Date&gt; {

   public static final String DATE_PATTERN = "yyyyMMdd";

   @Override
   public Date fromString(String param) {
      try {
         return new SimpleDateFormat(DATE_PATTERN).parse(param.trim());
      } catch (ParseException e) {
         throw new BadRequestException(e);
      }
   }

   @Override
   public String toString(Date date) {
      return new SimpleDateFormat(DATE_PATTERN).format(date);
   }
}
   </code></pre>
   
   <p>
   Sending a <code class="classname">Date</code> in the form of a query, e.g., "?date=20161217" will cause the string "20161217"
   to be converted to a <code class="classname">Date</code> on the server.
   </p>
   </section>
   
   <section class="sect1" id="d5e1857"><div class="titlepage"><div><div><h2 class="title">28.3. StringParameterUnmarshaller</h2></div></div></div>
   
   
   <p>
   In addition to the JAX-RS <code class="classname">javax.ws.rs.ext.ParamConverterProvider</code>,
   RESTEasy also has its own <code class="classname">org.jboss.resteasy.StringParameterUnmarshaller</code>, defined
   </p>
   
   <pre><code class="no-highlight">
public interface StringParameterUnmarshaller&lt;T&gt;
{
   void setAnnotations(Annotation[] annotations);

   T fromString(String str);
}
   </code></pre>
   <p>
   It is similar to <code class="classname">javax.ws.rs.ext.ParamConverter</code> except that
   </p>
   <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">it converts only from <code class="classname">String</code>s;</li><li class="listitem">it is configured with the annotations on the injected parameter, which 
                allows for fine-grained control over the injection; and</li><li class="listitem">it is bound to a given parameter by an annotation that is annotated with the meta-annotation
                <code class="classname">org.jboss.resteasy.annotations.StringParameterUnmarshallerBinder:</code></li></ul></div>
   
   <pre><code class="no-highlight">
@Target({ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface StringParameterUnmarshallerBinder
{
   Class&lt;? extends StringParameterUnmarshaller&gt; value();
}
   </code></pre>
   <p>
   For example,
   </p>
   
   <pre><code class="no-highlight">
   @Retention(RetentionPolicy.RUNTIME)
   @StringParameterUnmarshallerBinder(TestDateFormatter.class)
   public @interface TestDateFormat {
      String value();
   }

   public static class TestDateFormatter implements StringParameterUnmarshaller&lt;Date&gt; {
      private SimpleDateFormat formatter;

      public void setAnnotations(Annotation[] annotations) {
         TestDateFormat format = FindAnnotation.findAnnotation(annotations, TestDateFormat.class);
         formatter = new SimpleDateFormat(format.value());
      }

      public Date fromString(String str) {
         try {
            return formatter.parse(str);
         } catch (ParseException e) {
            throw new RuntimeException(e);
         }
      }
   }
   
   @Path("/")
   public static class TestResource {

      @GET
      @Produces("text/plain")
      @Path("/datetest/{date}")
      public String get(@PathParam("date") @TestDateFormat("MM-dd-yyyy") Date date) {
         Calendar c = Calendar.getInstance();
         c.setTime(date);
         return date.toString();
      }
   }
   </code></pre>
   
   <p>
   Note that the annotation <code class="classname">@StringParameterUnmarshallerBinder</code> on the
   annotation <code class="classname">@TestDateFormat</code> binds the formatter
   <code class="classname">TestDateFormatter</code> to a parameter annotated with <code class="classname">@TestDateFormat</code>.
   In this example, <code class="classname">TestDateFormatter</code> is used to format the <code class="classname">Date</code> parameter.
   Note also that the parameter "MM-dd-yyyy" to <code class="classname">@TestDateFormat</code> is accessible from
   <code class="methodname">TestDateFormatter.setAnnotations()</code>.
   </p>
   </section>
   
   <section class="sect1" id="d5e1883"><div class="titlepage"><div><div><h2 class="title">28.4. Collections</h2></div></div></div>
   
   
   <p>
   For parameters and properties annotated with <code class="classname">@CookieParam</code>, <code class="classname">@HeaderParam</code>,
   <code class="classname">@MatrixParam</code>, <code class="classname">@PathParam,</code> or <code class="classname">@QueryParam</code>, the JAX-RS specification
   [<a class="ulink" href="https://jcp.org/aboutJava/communityprocess/final/jsr339/index.html">https://jcp.org/aboutJava/communityprocess/final/jsr339/index.html</a>]
   allows conversion as defined in the Javadoc of the
   corresponding annotation. In general, the following types are supported: 
   </p>
   
   <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
   Types for which a <code class="classname">ParamConverter</code> is available via a registered <code class="classname">ParamConverterProvider</code>. See
   Javadoc for these classes for more information.
   </li><li class="listitem">
   Primitive types.
   </li><li class="listitem">
   Types that have a constructor that accepts a single <code class="classname">String</code> argument.
   </li><li class="listitem">
   Types that have a static method named <code class="methodname">valueOf</code> or <code class="methodname">fromString</code>
   with a single <code class="classname">String</code> argument
   that return an instance of the type. If both methods are present then <code class="methodname">valueOf</code> MUST be used
   unless the type is an enum in which case <code class="methodname">fromString</code> MUST be used.
   </li><li class="listitem">
   List&lt;T&gt;, Set&lt;T&gt;, or SortedSet&lt;T&gt;, where T satisfies 3 or 4 above.
   </li></ol></div>
   
   <p>
   Items 1, 3, and 4 have been discussed above, and item 2 is obvious. Note that item 5 allows for
   collections of parameters. How these collections are expressed in HTTP messages depends, by
   default, on the particular kind of parameter. In most cases, the notation for collections is based
   on convention rather than a specification.
   </p>
   
   <section class="sect2" id="d5e1907"><div class="titlepage"><div><div><h3 class="title">28.4.1. @QueryParam</h3></div></div></div>
   
   
   <p>
   For example, a multivalued query parameter is conventionally expressed like this:
   </p>
   
   <pre><code class="no-highlight">
http://bluemonkeydiamond.com?q=1&amp;q=2&amp;q=3
   </code></pre>
   
   <p>
   In this case, there is a query with name "q" and value {1, 2, 3}. This notation is further supported
   in JAX-RS by the method
   </p>
   
   <pre><code class="no-highlight">
public MultivaluedMap&lt;String, String&gt; getQueryParameters();
   </code></pre>
   
   <p>
   in <code class="classname">javax.ws.rs.core.UriInfo</code>.
   </p>
   </section>
   
   <section class="sect2" id="d5e1915"><div class="titlepage"><div><div><h3 class="title">28.4.2. @MatrixParam</h3></div></div></div>
   
   
   <p>
   There is no specified syntax for collections derived from matrix parameters, but
   </p>
   
   <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
   matrix parameters in a URL segment are conventionally separated by ";", and
   </li><li class="listitem">
   the method
   <pre><code class="no-highlight">
MultivaluedMap&lt;String, String&gt; getMatrixParameters();
   </code></pre>
   <p>
   in <code class="classname">javax.ws.rs.core.PathSegment</code> supports extraction of collections from matrix parameters.
   </p>
   </li></ol></div>
      
   <p>
   RESTEasy adopts the convention that multiple instances of a matrix parameter with the same name
   are treated as a collection. For example,
   </p>
   <pre><code class="no-highlight">
http://bluemonkeydiamond.com/sippycup;m=1;m=2;m=3
   </code></pre>
   
   <p>
   is interpreted as a matrix parameter on path segment "sippycup" with name "m" and value {1, 2, 3}.
   </p>
   </section>
   
   <section class="sect2" id="d5e1927"><div class="titlepage"><div><div><h3 class="title">28.4.3. @HeaderParam</h3></div></div></div>
   
   
   <p>
   The HTTP 1.1 specification doesn't exactly specify that multiple components of a header value
   should be separated by commas, but commas are used in those headers that naturally use lists,
   e.g. Accept and Allow. Also, note that the method
   </p>
  
   <pre><code class="no-highlight">
public MultivaluedMap&lt;String, String&gt; getRequestHeaders();
   </code></pre>
   
   <p>
   in <code class="classname">javax.ws.rs.core.HttpHeaders</code> returns a <code class="classname">MultivaluedMap</code>.
   It is natural, then, for RESTEasy to treat
   </p>
   
   <pre><code class="no-highlight">
x-header: a, b, c
   </code></pre>
   
   <p>
   as mapping name "x-header" to set {a, b, c}.
   </p>
   </section>
   
   <section class="sect2" id="d5e1936"><div class="titlepage"><div><div><h3 class="title">28.4.4. @CookieParam</h3></div></div></div>
   
   
   <p>
   The syntax for cookies is specified, but, unfortunately, it is specified in multiple competing
   specifications. Typically, multiple name=value cookie pairs are separated by ";". However, unlike
   the case with query and matrix parameters, there is no specified JAX-RS method that returns a
   collection of cookie values. Consequently, if two cookies with the same name are received on
   the server and directed to a collection typed parameter, RESTEasy will inject only the second one.
   Note, in fact, that the method
   </p>
   
   <pre><code class="no-highlight">
public Map&lt;String, Cookie&gt; getCookies();
   </code></pre>
   
   <p>
   in <code class="classname">javax.ws.rs.core.HttpHeaders</code> returns a <code class="classname">Map</code> rather than a
   <code class="classname">MultivaluedMap</code>.
   </p>
   
   </section>
   
   <section class="sect2" id="d5e1944"><div class="titlepage"><div><div><h3 class="title">28.4.5. @PathParam</h3></div></div></div>
   
   
   <p>
   Deriving a collection from path segments is somewhat less natural than it is for other parameters,
   but JAX-RS supports the injection of multiple <code class="classname">javax.ws.rs.core.PathSegment</code>s. There are a
   couple of ways of obtaining multiple <code class="classname">PathSegment</code>s. One is through the use of multiple path
   variables with the same name. For example, the result of calling <code class="methodname">testTwoSegmentsArray()</code> and
   <code class="methodname">testTwoSegmentsList()</code> in
   </p>
   
   <pre><code class="no-highlight">
@Path("")
public static class TestResource {

   @GET
   @Path("{segment}/{other}/{segment}/array")
   public Response getTwoSegmentsArray(@PathParam("segment") PathSegment[] segments) {
      System.out.println("array segments: " + segments.length);
      return Response.ok().build();
   }
   
   @GET
   @Path("{segment}/{other}/{segment}/list")
   public Response getTwoSegmentsList(@PathParam("segment") List&lt;PathSegment&gt; segments) {
      System.out.println("list segments: " + segments.size());
      return Response.ok().build();
   }
}

...

   @Test
   public void testTwoSegmentsArray() throws Exception {
      Invocation.Builder request = client.target("http://localhost:8081/a/b/c/array").request();
      Response response = request.get();
      Assert.assertEquals(200, response.getStatus());
      response.close();
   }
   
   @Test
   public void testTwoSegmentsList() throws Exception {
      Invocation.Builder request = client.target("http://localhost:8081/a/b/c/list").request();
      Response response = request.get();
      Assert.assertEquals(200, response.getStatus());
      response.close();
   }
   </code></pre>
   
   <p>is</p>
   
   <pre><code class="no-highlight">
array segments: 2
list segments: 2
   </code></pre>
   
   <p>
   An alternative is to use a wildcard template parameter. For example, the output of calling
   <code class="methodname">testWildcardArray()</code> and <code class="methodname">testWildcardList() </code>in
   </p>
   
   <pre><code class="no-highlight">
@Path("")
public static class TestResource {

   @GET
   @Path("{segments:.*}/array")
   public Response getWildcardArray(@PathParam("segments") PathSegment[] segments) {
      System.out.println("array segments: " + segments.length);
      return Response.ok().build();
   }
   
   @GET
   @Path("{segments:.*}/list")
   public Response getWildcardList(@PathParam("segments") List&lt;PathSegment&gt; segments) {
      System.out.println("list segments: " + segments.size());
      return Response.ok().build();
   }
   
...

   @Test
   public void testWildcardArray() throws Exception {
      Invocation.Builder request = client.target("http://localhost:8081/a/b/c/array").request();
      Response response = request.get();
      response.close();
   }
   
   @Test
   public void testWildcardList() throws Exception {
      Invocation.Builder request = client.target("http://localhost:8081/a/b/c/list").request();
      Response response = request.get();
      response.close();
   }
   </code></pre>
   
   <p>is</p>
   
   <pre><code class="no-highlight">
array segments: 3
list segments: 3
   </code></pre>
   
   </section>
   </section>
   
   <section class="sect1" id="d5e1960"><div class="titlepage"><div><div><h2 class="title">28.5. Extension to <code class="classname">ParamConverter</code> semantics</h2></div></div></div>
   
   
   <p>
   In the JAX-RS semantics, a <code class="classname">ParamConverter</code> is supposed to convert a single <code class="classname">String</code> that
   represents an individual object. RESTEasy extends the semantics to allow a <code class="classname">ParamConverter</code>
   to parse the <code class="classname">String</code> representation of multiple objects and generate a <code class="classname">List&lt;T&gt;</code>,
   <code class="classname">Set&lt;T&gt;</code>, <code class="classname">SortedSet&lt;T&gt;</code>, array, or, indeed, any multivalued data structure
   whatever. First, consider the resource
   </p>
   
   <pre><code class="no-highlight">
@Path("queryParam")
public static class TestResource {

   @GET
   @Path("")
   public Response conversion(@QueryParam("q") List&lt;String&gt; list) {
      return Response.ok(stringify(list)).build();
   }
}

private static &lt;T&gt; String stringify(List&lt;T&gt; list) {
   StringBuffer sb = new StringBuffer();
   for (T s : list) {
      sb.append(s).append(',');
   }
   return sb.toString();
}
   </code></pre>
   
   <p>
   Calling <code class="classname">TestResource</code> as follows, using the standard notation,
   </p>
   
   <pre><code class="no-highlight">
@Test
public void testQueryParamStandard() throws Exception {
   Client client = ClientBuilder.newClient();
   Invocation.Builder request = client.target("http://localhost:8081/queryParam?q=20161217&amp;q=20161218&amp;q=20161219").request();
   Response response = request.get();
   System.out.println("response: " + response.readEntity(String.class));
}
   </code></pre>
   
   <p>results in</p>
   
   <pre><code class="no-highlight">
response: 20161217,20161218,20161219,
   </code></pre>
   
   <p>
   Suppose, instead, that we want to use a comma separated notation. We can add
   </p>
   
   <pre><code class="no-highlight">
public static class MultiValuedParamConverterProvider implements ParamConverterProvider

   @SuppressWarnings("unchecked")
   @Override
   public &lt;T&gt; ParamConverter&lt;T&gt; getConverter(Class&lt;T&gt; rawType, Type genericType, Annotation[] annotations) {
      if (List.class.isAssignableFrom(rawType)) {
         return (ParamConverter&lt;T&gt;) new MultiValuedParamConverter();
      }
      return null;
   }   
}

public static class MultiValuedParamConverter implements ParamConverter&lt;List&lt;?&gt;&gt; {

   @Override
   public List&lt;?&gt; fromString(String param) {
      if (param == null || param.trim().isEmpty()) {
         return null;
      }
      return parse(param.split(","));
   }

   @Override
   public String toString(List&lt;?&gt; list) {
      if (list == null || list.isEmpty()) {
         return null;
      }
      return stringify(list);
   }
   
   private static List&lt;String&gt; parse(String[] params) {
      List&lt;String&gt; list = new ArrayList&lt;String&gt;();
      for (String param : params) {
         list.add(param);
      }
      return list;
   }
}
   </code></pre>
   
   <p>Now we can call</p>
   
   <pre><code class="no-highlight">
@Test
public void testQueryParamCustom() throws Exception {
   Client client = ClientBuilder.newClient();
   Invocation.Builder request = client.target("http://localhost:8081/queryParam?q=20161217,20161218,20161219").request();
   Response response = request.get();
   System.out.println("response: " + response.readEntity(String.class));
}
   </code></pre>
   
   <p>and get</p>
   
   <pre><code class="no-highlight">
response: 20161217,20161218,20161219,
   </code></pre>
   
   <p>
   Note that in this case, <code class="methodname">MultiValuedParamConverter.fromString()</code> creates and returns an
   <code class="classname">ArrayList</code>, so <code class="methodname">TestResource.conversion()</code> could be rewritten
   </p>
   
   <pre><code class="no-highlight">
@Path("queryParam")
public static class TestResource {

   @GET
   @Path("")
   public Response conversion(@QueryParam("q") ArrayList&lt;String&gt; list) {
      return Response.ok(stringify(list)).build();
   }
}
   </code></pre>
   
   <p>
   On the other hand, <code class="classname">MultiValuedParamConverter</code> could be rewritten to return a
   <code class="classname">LinkList</code> and the parameter list in <code class="methodname">TestResource.conversion()</code>
   could be either a <code class="classname">List</code> or a <code class="classname">LinkedList</code>.
   </p>
   
   <p>
   Finally, note that this extension works for arrays as well. For example,
   </p>
   
   <pre><code class="no-highlight">
  public static class Foo {
      private String foo;
      public Foo(String foo) {this.foo = foo;}
      public String getFoo() {return foo;}
   }
   
   public static class FooArrayParamConverter implements ParamConverter&lt;Foo[]&gt; {

      @Override
      public Foo[] fromString(String value)
      {
         String[] ss = value.split(",");
         Foo[] fs = new Foo[ss.length];
         int i = 0;
         for (String s : ss) {
            fs[i++] = new Foo(s);
         }
         return fs;
      }

      @Override
      public String toString(Foo[] values)
      {
         StringBuffer sb = new StringBuffer();
         for (int i = 0; i &lt; values.length; i++) {
            sb.append(values[i].getFoo()).append(",");
         }
         if (sb.length() &gt; 0) {
            sb.deleteCharAt(sb.length() - 1);
         }
         return sb.toString();
      }
   }
   
   @Provider
   public static class FooArrayParamConverterProvider implements ParamConverterProvider {

      @SuppressWarnings("unchecked")
      @Override
      public &lt;T&gt; ParamConverter&lt;T&gt; getConverter(Class&lt;T&gt; rawType, Type genericType, Annotation[] annotations) {
         if (rawType.equals(Foo[].class));
         return (ParamConverter&lt;T&gt;) new FooArrayParamConverter();
      }
   }
   
   @Path("")
   public static class ParamConverterResource {

      @GET
      @Path("test")
      public Response test(@QueryParam("foos") Foo[] foos) {
         return Response.ok(new FooArrayParamConverter().toString(foos)).build();
      }
   }
   </code></pre>
   </section>
 
    <section class="sect1" id="d5e1996"><div class="titlepage"><div><div><h2 class="title">28.6. Default multiple valued <code class="classname">ParamConverter</code></h2></div></div></div>
   
   
   <p>
   RESTEasy includes two built-in <code class="classname">ParamConverter</code>s in the resteasy-jaxrs module,
   one for <code class="classname">Collection</code>s:
   </p>
   
<pre><code class="no-highlight">
   <code class="classname">org.jboss.resteasy.plugins.providers.MultiValuedCollectionParamConverter</code>,
</code></pre>

   <p>
   and one for arrays:
   </p>
   
<pre><code class="no-highlight">
   <code class="classname">org.jboss.resteasy.plugins.providers.MultiValuedArrayParamConverter</code>,
</code></pre>
   
   <p>
   which implement the concepts in the previous section.
   </p>
   
   <p>
   In particular, <code class="methodname">MultiValued*ParamConverter.fromString()</code> can transform a
   string representation coming over the network into a <code class="classname">Collection</code> or array, and
   <code class="methodname">MultiValued*ParamConverter.toString()</code> can be used by a client side proxy
   to transform <code class="classname">Collection</code>s or arrays into a string representation.
   </p>
   
   <p>
   String representations are determined by <code class="classname">org.jboss.resteasy.annotations.Separator</code>,
   a parameter annotation in the resteasy-core module:
   </p>
   
<pre><code class="no-highlight">
@Target({ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
public @interface Separator
{
   public String value() default "";
}
</code></pre>

   <p>
   The value of <code class="code">Separator.value()</code> is used to separate individual elements of a <code class="classname">Collection</code>
   or array. For example, a proxy implementing
   </p>
   
<pre><code class="no-highlight">
@Path("path/separator/multi/{p}")
@GET
public String pathMultiSeparator(@PathParam("p") @Separator("-") List&lt;String&gt; ss); 
</code></pre>

   <p>
   will turn
   </p>
   
<pre><code class="no-highlight">
List&lt;String&gt; list = new ArrayList&lt;String&gt;();
list.add("abc");
list.add("xyz");
proxy.pathMultiSeparator(list);
</code></pre>

  <p>
  and "path/separator/multi/{p}" into ".../path/separator/multi/abc-xyz". On the server side,
  the RESTEasy runtime will turn "abc-xyz" back into a list consisting of elements "abc" and "xyz" for
  </p>
  
<pre><code class="no-highlight">
@Path("path/separator/multi/{p}")
@GET
public String pathMultiSeparator(@PathParam("p") @Separator("-") List&lt;String&gt; ss) {
   StringBuffer sb = new StringBuffer();
   for (String s : ss) {
      sb.append(s);
      sb.append("|");
   }
   return sb.toString();
}
</code></pre>
  
   <p>
   which will return "abc|xyz|".
   </p>
   
   <p>
   In fact, the value of the <code class="classname">Separator</code> annotations may be a more general regular
   expression, which is passed to <code class="methodname">String.split()</code>. For example, "[-,;]" tells the
   server side to break up a string using either "-", ",", or ";". On the client side, a string will be created
   using the first element, "-" in this case.
   </p>
   
   <p>
   If a parameter is annotated with <code class="classname">@Separator</code> with no value, then the default value is
   </p>
   
   <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">"," for a <code class="classname">@HeaderParam</code>, <code class="classname">@MatrixParam</code>,
      <code class="classname">@PathParam</code>, or <code class="classname">@QueryParam</code>, and
      </li><li class="listitem">
      "-" for a <code class="classname">@CookieParam</code>.
      </li></ul></div>
   
   <p>
      The <code class="classname">MultiValued*ParamConverter</code>s depend on existing facilities for handling
      the individual elements. On the server side, once it has parsed the incoming string into substrings,
      <code class="classname">MultiValued*ParamConverter</code> turns each substring into an Java object according
      to Section 3.2 "Fields and Bean Properties" of the JAX-RS specification. On the client side, 
      <code class="classname">MultiValued*ParamConverter</code> turns a Java object into a string as follows:
   </p>
   
   <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">look for a <code class="classname">ParamConverter</code>;</li><li class="listitem">
         if there is no suitable <code class="classname">ParamConverter</code> and the parameter
         is labeled <code class="classname">@HeaderParam</code>, look for a
         <code class="classname">HeaderDelegate</code>; or</li><li class="listitem">
         call <code class="methodname">toString()</code>.
      </li></ol></div>
   
   <p>
   These <code class="classname">ParamConverter</code>s are meant to be fairly general, but there are a number of
   restrictions:
   </p>
   
   <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">They don't handle nested <code class="classname">Collections</code> or arrays. That is,
      <code class="classname">List&lt;String&gt;</code> and <code class="code">String[]</code> are OK, but
      <code class="classname">List&lt;List&lt;String&gt;&gt;</code> and <code class="code">String[][]</code> are not. 
      </li><li class="listitem">
      The regular expression used in <code class="classname">Separator</code> must match the regular expression
<pre><code class="no-highlight">
"\\p{Punct}|\\[\\p{Punct}+\\]"
</code></pre>

      That is, it must be either a single instance of a punctuation symbol, i.e., a symbol in the set
<pre><code class="no-highlight">
!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_`{|}~
</code></pre>

      or a class of punctuation symbols like "[-,;]".
      </li><li class="listitem">
      For either of these <code class="classname">ParamConverter</code>s to be available for use with a given parameter, that
      parameter must be annotated with <code class="classname">@Separator</code>.
      </li></ol></div>
   
   <p>
   There are also some logical restrictions:
   </p>
   
   <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
      Cookie syntax, as specified in <a class="ulink" href="https://tools.ietf.org/html/rfc6265#section-4.1.1">https://tools.ietf.org/html/rfc6265#section-4.1.1</a>,
      assigns a meaning to ";", so it cannot be used as a separator.
      </li><li class="listitem">
      If a separator character appears in the content of an element, then there will be problems. For example, if "," is
      used as a separator, then, if a proxy sends the array <code class="code">["a","b,c","d"]</code>, it will turn into the 
      string "a,b,c,d" on the wire and be reconstituted on the server as four elements.
      </li></ol></div>
   
   <p>
   These built-in <code class="classname">ParamConverter</code>s have the lowest priority, so any user supplied 
   <code class="classname">ParamConverter</code>s will be tried first.
   </p>
   </section>
     
</section>

   <section class="chapter" id="Responses_using_javax.ws.rs.core.Response"><div class="titlepage"><div><div><h1 class="title">Chapter 29. Responses using javax.ws.rs.core.Response</h1></div></div></div>


<p>

You can build custom responses using the javax.ws.rs.core.Response and ResponseBuilder classes.  If you want to do your own streaming, your entity response must be an implementation of javax.ws.rs.core.StreamingOutput.   See the java doc for more information.
</p>
<p>


</p>
</section>

   <section class="chapter" id="ExceptionHandling"><div class="titlepage"><div><div><h1 class="title">Chapter 30. Exception Handling</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="sect1"><a href="#ExceptionMappers">30.1. Exception Mappers</a></span></li><li><span class="sect1"><a href="#builtinException">30.2. RESTEasy Built-in Internally-Thrown Exceptions</a></span></li><li><span class="sect1"><a href="#ResteasyWebApplicationException">30.3. Resteasy WebApplicationExceptions</a></span></li><li><span class="sect1"><a href="#overring_resteasy_exceptions">30.4. Overriding RESTEasy Builtin Exceptions</a></span></li></ul></div>
   

   <section class="sect1" id="ExceptionMappers"><div class="titlepage"><div><div><h2 class="title">30.1. Exception Mappers</h2></div></div></div>
   
   <p>

      ExceptionMappers are custom, application provided, components that can catch thrown application exceptions and
      write specific HTTP responses. They are classes annotated with @Provider and that implement this interface
   </p>
   <p>

      </p><pre><code class="no-highlight">
         package javax.ws.rs.ext;

         import javax.ws.rs.core.Response;

         /**
         * Contract for a provider that maps Java exceptions to
         * {@link javax.ws.rs.core.Response}. An implementation of this interface must
         * be annotated with {@link Provider}.
         *
         * @see Provider
         * @see javax.ws.rs.core.Response
         */
         public interface ExceptionMapper&lt;E&gt;
         {
            /**
            * Map an exception to a {@link javax.ws.rs.core.Response}.
            *
            * @param exception the exception to map to a response
            * @return a response mapped from the supplied exception
            */
            Response toResponse(E exception);
         }
      </code></pre><p>
   </p>
   <p>

      When an application exception is thrown it will be caught by the JAX-RS runtime. JAX-RS will then scan registered
      ExceptionMappers to see which one support marshalling the exception type thrown. Here is an example of
      ExceptionMapper
   </p>
   <p>

      </p><pre><code class="no-highlight">

         @Provider
         public class EJBExceptionMapper implements ExceptionMapper&lt;javax.ejb.EJBException&gt;
         {
            public Response toResponse(EJBException exception) {
               return Response.status(500).build();
            }
         }
      </code></pre><p>
   </p>
   <p>

      You register ExceptionMappers the same way you do MessageBodyReader/Writers. By scanning for @Provider
      annotated classes, or programmatically through the
      ResteasyProviderFactory class.
   </p>
   <p>


   </p>
   </section>
   <section class="sect1" id="builtinException"><div class="titlepage"><div><div><h2 class="title">30.2. RESTEasy Built-in Internally-Thrown Exceptions</h2></div></div></div>
     
     <p>RESTEasy has a set of built-in exceptions that are thrown by it when it encounters errors during dispatching or marshalling.  They all
           revolve around specific HTTP error codes.  You can find them in RESTEasy's javadoc under the package org.jboss.resteasy.spi.  Here's
           a list of them:</p>
<div class="table" id="d5e2095"><div class="table-title">Table 30.1. </div><div class="table-contents">
<table style="border-collapse: collapse;border-top: 1px solid ; border-bottom: 1px solid ; "><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 1px  ; border-bottom: 1px  ; ">Exception</th><th style="border-right: 1px  ; border-bottom: 1px  ; ">HTTP Code</th><th style="border-bottom: 1px  ; ">Description</th></tr></thead><tbody><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">ReaderException</td><td style="border-right: 1px  ; border-bottom: 1px  ; ">400</td><td style="border-bottom: 1px  ; ">All exceptions thrown from MessageBodyReaders are wrapped within this exception.  If there is no ExceptionMapper for the
wrapped exception or if the exception isn't a WebApplicationException, then resteasy will return a 400 code by default.</td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">WriterException</td><td style="border-right: 1px  ; border-bottom: 1px  ; ">500</td><td style="border-bottom: 1px  ; ">All exceptions thrown from MessageBodyWriters are wrapped within this exception.  If there is no ExceptionMapper for the
wrapped exception or if the exception isn't a WebApplicationException, then resteasy will return a 400 code by default.</td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">o.j.r.plugins.providers.jaxb.JAXBUnmarshalException</td><td style="border-right: 1px  ; border-bottom: 1px  ; ">400</td><td style="border-bottom: 1px  ; ">The JAXB providers throw this exception on reads.  They may be wrapping JAXBExceptions.  This class extends ReaderException</td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">o.j.r.plugins.providers.jaxb.JAXBMarshalException</td><td style="border-right: 1px  ; border-bottom: 1px  ; ">500</td><td style="border-bottom: 1px  ; ">The JAXB providers throw this exception on writes.  They may be wrapping JAXBExceptions.  This class extends WriterException</td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">ApplicationException</td><td style="border-right: 1px  ; border-bottom: 1px  ; ">N/A</td><td style="border-bottom: 1px  ; ">This exception wraps all exceptions thrown from application code.  It functions much in the same way as InvocationTargetException.
If there is an ExceptionMapper for wrapped exception, then that is used to handle the request.</td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">Failure</td><td style="border-right: 1px  ; border-bottom: 1px  ; ">N/A</td><td style="border-bottom: 1px  ; ">Internal RESTEasy.  Not logged</td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">LoggableFailure</td><td style="border-right: 1px  ; border-bottom: 1px  ; ">N/A</td><td style="border-bottom: 1px  ; ">Internal RESTEasy error.  Logged</td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">DefaultOptionsMethodException</td><td style="border-right: 1px  ; border-bottom: 1px  ; ">N/A</td><td style="border-bottom: 1px  ; ">If the user invokes HTTP OPTIONS and no JAX-RS method for it, RESTEasy provides a default behavior by throwing this exception.
This is only done if the property <code class="code">dev.resteasy.throw.options.exception</code> is set to true.</td></tr><tr><td style="border-right: 1px  ; ">UnrecognizedPropertyExceptionHandler</td><td style="border-right: 1px  ; ">400</td><td>A Jackson provider throws this exception when JSON data is determine to be invalid.</td></tr></tbody></table>
</div></div><br class="table-break"/>
</section>
<section class="sect1" id="ResteasyWebApplicationException"><div class="titlepage"><div><div><h2 class="title">30.3. Resteasy WebApplicationExceptions</h2></div></div></div>
   
   <p>Suppose a client at local.com calls the following resource method:</p>
   <pre><code class="no-highlight">
   @GET
   @Path("remote")
   public String remote() throws Exception {
      Client client = ClientBuilder.newClient();
      return client.target("http://third.party.com/exception").request().get(String.class);
   }
   </code></pre>
   <p>If the call to http://third.party.com returns a status code 3xx, 4xx, or 5xx, then the 
   <code class="classname">Client</code> is obliged by the JAX-RS
   specification to throw a <code class="classname">WebApplicationException</code>. Moreover, if the
   <code class="classname">WebApplicationException</code> contains a <code class="classname">Response</code>, which
   it normally would in RESTEasy, the server runtime is obliged by the JAX-RS specification to return that
   <code class="classname">Response</code>.
   As a result, information from the server at third.party.com, e.g., headers and body, will get sent back to
   local.com. The problem is that that information could be, at best, meaningless to the client
   and, at worst, a security breach.</p>

   <p>RESTEasy has a solution that works around the problem and still conforms to the JAX-RS specification.
   In particular, for each <code class="classname">WebApplicationException</code> it defines a new subclass:</p>

<pre><code class="no-highlight">
WebApplicationException
+-ResteasyWebApplicationException
+-ClientErrorException
| +-ResteasyClientErrorException
| +-BadRequestException
| | +-ResteasyBadRequestException
| +-ForbiddenException
| | +-ResteasyForbiddenException
| +-NotAcceptableException
| | +-ResteasyNotAcceptableException
| +-NotAllowedException
| | +-ResteasyNotAllowedException
| +-NotAuthorizedException
| | +-ResteasyNotAuthorizedException
| +-NotFoundException
| | +-ResteasyNotFoundException
| +-NotSupportedException
| | +-ResteasyNotSupportedException
+-RedirectionException
| +-ResteasyRedirectionException
+-ServerErrorException
| +-ResteasyServerErrorException
| +-InternalServerErrorException
| | +-ResteasyInternalServerErrorException
| +-ServiceUnavailableException
| | +-ResteasyServiceUnavailableException
</code></pre>

    <p>The new <code class="classname">Exception</code>s play the same role as the original ones,
   but RESTEasy treats them slightly differently. When a <code class="classname">Client</code> detects
   that it is running in the context of a resource method, it will throw one of the new
   <code class="classname">Exception</code>s. However, instead of storing the original <code class="classname">Response</code>,
   it stores a "sanitized" version of the <code class="classname">Response</code>, in which only the status and
   the Allow and Content-Type headers are preserved. The original <code class="classname">WebApplicationException</code>,
   and therefore the original <code class="classname">Response</code>, can be accessed in one of two ways:</p>
   
   <pre><code class="no-highlight">
// Create a NotAcceptableException.
NotAcceptableException nae = new NotAcceptableException(Response.status(406).entity("ooops").build());

// Wrap the NotAcceptableException in a ResteasyNotAcceptableException.
ResteasyNotAcceptableException rnae = (ResteasyNotAcceptableException) WebApplicationExceptionWrapper.wrap(nae);

// Extract the original NotAcceptableException using instance method.
NotAcceptableException nae2 = rnae.unwrap();
Assert.assertEquals(nae, nae2);

// Extract the original NotAcceptableException using class method.
NotAcceptableException nae3 = (NotAcceptableException) WebApplicationExceptionWrapper.unwrap(nae); // second way
Assert.assertEquals(nae, nae3);
   </code></pre>
   
   <p>Note that this change is intended to introduce a safe default behavior in the case that
   the <code class="classname">Exception</code> generated by the remote call is allowed to make its way up
   to the server runtime. It is considered a good practice, though, to catch the 
   <code class="classname">Exception</code> and treat it in some appropriate manner:</p>
   
<pre><code class="no-highlight">
   @GET
   @Path("remote/{i}")
   public String remote(@PathParam("i") String i) throws Exception {
      Client client = ClientBuilder.newClient();
      try {
         return client.target("http://remote.com/exception/" + i).request().get(String.class);
      } catch (WebApplicationException wae) {
         ...
      }
   }
</code></pre>

   <p><span class="bold"><strong>Note.</strong></span> While RESTEasy will default to the new, safer behavior, the original behavior can
   be restored by setting the configuration parameter "resteasy.original.webapplicationexception.behavior"
   to "true".</p>
</section>

<section class="sect1" id="overring_resteasy_exceptions"><div class="titlepage"><div><div><h2 class="title">30.4. Overriding RESTEasy Builtin Exceptions</h2></div></div></div>
   
   <p>You may override RESTEasy built-in exceptions by writing an ExceptionMapper for the exception.  For that matter, you can write an ExceptionMapper
   for any thrown exception including WebApplicationException</p>
</section>
</section>

   <section class="chapter" id="Configuring_Individual_JAX-RS_Resource_Beans"><div class="titlepage"><div><div><h1 class="title">Chapter 31. Configuring Individual JAX-RS Resource Beans</h1></div></div></div>


<p>


</p>
<p>

If you are scanning your path for JAX-RS annotated resource beans, your beans will be registered in per-request mode.  This means an instance will be created per HTTP request served.  Generally, you will need information from your environment.  If you are running within a servlet container using the WAR-file distribution, in 1.0.0.Beta-2 and lower, you can only use the JNDI lookups to obtain references to Java EE resources and configuration information.  In this case, define your EE configuration (i.e. ejb-ref, env-entry, persistence-context-ref, etc...) within web.xml of the resteasy WAR file.  Then within your code do jndi lookups in the java:comp namespace.  For example:
</p>
<p>

web.xml
</p><pre><code class="no-highlight">

&lt;ejb-ref&gt;
  &lt;ejb-ref-name&gt;ejb/foo&lt;/ejb-ref-name&gt;
  ...
&lt;/ejb-ref&gt;

</code></pre><p>
</p>
<p>

resource code:
</p><pre><code class="no-highlight">
@Path("/")
public class MyBean {

   public Object getSomethingFromJndi() {
      new InitialContext.lookup("java:comp/ejb/foo");
   }
...
}
</code></pre><p>
</p>
<p>


</p>
<p>

You can also manually configure and register your beans through the Registry.  To do this in a WAR-based deployment, you need to write a specific ServletContextListener to do this.  Within the listener, you can obtain a reference to the registry as follows:
</p>
<p>

</p><pre><code class="no-highlight">

public class MyManualConfig implements ServletContextListener
{
   public void contextInitialized(ServletContextEvent event)
   {

      Registry registry = (Registry) event.getServletContext().getAttribute(Registry.class.getName());

   }
...
}

</code></pre><p>
</p>
<p>

Please also take a look at our Spring Integration as well as the Embedded Container's Spring Integration
</p>
<p>

</p>
<p>


</p>
</section>

    <section class="chapter" id="gzip"><div class="titlepage"><div><div><h1 class="title">Chapter 32. Content encoding</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="sect1"><a href="#d5e2188">32.1. GZIP Compression/Decompression</a></span><ul><li><span class="sect2"><a href="#configuring">32.1.1. Configuring GZIP compression / decompression</a></span></li></ul></li><li><span class="sect1"><a href="#d5e2232">32.2. General content encoding</a></span></li></ul></div>
   
   
<section class="sect1" id="d5e2188"><div class="titlepage"><div><div><h2 class="title">32.1. GZIP Compression/Decompression</h2></div></div></div>
   
   <p>
    RESTEasy supports (though not by default - see below)
    GZIP decompression.  If properly configured,
    the client framework or a JAX-RS service, upon receiving
    a message body with a Content-Encoding of "gzip",
    will automatically decompress it.  The client framework can
    (though not by default - see below) automatically
    set the Accept-Encoding header to be "gzip, deflate" so you do not
    have to set this header yourself.
    </p>
    <p>RESTEasy also supports (though not by default - see below) automatic
    compression.  If the client framework is sending a request
    or the server is sending a response with the Content-Encoding header
    set to "gzip", RESTEasy will (if properly configured)
    do the compression. So that you do not
    have to set the Content-Encoding header directly, you can use the
    @org.jboss.resteasy.annotation.GZIP annotation.
   </p>
<pre><code class="no-highlight">
@Path("/")
public interface MyProxy {

   @Consumes("application/xml")
   @PUT
   public void put(@GZIP Order order);
}
</code></pre>
   <p>In the above example, we tag the outgoing message body, order, to
   be gzip compressed.  You can use the same annotation to tag server responses
   </p>
<pre><code class="no-highlight">
@Path("/")
public class MyService {

   @GET
   @Produces("application/xml")
   @GZIP
   public String getData() {...}
}
</code></pre>

<section class="sect2" id="configuring"><div class="titlepage"><div><div><h3 class="title">32.1.1. Configuring GZIP compression / decompression</h3></div></div></div>
   
   
   <p><span class="bold"><strong>Note.</strong></span> Decompression carries a risk of attack
   from a bad actor that can package an entity that will expand greatly. Consequently,
   RESTEasy disables GZIP compression / decompression by default.
   </p>
   
   <p>
   There are three interceptors that are relevant to GZIP compression / decompression:
   </p>
   
   <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">org.jboss.resteasy.plugins.interceptors.GZIPDecodingInterceptor:
      If the Content-Encoding header is present and has the value "gzip",
      <code class="classname">GZIPDecodingInterceptor</code> will install an <code class="classname">InputStream</code>
      that decompresses the message body.
      </li><li class="listitem">org.jboss.resteasy.plugins.interceptors.GZIPEncodingInterceptor:
      If the Content-Encoding header is present and has the value "gzip",
      <code class="classname">GZIPEncodingInterceptor</code> will install an <code class="classname">OutputStream</code>
      that compresses the message body.
      </li><li class="listitem">org.jboss.resteasy.plugins.interceptors.AcceptEncodingGZIPFilter: 
      If the Accept-Encoding header does not exist, <code class="classname">AcceptEncodingGZIPFilter</code>
      will add Accept-Encoding with the value "gzip, deflate". If the Accept-Encoding header exists but
      does not contain "gzip", <code class="classname">AcceptEncodingGZIPFilter</code> will append ", gzip".
      Note that enabling GZIP compression / decompression does not depend on the presence of this
      interceptor.
      </li></ol></div>
   
   <p>
   If GZIP decompression is enabled, an upper limit is imposed on the number of bytes
   <code class="classname">GZIPDecodingInterceptor</code> will extract from a compressed message body.
   The default limit is 10,000,000, but a different value can be configured. See below.
   </p>
   
   <section class="sect3" id="d5e2212"><div class="titlepage"><div><div><h4 class="title">32.1.1.1. Server side configuration</h4></div></div></div>
   
   
   <p>
   The interceptors may be enabled by including their classnames in a
   META-INF/services/javax.ws.rs.ext.Providers file on the classpath. The upper limit on deflated files may
   be configured by setting the parameter "resteasy.gzip.max.input".
   [See <a class="xref" href="#microprofile_config" title="3.4. Configuration">Section 3.4, “Configuration”</a> for more information about application configuration.]
   If the limit is exceeded on the server side, GZIPDecodingInterceptor will return a 
   <code class="classname">Response</code> with status 413 ("Request Entity Too Large") and
   a message specifying the upper limit.
   </p>
   
   <p>
   <span class="bold"><strong>Note.</strong></span>
   As of release 3.1.0.Final, the GZIP interceptors have moved from package 
   <code class="classname">org.jboss.resteasy.plugins.interceptors.encoding</code> to
   <code class="classname">org.jboss.resteasy.plugins.interceptors</code>. and they should be
   named accordingly in javax.ws.rs.ext.Providers.
   </p>

   </section>
   
   <section class="sect3" id="d5e2221"><div class="titlepage"><div><div><h4 class="title">32.1.1.2. Client side configuration</h4></div></div></div>
   
   
   <p>
   The interceptors may be enabled by registering them with, for example, a
   <code class="classname">Client</code> or <code class="classname">WebTarget</code>. For example,
   </p>
   
<pre><code class="no-highlight">
Client client = ClientBuilder.newBuilder() // Activate gzip compression on client:
                    .register(AcceptEncodingGZIPFilter.class)
                    .register(GZIPDecodingInterceptor.class)
                    .register(GZIPEncodingInterceptor.class)
                    .build();
</code></pre>

   <p>
   The upper limit on deflated files may configured by creating an instance of
   <code class="classname">GZIPDecodingInterceptor</code> with a specific value:
   </p>
   
<pre><code class="no-highlight">
Client client = ClientBuilder.newBuilder() // Activate gzip compression on client:
                    .register(AcceptEncodingGZIPFilter.class)
                    .register(new GZIPDecodingInterceptor(256))
                    .register(GZIPEncodingInterceptor.class)
                    .build();
</code></pre>
   <p>
   If the limit is exceeded on the client side, GZIPDecodingInterceptor will throw a
   <code class="classname">ProcessingException</code> with a message specifying the upper limit.
   </p>
   
   </section>
</section>
</section>

<section class="sect1" id="d5e2232"><div class="titlepage"><div><div><h2 class="title">32.2. General content encoding</h2></div></div></div>
   
   
   <p>
   The designation of a compressible entity by the use of the <code class="classname">@GZIP</code> annotation is a
   built in, specific instance of a more general facility supported by RESTEasy.  There are three components
   to this facility.
   </p>
   
   <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
      The annotation <code class="classname">org.jboss.resteasy.annotations.ContentEncoding</code> is a "meta-annotation"
      used on other annotations to indicate that they represent a Content-Encoding. For example, <code class="classname">@GZIP</code>
      is defined
      
      <pre><code class="no-highlight">
@Target({ElementType.TYPE, ElementType.METHOD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@ContentEncoding("gzip")
public @interface GZIP
{
}
      </code></pre>
      The value of <code class="classname">@ContentEncoding</code> indicates the represented Content-Encoding. For <code class="classname">@GZIP</code>
      it is "gzip".
      </li><li class="listitem">
      <code class="classname">ClientContentEncodingAnnotationFeature</code> and
      <code class="classname">ServerContentEncodingAnnotationFeature</code>,
      two <code class="classname">DynamicFeature</code>s 
      in package <code class="classname">org.jboss.resteasy.plugins.interceptors</code>,
      examine resource methods for annotations decorated with <code class="classname">@ContentEncoding</code>.
      </li><li class="listitem">
      For each value found in a <code class="classname">@ContentEncoding</code> decorated annotation on a resource method, an instance of
      <code class="classname">ClientContentEncodingAnnotationFilter</code> or
      <code class="classname">ServerContentEncodingAnnotationFilter</code>,
      <code class="classname">javax.ws.rs.ext.WriterInterceptor</code>s in package
      <code class="classname">org.jboss.resteasy.plugins.interceptors</code>, is registered.
      They are responsible for adding an appropriate Content-Encoding header. For example,
      <code class="classname">ClientContentEncodingAnnotationFilter</code> is defined
      <pre><code class="no-highlight">
@ConstrainedTo(RuntimeType.CLIENT)
@Priority(Priorities.HEADER_DECORATOR)
public class ClientContentEncodingAnnotationFilter implements WriterInterceptor
{
   protected String encoding;

   public ClientContentEncodingAnnotationFilter(String encoding)
   {
      this.encoding = encoding;
   }

   @Override
   public void aroundWriteTo(WriterInterceptorContext context) throws IOException, WebApplicationException
   {
      context.getHeaders().putSingle(HttpHeaders.CONTENT_ENCODING, encoding);
      context.proceed();
   }
}
      </code></pre>
      When it is created, <code class="classname">ClientContentEncodingAnnotationFeature</code> passes in the value
      to be used for Content-Encoding headers.
      </li></ol></div>
   
   <p>
      The annotation <code class="classname">@GZIP</code> is built into RESTEasy, but 
      <code class="classname">ClientContentEncodingAnnotationFeature</code> and <code class="classname">ServerContentEncodingAnnotationFeature</code>
      will also recognize application defined annotations. For example,
   </p>
   
   <pre><code class="no-highlight">
   @Target({ElementType.TYPE, ElementType.METHOD, ElementType.PARAMETER})
   @Retention(RetentionPolicy.RUNTIME)
   @ContentEncoding("compress")
   public @interface Compress
   {
   }
   
   @Path("")
   public static class TestResource {
      
      @GET
      @Path("a")
      @Compress
      public String a() {
         return "a";
      }
   }
   </code></pre>
   
   <p>
      If <code class="methodname">TestResource.a()</code> is invoked as follows
   </p>
   
   <pre><code class="no-highlight">
   @Test
   public void testCompress() throws Exception
   {
      Client client = ClientBuilder.newClient();
      Invocation.Builder request = client.target("http://localhost:8081/a").request();
      request.acceptEncoding("gzip,compress");
      Response response = request.get();
      System.out.println("content-encoding: "+ response.getHeaderString("Content-Encoding"));
      client.close();
   }
   </code></pre>
   
   <p>
      the output will be
   </p>
   
   <pre><code class="no-highlight">
content-encoding: compress
   </code></pre>
</section>
   
</section>

    <section class="chapter" id="d5e2268"><div class="titlepage"><div><div><h1 class="title">Chapter 33. CORS</h1></div></div></div>
    
    <p>
        RESTEasy has a <code class="literal">ContainerRequestFilter</code> that can be used to handle CORS preflight and actual requests.
        <code class="literal">org.jboss.resteasy.plugins.interceptors.CorsFilter</code>.  You must allocate this and register it
        as a singleton provider from your Application class.  See the javadoc or its various settings.
    </p>
<pre><code class="no-highlight">
CorsFilter filter = new CorsFilter();
filter.getAllowedOrigins().add("http://localhost");
</code></pre>
</section>
   <section class="chapter" id="ContentRange"><div class="titlepage"><div><div><h1 class="title">Chapter 34. Content-Range Support</h1></div></div></div>
   
   <p>
      RESTEasy supports <code class="literal">Range</code> requests for <code class="literal">java.io.File</code> response entities.
   </p>
      <pre><code class="no-highlight">
   @Path("/")
   public class Resource {
      @GET
      @Path("file")
      @Produces("text/plain")
      public File getFile()
      {
         return file;
      }
   }

      Response response = client.target(generateURL("/file")).request()
              .header("Range", "1-4").get();
      Assert.assertEquals(response.getStatus(), 206);
      Assert.assertEquals(4, response.getLength());
      System.out.println("Content-Range: " + response.getHeaderString("Content-Range"));


      </code></pre>
</section>

   <section class="chapter" id="Cache_NoCache_CacheControl"><div class="titlepage"><div><div><h1 class="title">Chapter 35. RESTEasy Caching Features</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="sect1"><a href="#Cache_Annotation">35.1. @Cache and @NoCache Annotations</a></span></li><li><span class="sect1"><a href="#client_cache">35.2. Client "Browser" Cache</a></span></li><li><span class="sect1"><a href="#server_cache">35.3. Local Server-Side Response Cache</a></span></li><li><span class="sect1"><a href="#Http_Precondition">35.4. HTTP preconditions</a></span></li></ul></div>
   
   <p>
     RESTEasy provides numerous annotations and facilities to support HTTP caching semantics.  Annotations to make setting Cache-Control
     headers easier and both server-side and client-side in-memory caches are available.
   </p>
  <section class="sect1" id="Cache_Annotation"><div class="titlepage"><div><div><h2 class="title">35.1. @Cache and @NoCache Annotations</h2></div></div></div>
  
   <p>
      RESTEasy provides an extension to JAX-RS that allows you to automatically set Cache-Control headers on a successful
      GET request.  It can only be used on @GET annotated methods.  A successful @GET request is any request
      that returns 200 OK response.
   </p>
   <pre><code class="no-highlight">
package org.jboss.resteasy.annotations.cache;

public @interface Cache
{
   int maxAge() default -1;
   int sMaxAge() default -1;
   boolean noStore() default false;
   boolean noTransform() default false;
   boolean mustRevalidate() default false;
   boolean proxyRevalidate() default false;
   boolean isPrivate() default false;
}

public @interface NoCache
{
   String[] fields() default {};
}

   </code></pre>
   <p>
      While @Cache builds a complex Cache-Control header, @NoCache is a simplified notation to say that you don't
      want anything cached; i.e. Cache-Control: nocache.
   </p>
   <p>
      These annotations can be put on the resource class or interface and specifies a default cache value for each
      @GET resource method.  Or they can be put individually on each @GET resource method.
   </p>
   </section>
   <section class="sect1" id="client_cache"><div class="titlepage"><div><div><h2 class="title">35.2. Client "Browser" Cache</h2></div></div></div>
     
     <p>
        RESTEasy has the ability to set up a client-side, browser-like, cache.  You can use it with the Client Proxy Framework, or with 
        ordinary requests.  This cache looks for Cache-Control headers sent back with a server response.  If the Cache-Control headers specify
       that the client is allowed to cache the response, Resteasy caches it within local memory.  The cache obeys max-age requirements 
       and will also automatically do HTTP 1.1 cache revalidation if either or both the Last-Modified and/or ETag headers are sent back with the
       original response.  See the HTTP 1.1 specification for details on how Cache-Control or cache revalidation works.
     </p>
     <p>It is very simple to enable caching.  Here's an example of using the client cache with the Client Proxy Framework</p>
<pre><code class="no-highlight">
@Path("/orders")
public interface OrderServiceClient {

   @Path("{id}")
   @GET
   @Produces("application/xml")
   public Order getOrder(@PathParam("id") String id);
}
</code></pre>

     <p>To create a proxy for this interface and enable caching for that proxy requires only a few simple steps
     in which the <code class="classname">BrowserCacheFeature</code> is registered:</p>
    
<pre><code class="no-highlight">
ResteasyWebTarget target = (ResteasyWebTarget) ClientBuilder.newClient().target("http://localhost:8081");
BrowserCacheFeature cacheFeature = new BrowserCacheFeature();
OrderServiceClient orderService = target.register(cacheFeature).proxy(OrderServiceClient.class);
</code></pre>

     <p>
     <code class="classname">BrowserCacheFeature</code> will create a Resteasy
     <code class="classname">LightweightBrowserCache</code> by default. It is also possible to configure
     the cache, or install a completely different cache implementation:
     </p>
   
<pre><code class="no-highlight">
ResteasyWebTarget target = (ResteasyWebTarget) ClientBuilder.newClient().target("http://localhost:8081");
LightweightBrowserCache cache = new LightweightBrowserCache();
cache.setMaxBytes(20);
BrowserCacheFeature cacheFeature = new BrowserCacheFeature();
cacheFeature.setCache(cache);
OrderServiceClient orderService = target.register(cacheFeature).proxy(OrderServiceClient.class); 
</code></pre>

   <p>If you are using the standard JAX-RS client framework to make invocations rather than the
   proxy framework, it is just as easy:</p>

<pre><code class="no-highlight">
ResteasyWebTarget target = (ResteasyWebTarget) ClientBuilder.newClient().target("http://localhost:8081/orders/{id}");
BrowserCacheFeature cacheFeature = new BrowserCacheFeature();
target.register(cacheFeature);
String rtn = target.resolveTemplate("id", "1").request().get(String.class);
</code></pre>

   <p>The LightweightBrowserCache, by default, has a maximum 2 megabytes of caching space.  You can change this programmatically by callings
         its setMaxBytes() method.   If the cache gets full, the cache completely wipes itself of all cached data.  This may seem
         a bit draconian, but the cache was written to avoid unnecessary synchronizations in a concurrent environment where the cache is 
         shared between multiple threads.  If you desire a more complex caching solution or if you want to plug in a thirdparty cache
         please contact our resteasy-developers list and discuss it with the community.
   </p>
   </section>
   <section class="sect1" id="server_cache"><div class="titlepage"><div><div><h2 class="title">35.3. Local Server-Side Response Cache</h2></div></div></div>
      
      <p>RESTEasy has a server-side cache that can sit in front of your JAX-RS services.
          It automatically caches marshalled responses from HTTP GET JAX-RS invocations if, and only if your
          JAX-RS resource method sets a Cache-Control header.  When a GET comes in, the RESTEasy Server Cache checks
          to see if the URI is stored in the cache.  If it does, it returns the already marshalled response without
          invoking your JAX-RS method.  Each cache entry has a max age to whatever is specified in the Cache-Control
          header of the initial request.  The cache also will automatically generate an ETag using an MD5 hash on the
          response body.  This allows the client to do HTTP 1.1 cache revalidation with the IF-NONE-MATCH header.
          The cache is also smart enough to perform revalidation if there is no initial cache hit, but the jax-rs
          method still returns a body that has the same ETag.
      </p>
       <p>
         The cache is also automatically invalidated for a particular URI that has
           PUT, POST, or DELETE invoked on it.  You can also obtain a reference to the cache by injecting a
           org.jboss.resteasy.plugins.cache.ServerCache
           via the @Context annotation
       </p>
<pre><code class="no-highlight">

    @Context
    ServerCache cache;

    @GET
    public String get(@Context ServerCache cache) {...}

</code></pre>
      <p>To set up the server-side cache you must register an instance of org.jboss.resteasy.plugins.cache.server.ServerCacheFeature
          via your Application getSingletons() or getClasses() methods.  The underlying cache is Infinispan.  By default,
          RESTEasy will create an Infinispan cache for you.  Alternatively, you can create and pass in an instance
          of your cache to the ServerCacheFeature constructor.  You can also configure Infinispan by specifying
          various parameters.  First, if you are using Maven you must depend on the resteasy-cache-core artifact:</p>
<pre><code class="no-highlight">

&lt;dependency&gt;
   &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
   &lt;artifactId&gt;resteasy-cache-core&lt;/artifactId&gt;
   &lt;version&gt;4.7.10.Final&lt;/version&gt;
&lt;/dependency&gt;

</code></pre>
      <p>The next thing you should probably do is set up the Infinispan configuration. In your web.xml, it would look like</p>
<pre><code class="no-highlight">

&lt;web-app&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;server.request.cache.infinispan.config.file&lt;/param-name&gt;
        &lt;param-value&gt;infinispan.xml&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;context-param&gt;
        &lt;param-name&gt;server.request.cache.infinispan.cache.name&lt;/param-name&gt;
        &lt;param-value&gt;MyCache&lt;/param-value&gt;
    &lt;/context-param&gt;

&lt;/web-app&gt;

</code></pre>
   <p>
       server.request.cache.infinispan.config.file can either be a classpath or a file path. server.request.cache.infinispan.cache.name
       is the name of the cache you want to reference that is declared in the config file.
   </p>
   
   <p>See <a class="xref" href="#microprofile_config" title="3.4. Configuration">Section 3.4, “Configuration”</a> for more information about application configuration. </p>
   
   </section>
   <section class="sect1" id="Http_Precondition"><div class="titlepage"><div><div><h2 class="title">35.4. HTTP preconditions</h2></div></div></div>
        
        <p>
            JAX-RS provides an API for evaluating HTTP preconditions based on <code class="literal">"If-Match"</code>, <code class="literal">"If-None-Match"</code>, <code class="literal">"If-Modified-Since"</code> and <code class="literal">"If-Unmodified-Since"</code> headers.
        </p>
        <pre><code class="no-highlight">
            Response.ResponseBuilder rb = request.evaluatePreconditions(lastModified, etag);
        </code></pre>
        <p>
            By default RESTEasy will return status code 304 (Not modified) or 412 (Precondition failed) if any of conditions fails.
            However it is not compliant with RFC 7232 which states that headers <code class="literal">"If-Match"</code>, <code class="literal">"If-None-Match"</code> MUST have higher precedence.
            You can enable RFC 7232 compatible mode by setting the parameter <code class="literal">resteasy.rfc7232preconditions</code> to <code class="literal">true</code>.
            See <a class="xref" href="#microprofile_config" title="3.4. Configuration">Section 3.4, “Configuration”</a> for more information about application configuration.
        </p>
   </section>
</section>

   <section class="chapter" id="Interceptors"><div class="titlepage"><div><div><h1 class="title">Chapter 36. Filters and Interceptors</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="sect1"><a href="#d5e2333">36.1. Server Side Filters</a></span><ul><li><span class="sect2"><a href="#d5e2338">36.1.1. Asynchronous filters</a></span></li></ul></li><li><span class="sect1"><a href="#d5e2368">36.2. Client Side Filters</a></span></li><li><span class="sect1"><a href="#d5e2372">36.3. Reader and Writer Interceptors</a></span></li><li><span class="sect1"><a href="#d5e2378">36.4. Per Resource Method Filters and Interceptors</a></span></li><li><span class="sect1"><a href="#d5e2382">36.5. Ordering</a></span></li></ul></div>
    
    <p>JAX-RS 2.0 has two different concepts for interceptions: Filters and Interceptors.  Filters are mainly used to
    modify or process incoming and outgoing request headers or response headers.  They execute before and after
    request and response processing.</p>
    <section class="sect1" id="d5e2333"><div class="titlepage"><div><div><h2 class="title">36.1. Server Side Filters</h2></div></div></div>
        
    <p>
        On the server-side you have two different types of filters.  ContainerRequestFilters
        run before your JAX-RS resource method is invoked.  ContainerResponseFilters run after your JAX-RS resource method
        is invoked.  As an added caveat, ContainerRequestFilters come in two flavors:  pre-match and post-matching.  Pre-matching
        ContainerRequestFilters are designated with the @PreMatching annotation and will execute before the JAX-RS resource
        method is matched with the incoming HTTP request.  Pre-matching filters often are used to modify request attributes
        to change how it matches to a specific resource method (i.e. strip .xml and add an Accept header).  ContainerRequestFilters can abort the request by calling ContainerRequestContext.abortWith(Response).  A filter
        might want to abort if it implements a custom authentication protocol.
    </p>
    <p>
          After the resource class method is executed, JAX-RS will run all ContainerResponseFilters.  These filters
        allow you to modify the outgoing response before it is marshalling and sent to the client.
        So given all that, here's some pseudo
        code to give some understanding of how things work.
    </p>
    <pre><code class="no-highlight">
        // execute pre match filters
        for (ContainerRequestFilter filter : preMatchFilters) {
            filter.filter(requestContext);
            if (isAborted(requestContext)) {
               sendAbortionToClient(requestContext);
               return;
            }
        }
        // match the HTTP request to a resource class and method
        JaxrsMethod method = matchMethod(requestContext);

        // Execute post match filters
        for (ContainerRequestFilter filter : postMatchFilters) {
           filter.filter(requestContext);
           if (isAborted(requestContext)) {
              sendAbortionToClient(requestContext);
              return;
           }
        }

        // execute resource class method
        method.execute(request);

        // execute response filters
        for (ContainerResponseFilter filter : responseFilters) {
           filter.filter(requestContext, responseContext);
        }
    </code></pre>
    <section class="sect2" id="d5e2338"><div class="titlepage"><div><div><h3 class="title">36.1.1. Asynchronous filters</h3></div></div></div>
        
        <p>
            It is possible to turn filters into asynchronous filters, if you need to suspend execution of your filter
            until a certain resource has become available. This turns the request asynchronous, but requires no change
            to your resource method declaration. In particular, <a class="link" href="#Asynchronous_HTTP_Request_Processing" title="Chapter 37. Asynchronous HTTP Request Processing">synchronous
            and asynchronous resource methods</a> continue
            to work as specified, regardless of whether or not a filter turned the request asynchronous. Similarly,
            one filter turning the request asynchronous requires no change in the declaration of further filters.
        </p>
        <p>
            In order to turn a filter's execution asynchronous, you need to cast the <code class="code">ContainerRequestContext</code> into
            a <code class="code">SuspendableContainerRequestContext</code> (for pre/post request filters), or cast the <code class="code">ContainerResponseContext</code> into
            a <code class="code">SuspendableContainerResponseContext</code> (for response filters). 
        </p>
        <p>
            These context objects can turn the current filter's execution to asynchronous by calling the <code class="code">suspend()</code>
            method. Once asynchronous, the filter chain is suspended, and will only resume after one of the following method
            is called on the context object:
        </p>
        <div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="code">abortWith(Response)</code></span></dt><dd>Terminate the filter chain, return the given <code class="code">Response</code> to the client (only for <code class="code">ContainerRequestFilter</code>).</dd><dt><span class="term"><code class="code">resume()</code></span></dt><dd>Resume execution of the filter chain by calling the next filter.</dd><dt><span class="term"><code class="code">resume(Throwable)</code></span></dt><dd>
                    Abort execution of the filter chain by throwing the given exception. This behaves as if the filter were synchronous
                    and threw the given exception.
                </dd></dl></div>
        <p>
            You can also do async processing inside your <code class="code">AsyncWriterInterceptor</code> (if you are using
            <a class="link" href="#Asynchronous_IO" title="37.4. Asynchronous IO">Async IO</a>), which is the asynchronous-supporting equivalent to
            <code class="code">WriterInterceptor</code>. In this case, you don't need to manually suspend or resume the request.
        </p>
    </section>
    </section>
    <section class="sect1" id="d5e2368"><div class="titlepage"><div><div><h2 class="title">36.2. Client Side Filters</h2></div></div></div>
        
        <p>
            On the client side you also have two types of filters: ClientRequestFilter and ClientResponseFilter.
            ClientRequestFilters run before your HTTP request is sent over the wire to the server.  ClientResponseFilters
            run after a response is received from the server, but before the response body is unmarshalled.  ClientRequestFilters
            are also allowed to abort the execute of the request and provide a canned response without going over the
            wire to the server.  ClientResponseFilters can modfiy the Response object before it is handed back to
            application code.  Here's some pseudo code to illustrate things.
        </p>
        <pre><code class="no-highlight">
            // execute request filters
            for (ClientRequestFilter filter : requestFilters) {
               filter.filter(requestContext);
               if (isAborted(requestContext)) {
                  return requestContext.getAbortedResponseObject();
               }
            }

            // send request over the wire
            response = sendRequest(request);

            // execute response filters
            for (ClientResponseFilter filter : responseFilters) {
               filter.filter(requestContext, responseContext);
            }
        </code></pre>
    </section>
    <section class="sect1" id="d5e2372"><div class="titlepage"><div><div><h2 class="title">36.3. Reader and Writer Interceptors</h2></div></div></div>
        
        <p>
            While filters modify request or response headers, interceptors deal with message bodies.  Interceptors are executed
            in the same call stack as their corresponding reader or writer.  ReaderInterceptors
            wrap around the execution of MessageBodyReaders.  WriterInterceptors wrap around the execution of MessageBodyWriters.
            They can be used to implement a specific content-encoding.  They can be used to generate digital signatures or
            to post or pre-process a Java object model before or after it is marshalled.
        </p>
        <p>
            Note that in order to support Async IO, you can implement <code class="code">AsyncWriterInterceptor</code>, which is a subtype of
            <code class="code">WriterInterceptor</code>.
        </p>
    </section>
    <section class="sect1" id="d5e2378"><div class="titlepage"><div><div><h2 class="title">36.4. Per Resource Method Filters and Interceptors</h2></div></div></div>
        
        <p>
            Sometimes you want a filter or interceptor to only run for a specific resource method.  You can do this in two different
            ways:  register an implementation of DynamicFeature or use the @NameBinding annotation.  The DynamicFeature
            interface is executed at deployment time for each resource method.  You just use the Configurable interface
            to register the filters and interceptors you want for the specific resource method.  @NameBinding works a lot
            like CDI interceptors.  You annotate a custom annotation with @NameBinding and then apply that custom annotation
            to your filter and resource method. The custom annotation must use @Retention(RetentionPolicy.RUNTIME) in order for the
            attribute to be picked up by the RESTEasy runtime code when it is deployed.
        </p>
        <pre><code class="no-highlight">
            @NameBinding
            @Retention(RetentionPolicy.RUNTIME)
            public @interface DoIt {}

            @DoIt
            public class MyFilter implements ContainerRequestFilter {...}

            @Path("/root")
            public class MyResource {

               @GET
               @DoIt
               public String get() {...}
            }
        </code></pre>
    </section>
    <section class="sect1" id="d5e2382"><div class="titlepage"><div><div><h2 class="title">36.5. Ordering</h2></div></div></div>
        
        <p>
            Ordering is accomplished by using the @BindingPriority annotation on your filter or interceptor class.
        </p>
    </section>

</section>

   <section class="chapter" id="Asynchronous_HTTP_Request_Processing"><div class="titlepage"><div><div><h1 class="title">Chapter 37. Asynchronous HTTP Request Processing</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="sect1"><a href="#d5e2388">37.1. Using the <code class="code">@Suspended</code> annotation</a></span></li><li><span class="sect1"><a href="#d5e2403">37.2. Using Reactive return types</a></span></li><li><span class="sect1"><a href="#d5e2417">37.3. Asynchronous filters</a></span></li><li><span class="sect1"><a href="#Asynchronous_IO">37.4. Asynchronous IO</a></span></li></ul></div>
   
   <p>
      Asynchronous HTTP Request Processing is a relatively new technique that allows you to process a single HTTP
      request using non-blocking I/O and, if desired in separate threads. Some refer to it as COMET capabilities.
      The primary use case for Asynchronous HTTP is
      in the case where the client is polling the server for a delayed response. The usual example is an AJAX chat
      client where you want to push/pull from both the client and the server. These scenarios have the client blocking
      a long time on the server’s socket waiting for a new message. What happens in synchronous HTTP where the server is
      blocking on incoming and outgoing I/O is that you end up having a thread consumed per client connection.
      This eats up memory and valuable thread resources. Not such a big deal in 90% of applications (in fact using
      asynchronous processing may actually hurt your performance in most common scenarios), but when you start
      getting a lot of concurrent clients that are blocking like this, there’s a lot of wasted resources and your
      server does not scale that well.
   </p>
   <section class="sect1" id="d5e2388"><div class="titlepage"><div><div><h2 class="title">37.1. Using the <code class="code">@Suspended</code> annotation</h2></div></div></div>
      
      <p>
         The JAX-RS 2.0 specification has added asynchronous HTTP support via two classes.  The <code class="code">@Suspended</code> annotation,
         and AsyncResponse interface.
      </p>
      <p>
          Injecting an AsynchronousResponse as a parameter to your jax-rs methods tells RESTEasy that the HTTP request/response should be detached from the currently
         executing thread and that the current thread should not try to automatically process the response.
      </p>
      <p>
         The AsyncResponse is the callback object.
         The act of calling one of the resume() methods will cause a response to be sent back to the client and will also terminate the
         HTTP request. Here is an example of asynchronous processing:
      </p>
   
      <pre><code class="no-highlight">
import javax.ws.rs.Suspend;
import javax.ws.rs.core.AsynchronousResponse;

@Path("/")
public class SimpleResource
{

   @GET
   @Path("basic")
   @Produces("text/plain")
   public void getBasic(@Suspended final AsyncResponse response) throws Exception
   {
      Thread t = new Thread()
      {
         @Override
         public void run()
         {
            try
            {
               Response jaxrs = Response.ok("basic").type(MediaType.TEXT_PLAIN).build();
               response.resume(jaxrs);
            }
            catch (Exception e)
            {
               response.resume(e);
            }
         }
      };
      t.start();
   }
}
      </code></pre>
      <p>
         AsyncResponse also has other methods to cancel the execution.  See javadoc for more details.
      </p>
      <p>
         <span class="bold"><strong>NOTE:</strong></span> The old RESTEasy proprietary API for async http has been deprecated and may be removed as soon as RESTEasy 3.1.
         In particular, the RESTEasy @Suspend annotation is replaced by <code class="classname">javax.ws.rs.container.Suspended</code>, and
         <code class="classname">org.jboss.resteasy.spi.AsynchronousResponse</code> is replaced by
         <code class="classname">javax.ws.rs.container.AsyncResponse</code>. Note that @Suspended does not have a value field,
         which represented a timeout limit. Instead, <code class="methodname">AsyncResponse.setTimeout()</code> may be called.
      </p>
   </section>
   <section class="sect1" id="d5e2403"><div class="titlepage"><div><div><h2 class="title">37.2. Using Reactive return types</h2></div></div></div>
      
      <p id="CompletionStage">
          The JAX-RS 2.1 specification adds support for declaring asynchronous resource methods by
          returning a <code class="code">CompletionStage</code> instead of using the <code class="code">@Suspended</code>
          annotation.
      </p>
      <p>
          Whenever a resource method returns a <code class="code">CompletionStage</code>, it will be subscribed to,
          the request will be suspended, and only resumed when the <code class="code">CompletionStage</code> is
          resolved either to a value (which is then treated as the return value for the method), or
          as an error case, in which case the exception will be processed as if it were thrown by the
          resource method.
      </p>
      <p>
          Here is an example of asynchronous processing using <code class="code">CompletionStage</code>:
      </p>
      <pre><code class="no-highlight">
import javax.ws.rs.Suspend;
import javax.ws.rs.core.AsynchronousResponse;

@Path("/")
public class SimpleResource
{

   @GET
   @Path("basic")
   @Produces("text/plain")
   public CompletionStage&lt;Response&gt; getBasic() throws Exception
   {
      final CompletableFuture&lt;Response&gt; response = new CompletableFuture&lt;&gt;();
      Thread t = new Thread()
      {
         @Override
         public void run()
         {
            try
            {
               Response jaxrs = Response.ok("basic").type(MediaType.TEXT_PLAIN).build();
               response.complete(jaxrs);
            }
            catch (Exception e)
            {
               response.completeExceptionally(e);
            }
         }
      };
      t.start();
      return response;
   }
}
     </code></pre>
     <div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2>
        <p>
           RESTEasy <a class="link" href="#Reactive" title="Chapter 40. Reactive programming support">supports more reactive types for asynchronous programming</a>.
        </p>
     </div>
   </section>
   <section class="sect1" id="d5e2417"><div class="titlepage"><div><div><h2 class="title">37.3. Asynchronous filters</h2></div></div></div>
      
      <p>
         It is possible to write <a class="link" href="#Asynchronous_Filter">filters that also turn the request asynchronous</a>. 
         Whether or not filters turned the request asynchronous
         before execution of your method makes absolutely no difference to your method: it does not need to be declared asynchronous in
         order to function as specified. Synchronous methods and asynchronous methods will work as specified by the spec.
      </p>
    </section>
   <section class="sect1" id="Asynchronous_IO"><div class="titlepage"><div><div><h2 class="title">37.4. Asynchronous IO</h2></div></div></div>
      
      <p>
         Some backends support asynchronous IO operations (Servlet, Undertow, Vert.x, Quarkus, Netty), which are exposed using the
         <code class="code">AsyncOutputStream</code> subtype of <code class="code">OutputStream</code>. It includes async variants for writing and flushing
         the stream.
      </p>
      <p>
         Some backends have what is called an "Event Loop Thread", which is a thread responsible for doing all IO operations. Those
         backends require the Event Loop Thread to never be blocked, because it does IO for every other thread. Those backends
         typically require JAX-RS endpoints to be invoked on worker threads, to make sure they never block the Event Loop Thread.
      </p>
      <p>
         Sometimes, with Async programming, it is possible for asynchronous JAX-RS requests to be resumed from the Event Loop Thread.
         As a result, JAX-RS will attempt to serialise the response and send it to the client. But JAX-RS is written using "Blocking IO"
         mechanics, such as <code class="code">OutputStream</code> (used by <code class="code">MessageBodyWriter</code> and <code class="code">WriterInterceptor</code>), which
         means that sending the response will block the current thread until the response is received. This would work on a worker thread,
         but if it happens on the Event Loop Thread it will block it and prevent it from sending the response, resulting in a deadlock.
      </p>
      <p>
         As a result, we've decided to support and expose Async IO interfaces in the form of <code class="code">AsyncOutputStream</code>,
         <code class="code">AsyncMessageBodyWriter</code> and <code class="code">AsyncWriterInterceptor</code>, to allow users to write Async IO applications
         in RESTEasy.
      </p>
      <p>
         Most built-in <code class="code">MessageBodyWriter</code> and <code class="code">WriterInterceptor</code> support Async IO, with the notable exceptions of:
      </p>
      <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="code">HtmlRenderableWriter</code>, which is tied to servlet APIs</p></li><li class="listitem"><p><code class="code">ReaderProvider</code></p></li><li class="listitem"><p><code class="code">StreamingOutputProvider</code>: use <code class="code">AsyncStreamingOutput</code> instead</p></li><li class="listitem"><p><code class="code">GZIPEncodingInterceptor</code></p></li></ul></div>
      <p>
         Async IO will be preferred if the following conditions are met:
      </p>
      <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The backend supports it</p></li><li class="listitem"><p>The writer supports it</p></li><li class="listitem"><p>All writer interceptors support it</p></li></ul></div>
      <p>
         If those conditions are not met, and you attempt to use Blocking IO on an Event Loop Thread (as determined by the
         backend), then an exception will be thrown.
      </p>
    </section>
</section>
   <section class="chapter" id="async_job_service"><div class="titlepage"><div><div><h1 class="title">Chapter 38. Asynchronous Job Service</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="sect1"><a href="#async_job">38.1. Using Async Jobs</a></span></li><li><span class="sect1"><a href="#oneway">38.2. Oneway: Fire and Forget</a></span></li><li><span class="sect1"><a href="#async_job_setup">38.3. Setup and Configuration</a></span></li></ul></div>
   
   <p>
      The RESTEasy Asynchronous Job Service is an implementation of the Asynchronous Job pattern defined in O'Reilly's "Restful Web Services" book.  The idea of it is to bring asynchronicity to a synchronous protocol.
   </p>
   <section class="sect1" id="async_job"><div class="titlepage"><div><div><h2 class="title">38.1. Using Async Jobs</h2></div></div></div>
     
      <p>While HTTP is a synchronous protocol
      it does have a faint idea of asynchronous invocations.  The HTTP 1.1 response code 202, "Accepted" means that the server
      has received and accepted the response for processing, but the processing has not yet been completed.  The RESTEasy 
      Asynchronous Job Service builds around this idea.
   </p>
<pre><code class="no-highlight">
POST http://example.com/myservice?asynch=true
</code></pre>
   <p>
    For example, if you make the above post with the asynch query parameter set to true, RESTEasy will return a 202, "Accepted" response code and run the invocation in the background.  It also sends back a Location header with a URL pointing to where the response of the background method is located.
   </p>
<pre><code class="no-highlight">
HTTP/1.1 202 Accepted
Location: http://example.com/asynch/jobs/3332334
</code></pre>
   <p>
   The URI will have the form of:
   </p>
<pre><code class="no-highlight">
/asynch/jobs/{job-id}?wait={millisconds}|nowait=true
</code></pre>
   <p>You can perform the GET, POST, and DELETE operations on this job URL.  GET returns whatever the JAX-RS resource method you invoked
   returned as a response if the job was completed.  If the job has not completed, this GET will return a response code of 202, Accepted.  Invoking GET does not remove the job, so you can call it multiple times.  When RESTEasy's job queue gets full, it will evict
the least recently used job from memory.  You can manually clean up after yourself by calling DELETE on the URI.  POST does
a read of the JOB response and will remove the JOB it has been completed.
</p>
   <p>Both GET and POST allow you to specify a maximum
wait time in milliseconds, a "wait" query parameter.  Here's an example:
</p>
<pre><code class="no-highlight">
POST http://example.com/asynch/jobs/122?wait=3000
</code></pre>
   <p>  If you do not specify a "wait" parameter, the GET or POST will not wait at all if the job is not complete.</p>
   <p>  NOTE!!  While you can invoke GET, DELETE, and PUT methods asynchronously, this breaks the HTTP 1.1 contract of these methods.  While these invocations may not change the state of the resource if invoked more than once, they do change the state of the server as new Job entries with each invocation.  If you want to be a purist, stick with only invoking POST methods asynchronously.
   </p>
   <p> Security NOTE!  RESTEasy role-based security (annotations) does not work with the Asynchronous Job Service.  You must use
   XML declarative security within your web.xml file. Why? It is impossible to implement role-based security portably.  In the future, we may have specific JBoss integration, but will not support other environments.</p>
   <p>NOTE. A <code class="classname">SecureRandom</code> object is used to generate unique job ids. For security purposes, the
   <code class="classname">SecureRandom</code> is periodically reseeded. By default, it is reseeded after 100 uses. This value
   may be configured with the servlet init parameter "resteasy.secure.random.max.use".
   </p>
   </section>
   <section class="sect1" id="oneway"><div class="titlepage"><div><div><h2 class="title">38.2. Oneway: Fire and Forget</h2></div></div></div>
      
      <p>
         RESTEasy also supports the notion of fire and forget.  This will also return a 202, Accepted response, but no Job will
         be created.  This is as simple as using the oneway query parameter instead of asynch.  For example:
      </p>
<pre><code class="no-highlight">
POST http://example.com/myservice?oneway=true
</code></pre>
   <p> Security NOTE!  RESTEasy role-based security (annotations) does not work with the Asynchronous Job Service.  You must use
   XML declaritive security within your web.xml file. Why? It is impossible to implement role-based security portably.  In the future, we may have specific JBoss integration, but will not support other environments.</p>
   </section>
   <section class="sect1" id="async_job_setup"><div class="titlepage"><div><div><h2 class="title">38.3. Setup and Configuration</h2></div></div></div>
     
     <p>You must enable the Asynchronous Job Service, as it is not turned on by default. If the relevant configuration properties are configured
     in web.xml, it would look like the following: </p>
<pre><code class="no-highlight">

&lt;web-app&gt;
    &lt;!-- enable the Asynchronous Job Service --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.async.job.service.enabled&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;!-- The next context parameters are all optional.  
         Their default values are shown as example param-values --&gt;

    &lt;!-- How many jobs results can be held in memory at once? --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.async.job.service.max.job.results&lt;/param-name&gt;
        &lt;param-value&gt;100&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;!-- Maximum wait time on a job when a client is querying for it --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.async.job.service.max.wait&lt;/param-name&gt;
        &lt;param-value&gt;300000&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;!-- Thread pool size of background threads that run the job --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.async.job.service.thread.pool.size&lt;/param-name&gt;
        &lt;param-value&gt;100&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;!-- Set the base path for the Job uris --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.async.job.service.base.path&lt;/param-name&gt;
        &lt;param-value&gt;/asynch/jobs&lt;/param-value&gt;
    &lt;/context-param&gt;

    ...
&lt;/web-app&gt;

</code></pre>

   <p>See <a class="xref" href="#microprofile_config" title="3.4. Configuration">Section 3.4, “Configuration”</a> for more information about application configuration.</p>
   </section>
</section>

   <section class="chapter" id="Async_Injection"><div class="titlepage"><div><div><h1 class="title">Chapter 39. Asynchronous Injection</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="sect1"><a href="#ContextInjector_Interface">39.1. org.jboss.resteasy.spi.ContextInjector Interface</a></span></li><li><span class="sect1"><a href="#Single_foo_example">39.2. Single&lt;Foo&gt; Example</a></span></li><li><span class="sect1"><a href="#injectory_with_annotations_example">39.3. Async Injector With Annotations Example</a></span></li></ul></div>
    
    <p>
        Pluggable Asynchronous Injection, also referred to as Asynch Injection, is a
        feature that allows users to create custom injectable asynchronous types.
        For example it is now possible to declare an injector for <code class="classname">Single&lt;Foo&gt;</code>
        and inject it into an endpoint as a class variable or as a method parameter using
        <code class="classname">@Context Foo</code>.  The response will be made asynchronous automatically and
        the resource method will only be invoked once the <code class="classname">Single&lt;Foo&gt;</code> object is
        resolved to <code class="classname">Foo</code>.  Resolution is done in a non-blocking manner.
    </p>
    <p>
        <span class="bold"><strong>Note.</strong></span>
        Asynch injection is only attempted at points where asynchronous injection is
        permitted, such as on resource creation and resource method invocation. It
        is not enabled at points where the API does not allow for suspending the
        request, for example on <code class="classname">ResourceContext.getResource(Foo.class)</code>.
    </p>
    <section class="sect1" id="ContextInjector_Interface"><div class="titlepage"><div><div><h2 class="title">39.1. org.jboss.resteasy.spi.ContextInjector Interface</h2></div></div></div>
        
        <p>
            The <code class="classname">org.jboss.resteasy.spi.ContextInjector</code> interface must be implemented
            on any custom asynch injector object.  The implementation class must be
            tagged with the <code class="classname">@Provider</code> annotation.
        </p>
        <pre><code class="no-highlight">
/**
 * @param &lt;WrappedType&gt; A class that wraps a data type or data object
 *                            (e.g. Single&lt;Foo&gt;)
 * @param &lt;UnwrappedType&gt; The data type or data object declared in the
 *                              WrappedType (e.g. Foo)
*/
public interface ContextInjector&lt;WrappedType, UnwrappedType&gt; {
/**
 * This interface allows users to create custom injectable asynchronous types.
 *
 * Asynch injection is only attempted at points where asynchronous injection is
 * permitted, such as on resource creation and resource method invocation. It
 * is not enabled at points where the API does not allow for suspending the
 * request
 *
 * @param rawType
 * @param genericType
 * @param annotations The annotation list is useful to parametrize the injection.
 * @return
 */
 public WrappedType resolve(
            Class&lt;? extends WrappedType&gt; rawType,
            Type genericType,
            Annotation[] annotations);
  }
        </code></pre>
   </section>
    <section class="sect1" id="Single_foo_example"><div class="titlepage"><div><div><h2 class="title">39.2. Single&lt;Foo&gt; Example</h2></div></div></div>
    
        <pre><code class="no-highlight">
package my.test;

public class Foo {
   private String value = "PRE-SET-VALUE";

   public void setValue(String s) {
      this.value = s;
   }

   public String getValue() {
      return this.value;
   }
}
        </code></pre>
        <pre><code class="no-highlight">
package my.test.asyc.resources;

import io.reactivex.Single;
import javax.ws.rs.ext.Provider;
import org.jboss.resteasy.spi.ContextInjector;
import my.test.Foo;

@Provider
public class FooAsychInjectorProvider implements
            ContextInjector&lt;Single&lt;Foo&gt;,Foo&gt; {

   public Single&lt;Foo&gt; resolve(Class&lt;? extends Single&lt;Foo&gt;&gt; rawType,
            Type genericType,
            Annotation[] annotations)
   {
      Foo value = new Foo();
      return Single.just(value.setValue("made it"));
   }
}
        </code></pre>
    </section>
    <section class="sect1" id="injectory_with_annotations_example"><div class="titlepage"><div><div><h2 class="title">39.3. Async Injector With Annotations Example</h2></div></div></div>
    
        <p>
            A convenience interface to provide annotation parameter designators
        </p>
    <pre><code class="no-highlight">
@Retention(RUNTIME)
@Target({ FIELD, METHOD, PARAMETER })
public @interface AsyncInjectionPrimitiveInjectorSpecifier
{
   public enum Type {
      VALUE, NULL, NO_RESULT;
   }

   Type value() default Type.VALUE;
}
    </code></pre>
        <pre><code class="no-highlight">

@Provider
public class AsyncInjectionFloatInjector implements
            ContextInjector&lt;CompletionStage&lt;Float&gt;, Float&gt;
{

   @Override
   public CompletionStage&lt;Float&gt; resolve(
      Class&lt;? extends CompletionStage&lt;Float&gt;&gt; rawType,
            Type genericType,
            Annotation[] annotations)
    {
       for (Annotation annotation : annotations)
       {
           if(annotation.annotationType() ==
              AsyncInjectionPrimitiveInjectorSpecifier.class) {
             AsyncInjectionPrimitiveInjectorSpecifier.Type value =
               ((AsyncInjectionPrimitiveInjectorSpecifier)annotation).value();
             switch(value) {
               case NO_RESULT:
                  return null;
               case NULL:
                  return CompletableFuture.completedFuture(null);
               case VALUE:
                  return CompletableFuture.completedFuture(4.2f);
            }
            break;
          }
       }
       return CompletableFuture.completedFuture(4.2f);
    }
}
        </code></pre>
    </section>
 </section>
   <section class="chapter" id="Reactive"><div class="titlepage"><div><div><h1 class="title">Chapter 40. Reactive programming support</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="sect1"><a href="#d5e2525">40.1. CompletionStage</a></span></li><li><span class="sect1"><a href="#d5e2565">40.2. CompletionStage in JAX-RS</a></span></li><li><span class="sect1"><a href="#d5e2613">40.3. Beyond CompletionStage</a></span></li><li><span class="sect1"><a href="#d5e2644">40.4. Pluggable reactive types: RxJava 2 in RESTEasy</a></span></li><li><span class="sect1"><a href="#d5e2843">40.5. Proxies</a></span></li><li><span class="sect1"><a href="#d5e2857">40.6. Adding extensions</a></span></li></ul></div>

 
    <p>
       With version 2.1, the JAX-RS specification 
       (<a class="ulink" href="https://jcp.org/en/jsr/detail?id=370">https://jcp.org/en/jsr/detail?id=370</a>)
       takes its first steps into the world of <span class="bold"><strong>Reactive Programming</strong></span>. There are many discussions
       of reactive programming on the internet, and a general introduction is beyond the scope of this document,
       but there are a few things worth discussing. Some primary aspects of reactive programming are the following: 
    </p>
    
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
           Reactive programming supports the declarative creation of rich computational structures. The 
           representations of these structures can be passed around as first class objects such as method parameters
           and return values.
        </li><li class="listitem">
           Reactive programming supports both synchronous and asynchronous computation, but it is particularly helpful
           in facilitating, at a relatively high level of expression, asynchronous computation. Conceptually,
           asynchronous computation in reactive program typically involves pushing data from one entity to another, rather
           than polling for data.
        </li></ul></div>
<section class="sect1" id="d5e2525"><div class="titlepage"><div><div><h2 class="title">40.1. CompletionStage</h2></div></div></div>

    <p>
       In java 1.8 and JAX-RS 2.1, the support for reactive programming is fairly limited. Java 1.8 introduces the interface
       <code class="classname">java.util.concurrent.CompletionStage</code>, and JAX-RS 2.1 mandates support for the
       <code class="classname">javax.ws.rs.client.CompletionStageRxInvoker</code>, which allows a client to obtain a 
       response in the form of a <code class="classname">CompletionStage</code>. 
    </p>
    
    <p>
       One implementation of <code class="classname">CompletionStage</code> is the <code class="classname">java.util.concurrent.CompleteableFuture</code>.
       For example:
    </p>
    
<pre><code class="no-highlight">
@Test
public void testCompletionStage() throws Exception {
   CompletionStage&lt;String&gt; stage = getCompletionStage();
   log.info("result: " + stage.toCompletableFuture().get());
}

private CompletionStage&lt;String&gt; getCompletionStage() {
   CompletableFuture&lt;String&gt; future = new CompletableFuture&lt;String&gt;();
   future.complete("foo");
   return future;
}
</code></pre>

    <p>
       Here, a <code class="classname">CompleteableFuture</code> is created with the value "foo", and its value is 
       extracted by the method <code class="methodname">CompletableFuture.get()</code>. That's fine, but consider the
       altered version:
    </p>
    
<pre><code class="no-highlight">
@Test
public void testCompletionStageAsync() throws Exception {
   log.info("start");
   CompletionStage&lt;String&gt; stage = getCompletionStageAsync();
   String result = stage.toCompletableFuture().get();
   log.info("do some work");
   log.info("result: " + result);
}

private CompletionStage&lt;String&gt; getCompletionStageAsync() {
   CompletableFuture&lt;String&gt; future = new CompletableFuture&lt;String&gt;();
   Executors.newCachedThreadPool().submit(() -&gt; {sleep(2000); future.complete("foo");});
   return future;
}

private void sleep(long l) {
   try {
      Thread.sleep(l);
   } catch (InterruptedException e) {
      e.printStackTrace();
   }
}
</code></pre>

   <p>
      with output something like:
   </p>
   
<pre><code class="no-highlight">
3:10:51 PM INFO: start
3:10:53 PM INFO: do some work
3:10:53 PM INFO: result: foo
</code></pre>

    <p>
       It also works, but it illustrates the fact that <code class="methodname">CompletableFuture.get()</code> is a blocking
       call. The <code class="classname">CompletionStage</code> is constructed and returned immediately,
       but the value isn't returned for two seconds. A version that is more in the spirit of the reactive style is:
    </p>
    
<pre><code class="no-highlight">
@Test
public void testCompletionStageAsyncAccept() throws Exception {
   log.info("start");
   CompletionStage&lt;String&gt; stage = getCompletionStageAsync();
   stage.thenAccept((String s) -&gt; log.info("s: " + s));
   log.info("do some work");
   ...
}
</code></pre>

    <p>
       In this case, the lambda (String s) -&gt; log.info("s: " + s) is registered with the 
       <code class="classname">CompletionStage</code> as a "subscriber", and, when the <code class="classname">CompletionStage</code>
       eventually has a value, that value is passed to the lambda. Note that the output is something like
    </p>
    
<pre><code class="no-highlight">
3:23:05 INFO: start
3:23:05 INFO: do some work
3:23:07 INFO: s: foo
</code></pre>
    
    <p>
       Executing <code class="classname">CompletionStage</code>s asynchronously is so common that there are 
       several supporting convenience methods. For example:
    </p>
    
<pre><code class="no-highlight">
@Test
public void testCompletionStageSupplyAsync() throws Exception {
   CompletionStage&lt;String&gt; stage = getCompletionStageSupplyAsync();;
   stage.thenAccept((String s) -&gt; log.info("s: " + s));
}

private CompletionStage&lt;String&gt; getCompletionStageSupplyAsync() {
   return CompletableFuture.supplyAsync(() -&gt; "foo");
}
</code></pre>
    
    <p>
       The static method <code class="classname">ComputableFuture.supplyAsync()</code> creates a
       <code class="classname">ComputableFuture</code>, the value of which is supplied asynchronously
       by the lambda () -&gt; "foo", running, by default, in the default pool of
       <code class="methodname">java.util.concurrent.ForkJoinPool</code>.
    </p>
    
    <p>
       One final example illustrates a more complex computational structure:
    </p>
    
<pre><code class="no-highlight">
@Test
public void testCompletionStageComplex() throws Exception {
   ExecutorService executor = Executors.newCachedThreadPool();
   CompletionStage&lt;String&gt; stage1 = getCompletionStageSupplyAsync1("foo", executor);
   CompletionStage&lt;String&gt; stage2 = getCompletionStageSupplyAsync1("bar", executor);
   CompletionStage&lt;String&gt; stage3 = stage1.thenCombineAsync(stage2, (String s, String t) -&gt; s + t, executor);
   stage3.thenAccept((String s) -&gt; log.info("s: " + s));
}

private CompletionStage&lt;String&gt; getCompletionStageSupplyAsync1(String s, ExecutorService executor) {
   return CompletableFuture.supplyAsync(() -&gt; s, executor);
}
</code></pre>

    <p>
       <code class="classname">stage1</code> returns "foo", <code class="classname">stage2</code> returns "bar", and
       <code class="classname">stage3</code>, which runs when both <code class="classname">stage1</code> and <code class="classname">stage2</code>
       have completed, returns the concatenation of "foo" and "bar". Note that, in this example, an explict
       <code class="classname">ExecutorService</code> is provided for asynchronous processing.
    </p>
</section>

<section class="sect1" id="d5e2565"><div class="titlepage"><div><div><h2 class="title">40.2. CompletionStage in JAX-RS</h2></div></div></div>


    <p>
       On the client side, the JAX-RS 2.1 specification mandates an implementation of the interface
       <code class="classname">javax.ws.rs.client.CompletionStageRxInvoker</code>:
    </p>
    
<pre><code class="no-highlight">
public interface CompletionStageRxInvoker extends RxInvoker&lt;CompletionStage&gt; {

    @Override
    public CompletionStage&lt;Response&gt; get();

    @Override
    public &lt;T&gt; CompletionStage&lt;T&gt; get(Class&lt;T&gt; responseType);

    @Override
    public &lt;T&gt; CompletionStage&lt;T&gt; get(GenericType&lt;T&gt; responseType);
    ...
</code></pre>

    <p>
       That is, there are invocation methods for the standard HTTP verbs, just as in the standard 
       <code class="classname">javax.ws.rs.client.SyncInvoker</code>. A <code class="classname">CompletionStageRxInvoker</code>
       is obtained by calling <code class="methodname">rx()</code> on a
       <code class="classname">javax.ws.rs.client.Invocation.Builder</code>, which extends <code class="classname">SyncInvoker</code>.
       For example,
    </p>
    
<pre><code class="no-highlight">
Invocation.Builder builder = client.target(generateURL("/get/string")).request();
CompletionStageRxInvoker invoker = builder.rx(CompletionStageRxInvoker.class);
CompletionStage&lt;Response&gt; stage = invoker.get();
Response response = stage.toCompletableFuture().get();
log.info("result: " + response.readEntity(String.class));
</code></pre>

    <p>
       or
    </p>
    
<pre><code class="no-highlight">
CompletionStageRxInvoker invoker = client.target(generateURL("/get/string")).request().rx(CompletionStageRxInvoker.class);
CompletionStage&lt;String&gt; stage = invoker.get(String.class);
String s = stage.toCompletableFuture().get();
log.info("result: " + s);
</code></pre>

    <p>
       On the server side, the JAX-RS 2.1 specification requires support for resource methods with return type
       <code class="classname">CompletionStage&lt;T&gt;</code>. For example,
    </p>
    
<pre><code class="no-highlight">
@GET
@Path("get/async")
public CompletionStage&lt;String&gt; longRunningOpAsync() {
   CompletableFuture&lt;String&gt; cs = new CompletableFuture&lt;&gt;();
   executor.submit(
      new Runnable() {
         public void run() {
            executeLongRunningOp();
            cs.complete("Hello async world!");
         }
      });
   return cs;
}
</code></pre>

    <p>
       The way to think about <code class="methodname">longRunningOpAsync()</code> is that it is asynchronously
       creating and returning a <code class="classname">String</code>. After <code class="classname">cs.complete()</code> is called,
       the server will return the <code class="classname">String</code> "Hello async world!" to the client.
    </p>
    
    <p>
       An important thing to understand is that the decision to produce a result asynchronously on the server and the
       decision to retrieve the result asynchronously on the client are independent. Suppose that there is also a
       resource method
    </p>
    
<pre><code class="no-highlight">
@GET
@Path("get/sync")
public String longRunningOpSync() {
   return "Hello async world!";
}
</code></pre>

    <p>
       Then all three of the following invocations are valid:
    </p>
    
<pre><code class="no-highlight">
public void testGetStringAsyncAsync() throws Exception {
   CompletionStageRxInvoker invoker = client.target(generateURL("/get/async")).request().rx();
   CompletionStage&lt;String&gt; stage = invoker.get(String.class);
   log.info("s: " + stage.toCompletableFuture().get());
}
</code></pre>

<pre><code class="no-highlight">
public void testGetStringSyncAsync() throws Exception {
   Builder request = client.target(generateURL("/get/async")).request();
   String s = request.get(String.class);
   log.info("s: " + s);
}
</code></pre>

    <p>
       and
    </p>
    
<pre><code class="no-highlight">
public void testGetStringAsyncSync() throws Exception {
   CompletionStageRxInvoker invoker = client.target(generateURL("/get/sync")).request().rx();
   CompletionStage&lt;String&gt; stage = invoker.get(String.class);
   log.info("s: " + stage.toCompletableFuture().get());
}
</code></pre>

   <div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2>
       <p>
          <code class="classname">CompletionStage</code> in JAX-RS is also discussed in the chapter
          <a class="link" href="#Asynchronous_HTTP_Request_Processing" title="Chapter 37. Asynchronous HTTP Request Processing">Asynchronous HTTP Request Processing</a>.
       </p>
   </div>
   
   <div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2>
       <p>
          Since running code asynchronously is so common in this context, it is worth pointing out
          that objects obtained by way of the annotation <code class="code">@Context</code> or by way of calling
          <code class="code">ResteasyContext.getContextData()</code> are sensitive to the
          executing thread. For example, given resource method
       </p>
   
<pre><code class="no-highlight">
@GET
@Path("test")
@Produces("text/plain")
public CompletionStage&lt;String&gt; text(@Context HttpRequest request) {
   System.out.println("request (inline): " + request);
   System.out.println("application (inline): " + ResteasyContext.getContextData(Application.class));
   CompletableFuture&lt;String&gt; cs = new CompletableFuture&lt;&gt;();
   ExecutorService executor = Executors.newSingleThreadExecutor();
   executor.submit(
         new Runnable() {
            public void run() {
               try {
                  System.out.println("request (async): " + request); 
                  System.out.println("application (async): " + ResteasyContext.getContextData(Application.class));
                  cs.complete("hello");
               } catch (Exception e) {
                  e.printStackTrace();
               }
            }
         });
   return cs;
}
</code></pre>

       <p>
          the output will look something like
       </p>
       
<pre><code class="no-highlight">
application (inline): org.jboss.resteasy.experiment.Test1798CompletionStage$TestApp@23c57474
request (inline): org.jboss.resteasy.plugins.server.servlet.Servlet3AsyncHttpRequest@2ce23138
application (async): null
org.jboss.resteasy.spi.LoggableFailure: RESTEASY003880: Unable to find contextual data of type: org.jboss.resteasy.spi.HttpRequest
</code></pre>

       <p>
          The point is that it is the developer's responsibility to extract information from these context objects
          in advance. For example:
       </p>
       
<pre><code class="no-highlight">
@GET
@Path("test")
@Produces("text/plain")
public CompletionStage&lt;String&gt; text(@Context HttpRequest req) {
   System.out.println("request (inline): " + request);
   System.out.println("application (inline): " + ResteasyContext.getContextData(Application.class));
   CompletableFuture&lt;String&gt; cs = new CompletableFuture&lt;&gt;();
   ExecutorService executor = Executors.newSingleThreadExecutor();
   final String httpMethodFinal = request.getHttpMethod();
   final Map&lt;String, Object&gt; mapFinal = ResteasyContext.getContextData(Application.class).getProperties();
   executor.submit(
         new Runnable() {
            public void run() {
               System.out.println("httpMethod (async): " + httpMethodFinal); 
               System.out.println("map (async): " + mapFinal); 
               cs.complete("hello");
            }
         });
   return cs;
}
</code></pre>

       <p>
          Alternatively, you can use RESTEasy's support of 
          <a class="ulink" href="https://github.com/eclipse/microprofile-context-propagation">MicroProfile Context Propagation</a> by using <code class="code">ThreadContext.contextualRunnable</code>
          around your <code class="code">Runnable</code>, which will take care of capturing and restoring all 
          registered contexts (you will need to import the <code class="code">resteasy-context-propagation</code> module):
       </p>
       
<pre><code class="no-highlight">
@GET
@Path("test")
@Produces("text/plain")
public CompletionStage&lt;String&gt; text(@Context HttpRequest req) {
   System.out.println("request (inline): " + request);
   System.out.println("application (inline): " + ResteasyContext.getContextData(Application.class));
   CompletableFuture&lt;String&gt; cs = new CompletableFuture&lt;&gt;();
   ThreadContext threadContext = ThreadContext.builder()
                                                   .propagated(ThreadContext.ALL_REMAINING)
                                                   .unchanged()
                                                   .cleared()
                                                   .build();
   ExecutorService executor = Executors.newSingleThreadExecutor();
   executor.submit(
         threadContext.contextualRunnable(new Runnable() {
            public void run() {
               try {
                  System.out.println("request (async): " + request); 
                  System.out.println("application (async): " + ResteasyContext.getContextData(Application.class));
                  cs.complete("hello");
               } catch (Exception e) {
                  e.printStackTrace();
               }
            }
         }));
   return cs;
}
</code></pre>
   </div>
</section>

<section class="sect1" id="d5e2613"><div class="titlepage"><div><div><h2 class="title">40.3. Beyond CompletionStage</h2></div></div></div>


    <p>
       The picture becomes more complex and interesting when sequences are added. A <code class="classname">CompletionStage</code>
       holds no more than one potential value, but other reactive objects can hold multiple, even unlimited, values.
       Currently, most Java implementations of reactive programming are based on the project Reactive Streams
       (<a class="ulink" href="http://www.reactive-streams.org/">http://www.reactive-streams.org/</a>), which defines a set of
       four interfaces and a specification, in the form of a set of rules, describing how they interact:
    </p>
    
<pre><code class="no-highlight">
public interface Publisher&lt;T&gt; {
    public void subscribe(Subscriber&lt;? super T&gt; s);
}

public interface Subscriber&lt;T&gt; {
    public void onSubscribe(Subscription s);
    public void onNext(T t);
    public void onError(Throwable t);
    public void onComplete();
}

public interface Subscription {
    public void request(long n);
    public void cancel();
}

public interface Processor&lt;T, R&gt; extends Subscriber&lt;T&gt;, Publisher&lt;R&gt; {
}
</code></pre>

    <p>
       A <code class="classname">Producer</code> pushes objects to a <code class="classname">Subscriber</code>, a
       <code class="classname">Subscription</code> mediates the relationship between the two, and a
       <code class="classname">Processor</code> which is derived from both, helps to construct pipelines
       through which objects pass.
    </p>
    
    <p>
       One important aspect of the specification is flow control, the ability of a <code class="classname">Suscriber</code>
       to control the load it receives from a <code class="classname">Producer</code> by calling
       <code class="methodname">Suscription.request()</code>. The general term in this context for flow control is
       <span class="bold"><strong>backpressure</strong></span>.
    </p>
    
    <p>
       There are a number of implementations of Reactive Streams, including 
    </p>
    
    <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><span class="bold"><strong>RxJava</strong></span>: 
          <a class="ulink" href="https://github.com/ReactiveX/RxJava">https://github.com/ReactiveX/RxJava</a> (end of life, superceded by RxJava 2)
       </li><li class="listitem"><span class="bold"><strong>RxJava 2</strong></span>: 
          <a class="ulink" href="https://github.com/ReactiveX/RxJava">https://github.com/ReactiveX/RxJava</a>
       </li><li class="listitem"><span class="bold"><strong>Reactor</strong></span>: 
          <a class="ulink" href="http://projectreactor.io/">http://projectreactor.io/</a>
       </li><li class="listitem"><span class="bold"><strong>Flow</strong></span>: 
          <a class="ulink" href="https://community.oracle.com/docs/DOC-1006738">https://community.oracle.com/docs/DOC-1006738/</a>:
          (Java JDK 9+)
          </li></ol></div>
    
    <p>
       RESTEasy currently supports RxJava (deprecated) and RxJava2.
    </p>
    
</section>

<section class="sect1" id="d5e2644"><div class="titlepage"><div><div><h2 class="title">40.4. Pluggable reactive types: RxJava 2 in RESTEasy</h2></div></div></div>


    <p>
       JAX-RS 2.1 doesn't require support for any Reactive Streams implementations, but it does allow
       for extensibility to support various reactive libraries.
       RESTEasy's optional module <code class="code">resteasy-rxjava2</code> 
       adds support for <a class="ulink" href="https://github.com/ReactiveX/RxJava">RxJava 2</a>.
    </p>
    
    <p>
       More in details, <code class="code">resteasy-rxjava2</code>
       contributes support for reactive types <code class="classname">io.reactivex.Single</code>,
       <code class="classname">io.reactivex.Flowable</code>, and <code class="classname">io.reactivex.Observable</code>.
       Of these, <code class="classname">Single</code> is similar to <code class="classname">CompletionStage</code> in that
       it holds at most one potential value. <code class="classname">Flowable</code> implements 
       <code class="classname">io.reactivex.Publisher</code>, and <code class="classname">Observable</code> is very
       similar to <code class="classname">Flowable</code> except that it doesn't support backpressure.
       So, if you import <code class="code">resteasy-rxjava2</code>, you can just start returning these reactive types from your
       resource methods on the server side and receiving them on the client side.
    </p>
    
    <div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2>
       <p>
          When you use RESTEasy's modules for RxJava, the reactive contexts are automatically propagated
          to all supported RxJava types, which means you don't need to worry about <code class="code">@Context</code>
          injection not working within RxJava lambdas, contrary to <code class="code">CompletionStage</code> (as previously
          noted).
       </p>
    </div>
    
<section class="sect1" id="d5e2665"><div class="titlepage"><div><div><h2 class="title">1. Server side</h2></div></div></div>

    <p>
       Given the class <code class="classname">Thing</code>, which can be represented in JSON:
    </p>
    
<pre><code class="no-highlight">
public class Thing {

   private String name;

   public Thing() {
   }

   public Thing(String name) {
      this.name = name;
   }
   ...
}
</code></pre>

    <p>the method <code class="methodname">postThingList()</code> in the following is a valid resource method:
    </p>
...
<pre><code class="no-highlight">
@POST
@Path("post/thing/list")
@Produces(MediaType.APPLICATION_JSON)
@Stream
public Flowable&lt;List&lt;Thing&gt;&gt; postThingList(String s) {
   return buildFlowableThingList(s, 2, 3);
}

static Flowable&lt;List&lt;Thing&gt;&gt; buildFlowableThingList(String s, int listSize, int elementSize) {
   return Flowable.create(
      new FlowableOnSubscribe&lt;List&lt;Thing&gt;&gt;() {

         @Override
         public void subscribe(FlowableEmitter&lt;List&lt;Thing&gt;&gt; emitter) throws Exception {
            for (int i = 0; i &lt; listSize; i++) {
               List&lt;Thing&gt; list = new ArrayList&lt;Thing&gt;();
               for (int j = 0; j &lt; elementSize; j++) {
                  list.add(new Thing(s));
               }
               emitter.onNext(list);
            }
            emitter.onComplete();
         }
      },
      BackpressureStrategy.BUFFER);
}
</code></pre>

    <p>
       The somewhat imposing method <code class="methodname">buildFlowableThingList()</code> probably deserves
       some explanation. First,
    </p>
    
<pre><code class="no-highlight">
Flowable&lt;List&lt;Thing&gt;&gt; Flowable.create(FlowableOnSubscribe&lt;List&lt;Thing&gt;&gt; source, BackpressureStrategy mode);
</code></pre>
    
    <p>
    creates a <code class="classname">Flowable&lt;List&lt;Thing&gt;&gt;</code> by describing what should happen when
    the <code class="classname">Flowable&lt;List&lt;Thing&gt;&gt;</code> is subscribed to. 
    <code class="classname">FlowableEmitter&lt;List&lt;Thing&gt;&gt;</code>
    extends <code class="classname"> io.reactivex.Emitter&lt;List&lt;Thing&gt;&gt;</code>:
    </p>
    
<pre><code class="no-highlight">
/**
 * Base interface for emitting signals in a push-fashion in various generator-like source
 * operators (create, generate).
 *
 * @param &lt;T&gt; the value type emitted
 */
public interface Emitter&lt;T&gt; {

    /**
     * Signal a normal value.
     * @param value the value to signal, not null
     */
    void onNext(@NonNull T value);

    /**
     * Signal a Throwable exception.
     * @param error the Throwable to signal, not null
     */
    void onError(@NonNull Throwable error);

    /**
     * Signal a completion.
     */
    void onComplete();
}
</code></pre>

    <p>
       and <code class="classname">FlowableOnSubscribe</code> uses a <code class="classname">FlowableEmitter</code>
       to send out values from the <code class="classname">Flowable&lt;List&lt;Thing&gt;&gt;</code>:
    </p>
    
<pre><code class="no-highlight">
/**
 * A functional interface that has a {@code subscribe()} method that receives
 * an instance of a {@link FlowableEmitter} instance that allows pushing
 * events in a backpressure-safe and cancellation-safe manner.
 *
 * @param &lt;T&gt; the value type pushed
 */
public interface FlowableOnSubscribe&lt;T&gt; {

    /**
     * Called for each Subscriber that subscribes.
     * @param e the safe emitter instance, never null
     * @throws Exception on error
     */
    void subscribe(@NonNull FlowableEmitter&lt;T&gt; e) throws Exception;
}
</code></pre>
    
    <p>
       So, what will happen
       when a subscription to the <code class="classname">Flowable&lt;List&lt;Thing&gt;&gt;</code> is created is,
       the <code class="methodname">FlowableEmitter.onNext()</code> will be called, once for each
       <code class="classname">&lt;List&lt;Thing&gt;&gt;</code> created, followed by a call to
       <code class="methodname">FlowableEmitter.onComplete()</code> to indicate that the sequence has ended. Under the covers,
       RESTEasy subscribes to the <code class="classname">Flowable&lt;List&lt;Thing&gt;&gt;</code> and handles each element passed in
       by way of <code class="methodname">onNext()</code>.
    </p>
</section>
    
<section class="sect1" id="d5e2694"><div class="titlepage"><div><div><h2 class="title">2. Client side</h2></div></div></div>

   
    <p>
       On the client side, JAX-RS 2.1 supports extensions for reactive classes by adding the method
    </p>
    
<pre><code class="no-highlight">
/**
 * Access a reactive invoker based on a {@link RxInvoker} subclass provider. Note
 * that corresponding {@link RxInvokerProvider} must be registered in the client runtime.
 * 
 * This method is an extension point for JAX-RS implementations to support other types
 * representing asynchronous computations.
 *
 * @param clazz {@link RxInvoker} subclass.
 * @return reactive invoker instance.
 * @throws IllegalStateException when provider for given class is not registered.
 * @see javax.ws.rs.client.Client#register(Class)
 * @since 2.1
 */
public &lt;T extends RxInvoker&gt; T rx(Class&lt;T&gt; clazz);
</code></pre>

    <p>
       to interface <code class="classname"> javax.ws.rs.client.Invocation.Builder</code>. Resteasy
       module <code class="code">resteasy-rxjava2</code> adds support for classes:
    </p>
    
   <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><code class="classname">org.jboss.resteasy.rxjava2.SingleRxInvoker</code>,</li><li class="listitem"><code class="classname">org.jboss.resteasy.rxjava2.FlowableRxInvoker</code></li><li class="listitem"><code class="classname">org.jbosss.resteasy.rxjava2.ObservableRxInvoker</code></li></ol></div>
   
   <p>
      which allow accessing <code class="classname">Single</code>s, <code class="classname">Observable</code>s, and
      <code class="classname">Flowable</code>s on the client side.
   </p>
   
   <p>
      For example, given the resource method <code class="methodname">postThingList()</code> above, a
      <code class="classname">Flowable&lt;List&lt;Thing&gt;&gt;</code> can be retrieved from the server
      by calling
   </p>
   
<pre><code class="no-highlight">
@SuppressWarnings("unchecked")
@Test
public void testPostThingList() throws Exception {
   CountDownLatch latch = new CountdownLatch(1);
   FlowableRxInvoker invoker = client.target(generateURL("/post/thing/list")).request().rx(FlowableRxInvoker.class);
   Flowable&lt;List&lt;Thing&gt;&gt; flowable = (Flowable&lt;List&lt;Thing&gt;&gt;) invoker.post(Entity.entity("a", MediaType.TEXT_PLAIN_TYPE), new GenericType&lt;List&lt;Thing&gt;&gt;() {});
   flowable.subscribe(
         (List&lt;?&gt; l) -&gt; thingListList.add(l),
         (Throwable t) -&gt; latch.countDown(),
         () -&gt; latch.countDown());
   latch.await();
   Assert.assertEquals(aThingListList, thingListList);
}
</code></pre>
 
   <p>
      where <code class="code">aThingListList</code> is
   </p>  
   
<pre><code class="no-highlight">
[[Thing[a], Thing[a], Thing[a]], [Thing[a], Thing[a], Thing[a]]]
</code></pre>

   <p>
      Note the call to <code class="methodname">Flowable.suscribe()</code>. On the server side, RESTEasy subscribes to a 
      returning <code class="classname">Flowable</code> in order to receive its elements and send them over the wire. On the client side,
      the user subscribes to the <code class="classname">Flowable</code> in order to receive its elements and do whatever it wants to
      with them. In this case, three lambdas determine what should happen 1) for each element, 2) if a <code class="classname">Throwable</code>
      is thrown, and 3) when the <code class="classname">Flowable</code> is done passing elements.
   </p>
   
</section>

<section class="sect1" id="d5e2725"><div class="titlepage"><div><div><h2 class="title">3. Representation on the wire</h2></div></div></div>


    <p>
       Neither Reactive Streams nor JAX-RS have anything to say about representing reactive types on the network.
       RESTEasy offers a number of representations, each suitable for different circumstances. The wire protocol
       is determined by 1) the presence or absence of the <code class="code">@Stream</code> annotation on the resource method, 
       and 2) the value of the <code class="code">value</code> field in the <code class="code">@Stream</code> annotation:
    </p>
    
<pre><code class="no-highlight">
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface Stream
{
   public enum MODE {RAW, GENERAL};
   public String INCLUDE_STREAMING_PARAMETER = "streaming";
   public MODE value() default MODE.GENERAL;
   public boolean includeStreaming() default false;
}
</code></pre>

    <p>
       Note that <code class="code">MODE.GENERAL</code> is the default value, so <code class="code">@Stream</code> is equivalent
       to <code class="code">@Stream(Stream.MODE.GENERAL)</code>.
    </p>
    
    <div class="variablelist"><dl class="variablelist"><dt><span class="term">No <code class="code">@Stream</code> annotation on the resource method</span></dt><dd>
                Resteasy will collect every value until the stream is complete, then wrap them into a
                <code class="code">java.util.List</code> entity  and send to the client.
            </dd><dt><span class="term"><code class="code">@Stream(Stream.MODE.GENERAL)</code></span></dt><dd>
                This case uses a variant of the SSE format, modified to eliminate some restrictions inherent in SSE.
                (See the specification at
                <a class="ulink" href="https://html.spec.whatwg.org/multipage/server-sent-events.html">
                https://html.spec.whatwg.org/multipage/server-sent-events.html</a> for details.)
                In particular, 1) SSE events are meant to hold text data, represented in character set UTF-8. In the general streaming mode,
                certain delimiting characters in the data ('\r', '\n', and '\') are escaped so that arbitrary binary data can be
                transmitted. Also, 2) the SSE specification requires the client to reconnect if it gets disconnected. If the stream
                is finite, reconnecting will induce a repeat of the stream, so SSE is really meant for unlimited streams.
                In general streaming mode, the client will close, rather than automatically reconnect, at the end of the stream. It follows
                that this mode is suitable for finite streams.
                
                <p>
                   <span class="bold"><strong>Note. </strong></span> The Content-Type header in general streaming mode is set to
                </p>
                
                <pre><code class="no-highlight">
          applicaton/x-stream-general;"element-type=&lt;element-type&gt;"
                </code></pre>
                <p>
                   where &lt;element-type&gt;
                   is the media type of the data elements in the stream. The element media type is derived
                   from the @Produces annotation. For example, 
                </p>
      
                <pre><code class="no-highlight">
      @GET
      @Path("flowable/thing")
      @Stream
      @Produces("application/json")
      public Flowable&lt;Thing&gt; getFlowable() { ... }
                </code></pre>
                
                <p>
                   induces the media type
                </p>
                
                <pre><code class="no-highlight">
          application/x-stream-general;"element-type=application/json"
                </code></pre>
                
                <p>
                   which describes a stream of JSON elements.
                </p>
            </dd><dt><span class="term"><code class="code">@Stream(Stream.MODE.RAW)</code></span></dt><dd>
                In this case each value is written directly to the wire, without any formatting, as it becomes available. 
                This is most useful for values that can be cut in pieces, such as strings, bytes, buffers, etc., and then
                re-concatenated on the client side. Note that without delimiters as in
                general mode, it isn't possible to reconstruct something like <code class="classname">List&lt;List&lt;String&gt;&gt;</code>.

                <p>
                   <span class="bold"><strong>Note. </strong></span> The Content-Type header in raw streaming mode is derived from
                   the <code class="code">@Produces</code> annotation. The <code class="code">@Stream</code> annotation offers the possibility of an
                   optional <code class="classname">MediaType</code> parameter called "streaming". The point is to be able to suggest
                   that the stream of data emanating from the server is unbounded, i.e., that the client shouldn't try to
                   read it all as a single byte array, for example. The parameter is set by explicitly setting the
                   <code class="code">@Stream</code> parameter <code class="code">includeStreaming()</code> to <code class="code">true</code>. For example,
                </p>
                
<pre><code class="no-highlight">
   @GET
   @Path("byte/default")
   @Produces("application/octet-stream;x=y")
   @Stream(Stream.MODE.RAW)
   public Flowable&lt;Byte&gt; aByteDefault() {
      return Flowable.fromArray((byte) 0, (byte) 1, (byte) 2);
   }
</code></pre>

    <p>
       induces the <code class="classname">MediaType</code> "application/octet-stream;x=y", and
    </p>
    
<pre><code class="no-highlight">
   @GET
   @Path("byte/true")
   @Produces("application/octet-stream;x=y")
   @Stream(value=Stream.MODE.RAW, includeStreaming=true)
   public Flowable&lt;Byte&gt; aByteTrue() {
      return Flowable.fromArray((byte) 0, (byte) 1, (byte) 2);
   }
</code></pre>

    <p>
       induces the <code class="classname">MediaType</code> "application/octet-stream;x=y;streaming=true".
    </p>
    
    <p>
       Note that browsers such as Firefox and Chrome seem to be comfortable with reading unlimited streams
       without any additional hints.
    </p>
           </dd></dl></div>
</section>

<section class="sect1" id="d5e2775"><div class="titlepage"><div><div><h2 class="title">4. Examples.</h2></div></div></div>

    
    <p>
       <span class="bold"><strong>Example 1.</strong></span>
    </p>
    
<pre><code class="no-highlight">
@POST
@Path("post/thing/list")
@Produces(MediaType.APPLICATION_JSON)
@Stream(Stream.MODE.GENERAL)
public Flowable&lt;List&lt;Thing&gt;&gt; postThingList(String s) {
   return buildFlowableThingList(s, 2, 3);
}
...
@SuppressWarnings("unchecked")
@Test
public void testPostThingList() throws Exception {
   CountDownLatch latch = new CountdownLatch(1);
   FlowableRxInvoker invoker = client.target(generateURL("/post/thing/list")).request().rx(FlowableRxInvoker.class);
   Flowable&lt;List&lt;Thing&gt;&gt; flowable = (Flowable&lt;List&lt;Thing&gt;&gt;) invoker.post(Entity.entity("a", MediaType.TEXT_PLAIN_TYPE), new GenericType&lt;List&lt;Thing&gt;&gt;() {});
   flowable.subscribe(
         (List&lt;?&gt; l) -&gt; thingListList.add(l),
         (Throwable t) -&gt; latch.countDown(),
         () -&gt; latch.countDown());
   latch.await();
   Assert.assertEquals(aThingListList, thingListList);
}
</code></pre>

    <p>
       This is the example given previously, except that the mode in the <code class="code">@Stream</code> annotation (which defaults
       to MODE.GENERAL) is given explicitly. In this scenario, the <code class="classname">Flowable</code> emits
       <code class="classname">&lt;List&lt;Thing&gt;&gt;</code> elements on the server, they are transmitted over the wire as
       SSE events:
    </p>
    
<pre><code class="no-highlight">
data: [{"name":"a"},{"name":"a"},{"name":"a"}]
data: [{"name":"a"},{"name":"a"},{"name":"a"}]
</code></pre>
       
    <p>
       and the <code class="classname">FlowableRxInvoker</code> reconstitutes a <code class="classname">Flowable</code> on the
       client side.
    </p>
    
    <p><span class="bold"><strong>Example 2.</strong></span></p>
    
<pre><code class="no-highlight">
@POST
@Path("post/thing/list")
@Produces(MediaType.APPLICATION_JSON)
public Flowable&lt;List&lt;Thing&gt;&gt; postThingList(String s) {
   return buildFlowableThingList(s, 2, 3);
}
...
@Test
public void testPostThingList() throws Exception {
   Builder request = client.target(generateURL("/post/thing/list")).request();
   List&lt;List&lt;Thing&gt;&gt; list = request.post(Entity.entity("a", MediaType.TEXT_PLAIN_TYPE), new GenericType&lt;List&lt;List&lt;Thing&gt;&gt;&gt;() {});
   Assert.assertEquals(aThingListList, list);
}  
</code></pre>

    <p>
       In this scenario, in which the resource method has no <code class="code">@Stream</code> annotation, the 
       <code class="classname">Flowable</code> emits stream elements which are accumulated by the server until
       the <code class="classname">Flowable</code> is done, at which point the entire JSON list is transmitted over the wire:
    </p>
    
<pre><code class="no-highlight">
[[{"name":"a"},{"name":"a"},{"name":"a"}],[{"name":"a"},{"name":"a"},{"name":"a"}]]
</code></pre>

    <p>
       and the list is reconstituted on the client side by an ordinary invoker.
    </p>
    
    <p><span class="bold"><strong>Example 3.</strong></span></p>
     
<pre><code class="no-highlight">
@GET
@Path("get/bytes")
@Produces(MediaType.APPLICATION_OCTET_STREAM)
@Stream(Stream.MODE.RAW)
public Flowable&lt;byte[]&gt; getBytes() {
   return Flowable.create(
      new FlowableOnSubscribe&lt;byte[]&gt;() {

         @Override
         public void subscribe(FlowableEmitter&lt;byte[]&gt; emitter) throws Exception {
            for (int i = 0; i &lt; 3; i++) {
               byte[] b = new byte[10];
               for (int j = 0; j &lt; 10; j++) {
                  b[j] = (byte) (i + j);
               }
               emitter.onNext(b);
            }
            emitter.onComplete();
         }
      },
      BackpressureStrategy.BUFFER);
}
...
@Test
public void testGetBytes() throws Exception {
   Builder request = client.target(generateURL("/get/bytes")).request();
   InputStream is = request.get(InputStream.class);
   int n = is.read();
   while (n &gt; -1) {
      System.out.print(n);
      n = is.read();
   }
}
</code></pre>

    <p>
       Here, the byte arrays are written to the network as they are created by the <code class="classname">Flowable</code>.
       On the network, they are concatenated, so the client sees one stream of bytes.
    </p>
    
    <div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2>
        <p>
           Given that asynchronous code is common in this context, it is worth looking at the earlier 
           <a class="link" href="#asyncContextNote" title="Note">Note</a>.
       </p>
   </div>
</section>

<section class="sect1" id="d5e2805"><div class="titlepage"><div><div><h2 class="title">5. Rx and SSE</h2></div></div></div>


    <p>
       Since general streaming mode and SSE share minor variants of the same wire protocol, they are, modulo the SSE
       restriction to character data, interchangeable. That is, an SSE client can connect to a resource method that returns
       a <code class="classname">Flowable</code> or an <code class="classname">Observable</code>, and a <code class="classname">FlowableRxInvoker</code>,
       for example, can connect to an SSE resource method.
    </p>
    
    <p>
        <span class="bold"><strong>Note.</strong></span> SSE requires a <code class="code">@Produces("text/event-stream")</code>
        annotation, so, unlike the cases of raw and general streaming, the element media type cannot
        be derived from the <code class="code">@Produces</code> annotation. To solve this problem, Resteasy introduces the
    </p>
    
<pre><code class="no-highlight">
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface SseElementType
{
   public String value();
}
</code></pre>

    <p>
        annotation, from which the element media type is derived.
    </p>
    
    <p><span class="bold"><strong>Example 1.</strong></span></p>
    
<pre><code class="no-highlight">
@GET
@Path("eventStream/thing")
@Produces("text/event-stream")
@SseElementType("application/json")
public void eventStreamThing(@Context SseEventSink eventSink, @Context Sse sse) {
   new ScheduledThreadPoolExecutor(5).execute(() -&gt; {
      try (SseEventSink sink = eventSink) {
         OutboundSseEvent.Builder  builder = sse.newEventBuilder();
         eventSink.send(builder.data(new Thing("e1")).build());
         eventSink.send(builder.data(new Thing("e2")).build());
         eventSink.send(builder.data(new Thing("e3")).build());
      }
   });
}
...
@SuppressWarnings("unchecked")
@Test
public void testFlowableToSse() throws Exception {
   CountDownLatch latch = new CountDownLatch(1);
   final AtomicInteger errors = new AtomicInteger(0);
   FlowableRxInvoker invoker = client.target(generateURL("/eventStream/thing")).request().rx(FlowableRxInvoker.class);
   Flowable&lt;Thing&gt; flowable = (Flowable&lt;Thing&gt;) invoker.get(Thing.class);
   flowable.subscribe(
      (Thing t) -&gt; thingList.add(t),
      (Throwable t) -&gt; errors.incrementAndGet(),
      () -&gt; latch.countDown());
   boolean waitResult = latch.await(30, TimeUnit.SECONDS);
   Assert.assertTrue("Waiting for event to be delivered has timed out.", waitResult);
   Assert.assertEquals(0, errors.get());
   Assert.assertEquals(eThingList, thingList);
}  
</code></pre>

    <p>
       Here, a <code class="classname">FlowableRxInvoker</code> is connecting to an SSE resource method. On the network,
       the data looks like
    </p>
    
<pre><code class="no-highlight">
data: {"name":"e1"}
data: {"name":"e2"}
data: {"name":"e3"}
</code></pre>

    <p>
       Note that the character data is suitable for an SSE resource method.
    </p>

    <p>
       Also, note that the <code class="methodname">eventStreamThing()</code> method in this example induces the media type
    </p>
    
<pre><code class="no-highlight">
    text/event-stream;element-type="application/json"
</code></pre>
    
    <p><span class="bold"><strong>Example 2.</strong></span></p>
    
<pre><code class="no-highlight">
@GET
@Path("flowable/thing")
@Produces("text/event-stream")
@SseElementType("application/json")
public Flowable&lt;Thing&gt; flowableSSE() {
   return Flowable.create(
      new FlowableOnSubscribe&lt;Thing&gt;() {

         @Override
         public void subscribe(FlowableEmitter&lt;Thing&gt; emitter) throws Exception {
            emitter.onNext(new Thing("e1"));
            emitter.onNext(new Thing("e2"));
            emitter.onNext(new Thing("e3"));
            emitter.onComplete();
         }
      },
      BackpressureStrategy.BUFFER);
}
...
@Test
public void testSseToFlowable() throws Exception {
   final CountDownLatch latch = new CountDownLatch(3);
   final AtomicInteger errors = new AtomicInteger(0);
   WebTarget target = client.target(generateURL("/flowable/thing"));
   SseEventSource msgEventSource = SseEventSource.target(target).build();
   try (SseEventSource eventSource = msgEventSource)
   {
      eventSource.register(
         event -&gt; {thingList.add(event.readData(Thing.class, MediaType.APPLICATION_JSON_TYPE)); latch.countDown();},
         ex -&gt; errors.incrementAndGet());
      eventSource.open();

      boolean waitResult = latch.await(30, TimeUnit.SECONDS);
      Assert.assertTrue("Waiting for event to be delivered has timed out.", waitResult);
      Assert.assertEquals(0, errors.get());
      Assert.assertEquals(eThingList, thingList);
   }
}
</code></pre>

    <p>
       Here, an SSE client is connecting to a resource method that returns a <code class="classname">Flowable</code>.
       Again, the server is sending character data, which is suitable for the SSE client, and the data looks
       the same on the network.
    </p>
</section>

<section class="sect1" id="d5e2832"><div class="titlepage"><div><div><h2 class="title">6. To stream or not to stream</h2></div></div></div>


    <p>
       Whether or not it is appropriate to stream a list of values is a judgment call. Certainly, if the
       list is unbounded, then it isn't practical, or even possible, perhaps, to collect the entire list
       and send it at once. In other cases, the decision is less obvious. 
    </p>
    
    <p>
       <span class="bold"><strong>Case 1.</strong></span> Suppose that all of the elements are producible quickly.
       Then the overhead of sending them independently is probably not worth it.
    </p>
    
    <p>
       <span class="bold"><strong>Case 2.</strong></span> Suppose that the list is bounded but the elements will
       be produced over an extended period of time. Then returning the initial elements when they become
       available might lead to a better user experience.
    </p>
    
    <p>
       <span class="bold"><strong>Case 3.</strong></span> Suppose that the list is bounded and the elements can be
       produced in a relatively short span of time but only after some delay. Here is a situation that
       illustrates the fact that asynchronous reactive processing and streaming over the network are
       independent concepts. In this case it's worth considering having the resource method return
       something like <code class="classname">CompletionStage&lt;List&lt;Thing&gt;&gt;</code> rather than
       <code class="classname">Flowable&lt;List&lt;Thing&gt;&gt;</code>. This has the 
       benefit of creating the list asynchronously but, once it is available, sending it to the client
       in one piece.
    </p>
</section>
</section>

<section class="sect1" id="d5e2843"><div class="titlepage"><div><div><h2 class="title">40.5. Proxies</h2></div></div></div>


    <p>
       Proxies, discussed in <a class="link" href="#proxies" title="51.2. RESTEasy Proxy Framework">RESTEasy Proxy Framework</a>, are a RESTEasy extension
       that supports a natural programming style in which generic JAX-RS invoker calls are replaced by application
       specific interface calls. The proxy framework is extended to include both
       <code class="classname">CompletionStage</code> and the RxJava2 types <code class="classname">Single</code>,
       <code class="classname">Observable</code>, and <code class="classname">Flowable</code>.
    </p>
    
    <p><span class="bold"><strong>Example 1.</strong></span></p>
    
<pre><code class="no-highlight">
@Path("")
public interface RxCompletionStageResource {

   @GET
   @Path("get/string")
   @Produces(MediaType.TEXT_PLAIN)
   public CompletionStage&lt;String&gt; getString();
}

@Path("")
public class RxCompletionStageResourceImpl {

   @GET
   @Path("get/string")
   @Produces(MediaType.TEXT_PLAIN)
   public CompletionStage&lt;String&gt; getString() { .... }
}

public class RxCompletionStageProxyTest {

   private static ResteasyClient client;
   private static RxCompletionStageResource proxy;
   
   static {
      client = (ResteasyClient)ClientBuilder.newClient();
      proxy = client.target(generateURL("/")).proxy(RxCompletionStageResource.class);
   }
   
   @Test
   public void testGet() throws Exception {
      CompletionStage&lt;String&gt; completionStage = proxy.getString();
      Assert.assertEquals("x", completionStage.toCompletableFuture().get());
   }
}
</code></pre>

    <p>
       <span class="bold"><strong>Example 2.</strong></span>
    </p>
    
<pre><code class="no-highlight">
public interface Rx2FlowableResource {

   @GET
   @Path("get/string")
   @Produces(MediaType.TEXT_PLAIN)
   @Stream
   public Flowable&lt;String&gt; getFlowable();
}

@Path("")
public class Rx2FlowableResourceImpl {

   @GET
   @Path("get/string")
   @Produces(MediaType.TEXT_PLAIN)
   @Stream
   public Flowable&lt;String&gt; getFlowable() { ... }
}

public class Rx2FlowableProxyTest {

   private static ResteasyClient client;
   private static Rx2FlowableResource proxy;
   
   static {
      client = (ResteasyClient)ClientBuilder.newClient();
      proxy = client.target(generateURL("/")).proxy(Rx2FlowableResource.class);
   }
   
   @Test
   public void testGet() throws Exception {
      Flowable&lt;String&gt; flowable = proxy.getFlowable();
      flowable.subscribe(
         (String o) -&gt; stringList.add(o),
         (Throwable t) -&gt; errors.incrementAndGet(),
         () -&gt; latch.countDown());
      boolean waitResult = latch.await(30, TimeUnit.SECONDS);
      Assert.assertTrue("Waiting for event to be delivered has timed out.", waitResult);
      Assert.assertEquals(0, errors.get());
      Assert.assertEquals(xStringList, stringList);
   }
}
</code></pre>
</section>

<section class="sect1" id="d5e2857"><div class="titlepage"><div><div><h2 class="title">40.6. Adding extensions</h2></div></div></div>


    <p>
       RESTEasy implements a framework that supports extensions for additional reactive classes. To understand
       the framework, it is necessary to understand the existing support for <code class="classname">CompletionStage</code>
       and other reactive classes.
    </p>
    
    <p>
       <span class="bold"><strong>Server side.</strong></span> When a resource method returns a
       <code class="classname">CompletionStage</code>, RESTEasy subscribes to it using the class
       <code class="classname">org.jboss.resteasy.core.AsyncResponseConsumer.CompletionStageResponseConsumer</code>.
       When the <code class="classname">CompletionStage</code> completes, it calls 
       <code class="methodname">CompletionStageResponseConsumer.accept()</code>, which sends the result back to
       the client.
    </p>
    
    <p>
       Support for <code class="classname">CompletionStage</code> is built in to RESTEasy, but it's not hard to extend
       that support to a class like <code class="classname">Single</code> by providing a mechanism for transforming a
       <code class="classname">Single</code> into a <code class="classname">CompletionStage</code>. In module resteasy-rxjava2,
       that mechanism is supplied by <code class="classname">org.jboss.resteasy.rxjava2.SingleProvider</code>, which
       implements interface <code class="classname">org.jboss.resteasy.spi.AsyncResponseProvider&lt;Single&lt;?&gt;&gt;</code>:
    </p>
    
<pre><code class="no-highlight">
public interface AsyncResponseProvider&lt;T&gt; {
   public CompletionStage toCompletionStage(T asyncResponse);
}
</code></pre>

    <p>
       Given <code class="classname">SingleProvider</code>, RESTEasy can take a <code class="classname">Single</code>,
       transform it into a <code class="classname">CompletionStage</code>, and then use 
       <code class="classname">CompletionStageResponseConsumer</code> to handle the eventual value of
       the <code class="classname">Single</code>.
    </p>
    
    <p>
       Similarly, when a resource method returns a streaming reactive class like <code class="classname">Flowable</code>,
       RESTEasy subscribes to it, receives a stream of data elements, and sends them to the client.
       <code class="classname">AsyncResponseConsumer</code> has several supporting classes, each of which implements a 
       different mode of streaming. For example, <code class="classname">AsyncResponseConsumer.AsyncGeneralStreamingSseResponseConsumer</code>
       handles general streaming and SSE streaming. Subscribing is done by calling 
       <code class="methodname">org.reactivestreams.Publisher.subscribe()</code>, so a mechanism is needed
       for turning, say, a <code class="classname">Flowable</code> into a <code class="classname">Publisher</code>.
       That is, an implementation of <code class="classname">org.jboss.resteasy.spi.AsyncStreamProvider&lt;Flowable&gt;</code>
       is called for, where <code class="classname">AsyncStreamProvider</code> is defined:
    </p>
       
<pre><code class="no-highlight">
public interface AsyncStreamProvider&lt;T&gt; {
   public Publisher toAsyncStream(T asyncResponse);
}
</code></pre>
       
    <p>
       In module resteasy-rxjava2, <code class="classname">org.jboss.resteasy.FlowableProvider</code> provides
       that mechanism for <code class="classname">Flowable</code>. [Actually, that's not too hard since, in
       rxjava2, a <code class="classname">Flowable</code> <span class="emphasis"><em>is</em></span> a <code class="classname">Provider</code>.]
    </p>
    
    <p>
        So, on the server side, adding support for other reactive types can be done by declaring a <code class="code">@Provider</code> for the interface
        <code class="code">AsyncStreamProvider</code> (for streams) or <code class="code">AsyncResponseProvider</code> (for single values), which
        both have a single method to convert the new reactive type into (respectively) a <code class="code">Publisher</code> (for streams)
        or a <code class="code">CompletionStage</code> (for single values).
    </p>
    
    <p>
       <span class="bold"><strong>Client side.</strong></span> The JAX-RS specification version 2.1 imposes two
       requirements for support of reactive classes on the client side:   
    </p> 
    
    <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">support for <code class="classname">CompletionStage</code> in the form of
          an implementation of the interface <code class="classname">javax.ws.rs.client.CompletionStageRxInvoker</code>, and
       </li><li class="listitem">
          extensibility in the form of support for registering providers that implement
<pre><code class="no-highlight">
public interface RxInvokerProvider&lt;T extends RxInvoker&gt; {
    public boolean isProviderFor(Class&lt;T&gt; clazz);
    public T getRxInvoker(SyncInvoker syncInvoker, ExecutorService executorService);
}
</code></pre>
          Once an <code class="classname">RxInvokerProvider</code> is registered, an <code class="classname">RxInvoker</code>
          can be requested by calling the <code class="classname">javax.ws.rs.client.Invocation.Builder</code> method
<pre><code class="no-highlight">
public &lt;T extends RxInvoker&gt; T rx(Class&lt;T&gt; clazz);
</code></pre>
          That <code class="classname">RxInvoker</code> can then be used for making an invocation that returns
          the appropriate reactive class. For example,
<pre><code class="no-highlight">
FlowableRxInvoker invoker = client.target(generateURL("/get/string")).request().rx(FlowableRxInvoker.class);
Flowable&lt;String&gt; flowable = (Flowable&lt;String&gt;) invoker.get();
</code></pre>
       </li></ol></div>
    
    <p>
       RESTEasy provides partial support for implementing <code class="classname">RxInvoker</code>s. For example,
       <code class="classname">SingleProvider</code>, mentioned above, also implements
       <code class="classname">org.jboss.resteasy.spi.AsyncClientResponseProvider&lt;Single&lt;?&gt;&gt;</code>,
       where <code class="classname">AsyncClientResponseProvider</code> is defined
    </p>
    
<pre><code class="no-highlight">
public interface AsyncClientResponseProvider&lt;T&gt; {
   public T fromCompletionStage(CompletionStage&lt;?&gt; completionStage);
}
</code></pre>

    <p>
       <code class="classname">SingleProvider</code>'s ability to turn a <code class="classname">CompletionStage</code>
       into a <code class="classname">Single</code> is used in the implementation of 
       <code class="classname">org.jboss.resteasy.rxjava2.SingleRxInvokerImpl</code>.
    </p>
    
    <p>
       The same concept might be useful in implementing other <code class="classname">RxInvoker</code>s. Note, 
       though, that <code class="classname">ObservableRxInvokerImpl</code> and 
       <code class="classname">FlowableRxInvokerImpl</code> in module resteasy-rxjava2 are each derived
       directly from the SSE implementation.
    </p>

</section>

</section>

   <section class="chapter" id="RESTEasy_Embedded_Container"><div class="titlepage"><div><div><h1 class="title">Chapter 41. Embedded Containers</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="section"><a href="#d5e2935">41.1. Undertow</a></span></li><li><span class="section"><a href="#d5e2939">41.2. Sun JDK HTTP Server</a></span></li><li><span class="section"><a href="#d5e2946">41.3. Netty</a></span></li><li><span class="section"><a href="#d5e2952">41.4. Reactor-Netty</a></span></li><li><span class="section"><a href="#d5e2958">41.5. Vert.x</a></span></li><li><span class="section"><a href="#d5e2974">41.6. EmbeddedJaxrsServer</a></span></li></ul></div>


    <p>RESTEasy has a few different plugins for different embedabble HTTP and/or Servlet containers if use RESTEasy in
    a test environment, or within an environment where you do not want a Servlet engine dependency.</p>
    <section class="section" id="d5e2935"><div class="titlepage"><div><div><h2 class="title">41.1. Undertow</h2></div></div></div>
        
        <p>
            Undertow is a new Servlet Container that is used by WildFly (JBoss Community Server).  You can embed
            Undertow as you wish.  Here's a a test that shows it in action.
</p><pre><code class="no-highlight">
import io.undertow.servlet.api.DeploymentInfo;
import org.jboss.resteasy.plugins.server.undertow.UndertowJaxrsServer;
import org.jboss.resteasy.test.TestPortProvider;
import org.junit.AfterClass;
import org.junit.Assert;
import org.junit.BeforeClass;
import org.junit.Test;

import javax.ws.rs.ApplicationPath;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.core.Application;
import java.util.HashSet;
import java.util.Set;

/**
 * @author &lt;a href="mailto:bill@burkecentral.com"&gt;Bill Burke&lt;/a&gt;
 * @version $Revision: 1 $
 */
public class UndertowTest
{
   private static UndertowJaxrsServer server;

   @Path("/test")
   public static class Resource
   {
      @GET
      @Produces("text/plain")
      public String get()
      {
         return "hello world";
      }
   }

   @ApplicationPath("/base")
   public static class MyApp extends Application
   {
      @Override
      public Set&lt;Class&lt;?&gt;&gt; getClasses()
      {
         HashSet&lt;Class&lt;?&gt;&gt; classes = new HashSet&lt;Class&lt;?&gt;&gt;();
         classes.add(Resource.class);
         return classes;
      }
   }

   @BeforeClass
   public static void init() throws Exception
   {
      server = new UndertowJaxrsServer().start();
   }

   @AfterClass
   public static void stop() throws Exception
   {
      server.stop();
   }

   @Test
   public void testApplicationPath() throws Exception
   {
      server.deployOldStyle(MyApp.class);
      Client client = ClientBuilder.newClient();
      String val = client.target(TestPortProvider.generateURL("/base/test"))
                         .request().get(String.class);
      Assert.assertEquals("hello world", val);
      client.close();
   }

   @Test
   public void testApplicationContext() throws Exception
   {
      server.deployOldStyle(MyApp.class, "/root");
      Client client = ClientBuilder.newClient();
      String val = client.target(TestPortProvider.generateURL("/root/test"))
                         .request().get(String.class);
      Assert.assertEquals("hello world", val);
      client.close();
   }

   @Test
   public void testDeploymentInfo() throws Exception
   {
      DeploymentInfo di = server.undertowDeployment(MyApp.class);
      di.setContextPath("/di");
      di.setDeploymentName("DI");
      server.deploy(di);
      Client client = ClientBuilder.newClient();
      String val = client.target(TestPortProvider.generateURL("/di/base/test"))
                         .request().get(String.class);
      Assert.assertEquals("hello world", val);
      client.close();
   }
}

</code></pre><p>
        </p>
    </section>
    <section class="section" id="d5e2939"><div class="titlepage"><div><div><h2 class="title">41.2. Sun JDK HTTP Server</h2></div></div></div>
        
        <p>
            The Sun JDK comes with a simple HTTP server implementation (com.sun.net.httpserver.HttpServer) which you
            can run RESTEasy on top of.
        </p>
    <pre><code class="no-highlight"> 
      HttpServer httpServer = HttpServer.create(new InetSocketAddress(port), 10);
      contextBuilder = new HttpContextBuilder();
      contextBuilder.getDeployment().getActualResourceClasses().add(SimpleResource.class);
      HttpContext context = contextBuilder.bind(httpServer);
      context.getAttributes().put("some.config.info", "42");
      httpServer.start();

      contextBuilder.cleanup();
      httpServer.stop(0);
    </code></pre>
    <p>
        Create your HttpServer the way you want then use the org.jboss.resteasy.plugins.server.sun.http.HttpContextBuilder to initialize Resteasy
        and bind it to an HttpContext.  The HttpContext attributes are available by injecting in a org.jboss.resteasy.spi.ResteasyConfiguration
        interface using @Context within your provider and resource classes.

    </p>
    <p>Maven project you must include is:</p>
<pre><code class="no-highlight"> 
  &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
      &lt;artifactId&gt;resteasy-jdk-http&lt;/artifactId&gt;
      &lt;version&gt;4.7.10.Final&lt;/version&gt;
  &lt;/dependency&gt;
</code></pre>

   
    </section>

    <section class="section" id="d5e2946"><div class="titlepage"><div><div><h2 class="title">41.3. Netty</h2></div></div></div>
        
        <p>
            RESTEasy has integration with the popular Netty project as well..
        </p>
    <pre><code class="no-highlight"> 
   public static void start(ResteasyDeployment deployment) throws Exception
   {
      netty = new NettyJaxrsServer();
      netty.setDeployment(deployment);
      netty.setPort(TestPortProvider.getPort());
      netty.setRootResourcePath("");
      netty.setSecurityDomain(null);
      netty.start();
   }
    </code></pre>

    <p>Maven project you must include is:</p>
<pre><code class="no-highlight"> 
  &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
      &lt;artifactId&gt;resteasy-netty4&lt;/artifactId&gt;
      &lt;version&gt;4.7.10.Final&lt;/version&gt;
  &lt;/dependency&gt;
</code></pre>

    </section>
    <section class="section" id="d5e2952"><div class="titlepage"><div><div><h2 class="title">41.4. Reactor-Netty</h2></div></div></div>
        
        <p>
            RESTEasy integrates with the reactor-netty project. This
            server adapter was created to pair with our reactor-netty
            based JAX-RS client integration. Ultimately, if using
            reactor-netty for both the server and server-contained
            clients you will be able to do things like share the same
            event loop for both server and client calls.
        </p>
    <pre><code class="no-highlight"> 
   public static void start(ResteasyDeployment deployment) throws Exception
   {
      ReactorNettyJaxrsServer server =  new ReactorNettyJaxrsServer();
      server.setDeployment(new ResteasyDeploymentImpl());
      server.setDeployment(deployment);
      server.setPort(TestPortProvider.getPort());
      server.setRootResourcePath("");
      server.setSecurityDomain(null);
      server.start();
   }
    </code></pre>

    <p>Maven project you must include is:</p>
<pre><code class="no-highlight"> 
  &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
      &lt;artifactId&gt;resteasy-reactor-netty&lt;/artifactId&gt;
      &lt;version&gt;4.7.10.Final&lt;/version&gt;
  &lt;/dependency&gt;
</code></pre>

    </section>
  <section class="section" id="d5e2958"><div class="titlepage"><div><div><h2 class="title">41.5. Vert.x</h2></div></div></div>
    
    <p>
      RESTEasy has integration with the popular Vert.x project as well..
    </p>
    <pre><code class="no-highlight"> 
   public static void start(VertxResteasyDeployment deployment) throws Exception
   {
      VertxJaxrsServer server = new VertxJaxrsServer();
      server.setDeployment(deployment);
      server.setPort(TestPortProvider.getPort());
      server.setRootResourcePath("");
      server.setSecurityDomain(null);
      server.start();
   }
    </code></pre>

    <p>Maven project you must include is:</p>
    <pre><code class="no-highlight"> 
  &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
      &lt;artifactId&gt;resteasy-vertx&lt;/artifactId&gt;
      &lt;version&gt;4.7.10.Final&lt;/version&gt;
  &lt;/dependency&gt;
    </code></pre>

    <p>The server will bootstrap its own Vert.x instance and Http server.</p>

    <p>When a resource is called, it is done with the Vert.x Event Loop thread, keep in mind to
    not block this thread and respect the Vert.x programming model, see the related Vert.x <a class="ulink" href="http://vertx.io/docs/vertx-core/java/#_don_t_block_me">manual page</a>.</p>

    <p>Vert.x extends the RESTEasy registry to  provide a new binding scope that creates resources per Event Loop:</p>
    <pre><code class="no-highlight"> 
  VertxResteasyDeployment deployment = new VertxResteasyDeployment();
  // Create an instance of resource per Event Loop
  deployment.getRegistry().addPerInstanceResource(Resource.class);
    </code></pre>

    <p>The per instance binding scope caches the same resource instance for each event loop providing the same
    concurrency model than a verticle deployed multiple times.</p>

    <p>Vert.x can also embed a RESTEasy deployment, making easy to use Jax-RS annotated controller in Vert.x applications: </p>
    <pre><code class="no-highlight"> 
  Vertx vertx = Vertx.vertx();
  HttpServer server = vertx.createHttpServer();

  // Set an handler calling Resteasy
  server.requestHandler(new VertxRequestHandler(vertx, deployment));

  // Start the server
  server.listen(8080, "localhost");
    </code></pre>

    <p>Vert.x objects can be injected in annotated resources:</p>
    <pre><code class="no-highlight"> 
  @GET
  @Path("/somepath")
  @Produces("text/plain")
  public String context(
      @Context io.vertx.core.Context context,
      @Context io.vertx.core.Vertx vertx,
      @Context io.vertx.core.http.HttpServerRequest req,
      @Context io.vertx.core.http.HttpServerResponse resp) {
    return "the-response";
  }
    </code></pre>

  </section>
   <section class="section" id="d5e2974"><div class="titlepage"><div><div><h2 class="title">41.6. EmbeddedJaxrsServer</h2></div></div></div>
   
   <p>
       <code class="classname">EmbeddedJaxrsServer</code> is an interface provided to enable each embedded container
       wrapper class to configurate, start and stop its container in a standard fashion.
       Each of <code class="classname">UndertowJaxrsServer</code>, <code class="classname">SunHttpJaxrsServer</code>,
       <code class="classname">NettyJaxrsServer</code>, and <code class="classname">VertxJaxrsServer</code> implements
       <code class="classname">EmbeddedJaxrsServer</code>.
   </p>
   <pre><code class="no-highlight"> 
      public interface EmbeddedJaxrsServer&lt;T&gt; {
         T deploy();
         T start();
         void stop();
         ResteasyDeployment getDeployment();
         T setDeployment(ResteasyDeployment deployment);
         T setPort(int port);
         T setHostname(String hostname);
         T setRootResourcePath(String rootResourcePath);
         T setSecurityDomain(SecurityDomain sc);
      }
    </code></pre>
   </section>
</section>

   <section class="chapter" id="RESTEasy_Server-side_Mock_Framework"><div class="titlepage"><div><div><h1 class="title">Chapter 42. Server-side Mock Framework</h1></div></div></div>


<p>

Although RESTEasy has an Embeddable Container, you may not be comfortable with the idea of starting and stopping a web server within unit tests (in reality, the embedded container starts in milli seconds), or you might not like the idea of using Apache HTTP Client or java.net.URL to test your code.  RESTEasy provides a mock framework so that you can invoke on your resource directly.
</p>
<p>

</p><pre><code class="no-highlight">
import org.jboss.resteasy.mock.*;
...

      Dispatcher dispatcher = MockDispatcherFactory.createDispatcher();

      POJOResourceFactory noDefaults = new POJOResourceFactory(LocatingResource.class);
      dispatcher.getRegistry().addResourceFactory(noDefaults);

      {
         MockHttpRequest request = MockHttpRequest.get("/locating/basic");
         MockHttpResponse response = new MockHttpResponse();

         dispatcher.invoke(request, response);


         Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatus());
         Assert.assertEquals("basic", response.getContentAsString());
      }
</code></pre><p>
</p>
<p>

See the RESTEasy Javadoc for all the ease-of-use methods associated with MockHttpRequest, and MockHttpResponse.
</p>
<p>


</p>
</section>

   <section class="chapter" id="Securing_JAX-RS_and_RESTeasy"><div class="titlepage"><div><div><h1 class="title">Chapter 43. Securing JAX-RS and RESTEasy</h1></div></div></div>


<p>

Because RESTEasy is deployed as a servlet, you must use standard web.xml constraints to enable authentication and authorization.  
</p>
<p>

Unfortunately, web.xml constraints do not mesh very well with JAX-RS in some situations.  The problem is that web.xml URL pattern matching is very very limited.  URL patterns in web.xml only support simple wildcards, so JAX-RS resources like:
</p>
<p>

</p><pre><code class="no-highlight">/{pathparam1}/foo/bar/{pathparam2} </code></pre><p>
</p>
<p>

Cannot be mapped as a web.xml URL pattern like:
</p>
<p>

</p><pre><code class="no-highlight">/*/foo/bar/*</code></pre><p>
</p>
<p>

To get around this problem you will need to use the security annotations defined below on your JAX-RS methods.  You will still need to set up some general security constraint elements in web.xml to turn on authentication.
</p>
<p>


</p>
<p>

RESTEasy JAX-RS supports the @RolesAllowed, @PermitAll and @DenyAll annotations on JAX-RS methods.   By default though, RESTEasy does not recognize these annotations.  You have to 
configure RESTEasy to turn on role-based security by setting the appropriate parameter.  NOTE!!!  Do not turn on this switch if you are using EJBs.  The EJB container will provide this
functionality instead of RESTEasy. To configure this switch as a context-param, do this:

</p>
<pre><code class="no-highlight">

&lt;web-app&gt;
...
   &lt;context-param&gt;
      &lt;param-name&gt;resteasy.role.based.security&lt;/param-name&gt;
      &lt;param-value&gt;true&lt;/param-value&gt;
   &lt;/context-param&gt;
&lt;/web-app&gt;
</code></pre>

<p>See <a class="xref" href="#microprofile_config" title="3.4. Configuration">Section 3.4, “Configuration”</a> for more information about application configuration. </p>

<p>There is a bit of quirkiness with this approach.   You will have to declare all roles used within the RESTEasy JAX-RS war file that you are using in your JAX-RS classes and set up a security constraint that permits all of these roles access to every URL handled by the JAX-RS runtime.  You'll just have to trust that RESTEasy JAX-RS authorizes properly.
</p>
<p>

How does RESTEasy do authorization?  Well, its really simple.  It just sees if a method is annotated with @RolesAllowed and then just does HttpServletRequest.isUserInRole.  If one of the @RolesAllowed passes, then allow the request, otherwise, a response is sent back with a 401 (Unauthorized) response code.
</p>
<p>

So, here's an example of a modified RESTEasy WAR file.  You'll notice that every role declared is allowed access to every URL controlled by the RESTEasy servlet.
</p>
<p>

</p><pre><code class="no-highlight">

&lt;web-app&gt;

   &lt;context-param&gt;
      &lt;param-name&gt;resteasy.role.based.security&lt;/param-name&gt;
      &lt;param-value&gt;true&lt;/param-value&gt;
   &lt;/context-param&gt;

   &lt;security-constraint&gt;
      &lt;web-resource-collection&gt;
         &lt;web-resource-name&gt;Resteasy&lt;/web-resource-name&gt;
         &lt;url-pattern&gt;/security&lt;/url-pattern&gt;
      &lt;/web-resource-collection&gt;
       &lt;auth-constraint&gt;
         &lt;role-name&gt;admin&lt;/role-name&gt;
         &lt;role-name&gt;user&lt;/role-name&gt;
      &lt;/auth-constraint&gt;
  &lt;/security-constraint&gt;

   &lt;login-config&gt;
      &lt;auth-method&gt;BASIC&lt;/auth-method&gt;
      &lt;realm-name&gt;Test&lt;/realm-name&gt;
   &lt;/login-config&gt;

   &lt;security-role&gt;
      &lt;role-name&gt;admin&lt;/role-name&gt;
   &lt;/security-role&gt;
   &lt;security-role&gt;
      &lt;role-name&gt;user&lt;/role-name&gt;
   &lt;/security-role&gt;

   ...
&lt;/web-app&gt;


</code></pre><p>
</p>
<p>


</p>
</section>

    <section class="chapter" id="d5e3012"><div class="titlepage"><div><div><h1 class="title">Chapter 44. JSON Web Signature and Encryption (JOSE-JWT)</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="section"><a href="#d5e3015">44.1. JSON Web Signature (JWS)</a></span></li><li><span class="section"><a href="#d5e3021">44.2. JSON Web Encryption (JWE)</a></span></li></ul></div>
  

  <p>JSON Web Signature and Encryption (JOSE JWT) is a new specification that can be used to
        encode content as a string and either digitally sign or encrypt it. I won't go over the spec
        here Do a Google search on it if you're interested</p>

  <section class="section" id="d5e3015"><div class="titlepage"><div><div><h2 class="title">44.1. JSON Web Signature (JWS)</h2></div></div></div>
      
      <p>To digitally sign content using JWS, use the <code class="literal">org.jboss.resteasy.jose.jws.JWSBuilder</code> class.
          To unpack and verify a JWS, use the <code class="literal">org.jboss.resteasy.jose.jws.JWSInput</code> class. (TODO, write
          more doco here!)
      Here's an example:</p>
      <pre><code class="no-highlight">
          
   @Test
   public void testRSAWithContentType() throws Exception
   {
      KeyPair keyPair = KeyPairGenerator.getInstance("RSA").generateKeyPair();

      String encoded = new JWSBuilder()
              .contentType(MediaType.TEXT_PLAIN_TYPE)
              .content("Hello World", MediaType.TEXT_PLAIN_TYPE)
              .rsa256(keyPair.getPrivate());

      System.out.println(encoded);

      JWSInput input = new JWSInput(encoded, ResteasyProviderFactory.getInstance());
      System.out.println(input.getHeader());
      String msg = (String)input.readContent(String.class);
      Assert.assertEquals("Hello World", msg);
      Assert.assertTrue(RSAProvider.verify(input, keyPair.getPublic()));

   }

      </code></pre>
  </section>
    <section class="section" id="d5e3021"><div class="titlepage"><div><div><h2 class="title">44.2. JSON Web Encryption (JWE)</h2></div></div></div>
        
        <p>To encrypt content using JWE, use the <code class="literal">org.jboss.resteasy.jose.jwe.JWEBuilder</code> class.
            To decrypt content using JWE, use the <code class="literal">org.jboss.resteasy.jose.jwe.JWEInput</code> class. (TODO, write
            more doco here!)
            Here's an example:</p>
        <pre><code class="no-highlight">
            
   @Test
   public void testRSA() throws Exception
   {
      KeyPair keyPair = KeyPairGenerator.getInstance("RSA").generateKeyPair();

      String content = "Live long and prosper.";

      {
      String encoded = new JWEBuilder().contentBytes(content.getBytes()).RSA1_5((RSAPublicKey)keyPair.getPublic());
      System.out.println("encoded: " + encoded);
      byte[] raw = new JWEInput(encoded).decrypt((RSAPrivateKey)keyPair.getPrivate()).getRawContent();
      String from = new String(raw);
      Assert.assertEquals(content, from);
      }
      {
         String encoded = new JWEBuilder().contentBytes(content.getBytes()).RSA_OAEP((RSAPublicKey)keyPair.getPublic());
         System.out.println("encoded: " + encoded);
         byte[] raw = new JWEInput(encoded).decrypt((RSAPrivateKey)keyPair.getPrivate()).getRawContent();
         String from = new String(raw);
         Assert.assertEquals(content, from);
      }
      {
         String encoded = new JWEBuilder().contentBytes(content.getBytes()).A128CBC_HS256().RSA1_5((RSAPublicKey)keyPair.getPublic());
         System.out.println("encoded: " + encoded);
         byte[] raw = new JWEInput(encoded).decrypt((RSAPrivateKey)keyPair.getPrivate()).getRawContent();
         String from = new String(raw);
         Assert.assertEquals(content, from);
      }
      {
         String encoded = new JWEBuilder().contentBytes(content.getBytes()).A128CBC_HS256().RSA_OAEP((RSAPublicKey)keyPair.getPublic());
         System.out.println("encoded: " + encoded);
         byte[] raw = new JWEInput(encoded).decrypt((RSAPrivateKey)keyPair.getPrivate()).getRawContent();
         String from = new String(raw);
         Assert.assertEquals(content, from);
      }
   }

   @Test
   public void testDirect() throws Exception
   {
      String content = "Live long and prosper.";
      String encoded = new JWEBuilder().contentBytes(content.getBytes()).dir("geheim");
      System.out.println("encoded: " + encoded);
      byte[] raw = new JWEInput(encoded).decrypt("geheim").getRawContent();
      String from = new String(raw);
      Assert.assertEquals(content, from);

   }
        </code></pre>
    </section>

</section>

   <section class="chapter" id="signature"><div class="titlepage"><div><div><h1 class="title">Chapter 45. Doseta Digital Signature Framework</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="section"><a href="#d5e3083">45.1. Maven settings</a></span></li><li><span class="section"><a href="#d5e3088">45.2. Signing API</a></span><ul><li><span class="section"><a href="#d5e3094">45.2.1. @Signed annotation</a></span></li></ul></li><li><span class="section"><a href="#d5e3102">45.3. Signature Verification API</a></span><ul><li><span class="section"><a href="#d5e3111">45.3.1. Annotation-based verification</a></span></li></ul></li><li><span class="section"><a href="#d5e3119">45.4. Managing Keys via a KeyRepository</a></span><ul><li><span class="section"><a href="#d5e3122">45.4.1. Create a KeyStore</a></span></li><li><span class="section"><a href="#d5e3129">45.4.2. Configure Restreasy to use the KeyRepository</a></span></li><li><span class="section"><a href="#d5e3143">45.4.3. Using DNS to Discover Public Keys</a></span></li></ul></li></ul></div>
  

  <p>Digital signatures allow you to protect the integrity of a message.
  They are used to verify that a message sent was sent by the actual user that
  sent the message and was modified in transit. Most web apps handle message
  integrity by using TLS, like HTTPS, to secure the connection between the
  client and server. Sometimes though, we have representations that are going
  to be forwarded to more than one recipient. Some representations may hop
  around from server to server. In this case, TLS is not enough. There needs
  to be a mechanism to verify who sent the original representation and that
  they actually sent that message. This is where digital signatures come
  in.</p>

  <p>While the mime type multiple/signed exists, it does have drawbacks.
  Most importantly it requires the receiver of the message body to understand
  how to unpack. A receiver may not understand this mime type. A better
  approach would be to put signatures in an HTTP header so that receivers that
  don't need to worry about the digital signature, don't have to.</p>

  <p>The email world has a nice protocol called <a class="ulink" href="http://dkim.org">Domain Keys Identified Mail</a> (DKIM). Work is
  also being done to apply this header to protocols other than email (i.e.
  HTTP) through the <a class="ulink" href="https://tools.ietf.org/html/draft-crocker-doseta-base-02">DOSETA
  specifications</a>. It allows you to sign a message body and attach the
  signature via a DKIM-Signature header. Signatures are calculated by first
  hashing the message body then combining this hash with an arbitrary set of
  metadata included within the DKIM-Signature header. You can also add other
  request or response headers to the calculation of the signature. Adding
  metadata to the signature calculation gives you a lot of flexibility to
  piggyback various features like expiration and authorization. Here's what an
  example DKIM-Signature header might look like.</p>

  <pre><code class="no-highlight">DKIM-Signature: v=1;
                a=rsa-sha256;
                d=example.com;
                s=burke;
                c=simple/simple;
                h=Content-Type;
                x=0023423111111;
                bh=2342322111;
                b=M232234=

</code></pre>

  <p>As you can see it is a set of name value pairs delimited by a ';'.
  While its not THAT important to know the structure of the header, here's an
  explanation of each parameter:</p>

  <div class="variablelist"><dl class="variablelist"><dt><span class="term">v</span></dt><dd>
        <p>Protocol version. Always 1.</p>
      </dd><dt><span class="term">a</span></dt><dd>
        <p>Algorithm used to hash and sign the message. RSA signing and
        SHA256 hashing is the only supported algorithm at the moment by
        RESTEasy.</p>
      </dd><dt><span class="term">d</span></dt><dd>
        <p>Domain of the signer. This is used to identify the signer as
        well as discover the public key to use to verify the signature.</p>
      </dd><dt><span class="term">s</span></dt><dd>
        <p>Selector of the domain. Also used to identify the signer and
        discover the public key.</p>
      </dd><dt><span class="term">c</span></dt><dd>
        <p>Canonical algorithm. Only simple/simple is supported at the
        moment. Basically this allows you to transform the message body before
        calculating the hash</p>
      </dd><dt><span class="term">h</span></dt><dd>
        <p>Semi-colon delimited list of headers that are included in the
        signature calculation.</p>
      </dd><dt><span class="term">x</span></dt><dd>
        <p>When the signature expires. This is a numeric long value of the
        time in seconds since epoch. Allows signer to control when a signed
        message's signature expires</p>
      </dd><dt><span class="term">t</span></dt><dd>
        <p>Timestamp of signature. Numeric long value of the time in
        seconds since epoch. Allows the verifier to control when a signature
        expires.</p>
      </dd><dt><span class="term">bh</span></dt><dd>
        <p>Base 64 encoded hash of the message body.</p>
      </dd><dt><span class="term">b</span></dt><dd>
        <p>Base 64 encoded signature.</p>
      </dd></dl></div>

  <p>To verify a signature you need a public key. DKIM uses DNS text
  records to discover a public key. To find a public key, the verifier
  concatenates the Selector (s parameter) with the domain (d parameter)</p>

  <p>&lt;selector&gt;._domainKey.&lt;domain&gt;</p>

  <p>It then takes that string and does a DNS request to retrieve a TXT
  record under that entry. In our above example burke._domainKey.example.com
  would be used as a string. This is a every interesting way to publish public
  keys. For one, it becomes very easy for verifiers to find public keys.
  There's no real central store that is needed. DNS is a infrastructure IT
  knows how to deploy. Verifiers can choose which domains they allow requests
  from. RESTEasy supports discovering public keys via DNS. It also instead
  allows you to discover public keys within a local Java KeyStore if you do
  not want to use DNS. It also allows you to plug in your own mechanism to
  discover keys.</p>

  <p>If you're interested in learning the possible use cases for digital
  signatures, here's a <a class="ulink" href="http://bill.burkecentral.com/2011/02/21/multiple-uses-for-content-signature/">blog</a>
  you might find interesting.</p>

  <section class="section" id="d5e3083"><div class="titlepage"><div><div><h2 class="title">45.1. Maven settings</h2></div></div></div>
    

    <p>You must include the resteasy-crypto project to use the digital
    signature framework.</p>

    <pre><code class="no-highlight">        &lt;dependency&gt;
            &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
            &lt;artifactId&gt;resteasy-crypto&lt;/artifactId&gt;
            &lt;version&gt;4.7.10.Final&lt;/version&gt;
        &lt;/dependency&gt;

</code></pre>
  </section>

  <section class="section" id="d5e3088"><div class="titlepage"><div><div><h2 class="title">45.2. Signing API</h2></div></div></div>
    

    <p>To sign a request or response using the RESTEasy client or server
    framework you need to create an instance of
    org.jboss.resteasy.security.doseta.DKIMSignature. This class represents
    the DKIM-Signature header. You instantiate the DKIMSignature object and
    then set the "DKIM-Signature" header of the request or response. Here's an
    example of using it on the server-side:</p>

    <pre><code class="no-highlight">import org.jboss.resteasy.security.doseta.DKIMSignature;
import java.security.PrivateKey;


@Path("/signed")
public static class SignedResource
{
   @GET
   @Path("manual")
   @Produces("text/plain")
   public Response getManual()
   {
      PrivateKey privateKey = ....; // get the private key to sign message
      
      DKIMSignature signature = new DKIMSignature();
      signature.setSelector("test");
      signature.setDomain("samplezone.org");
      signature.setPrivateKey(privateKey);

      Response.ResponseBuilder builder = Response.ok("hello world");
      builder.header(DKIMSignature.DKIM_SIGNATURE, signature);
      return builder.build();
   }
}

// client example

DKIMSignature signature = new DKIMSignature();
PrivateKey privateKey = ...; // go find it
signature.setSelector("test");
signature.setDomain("samplezone.org");
signature.setPrivateKey(privateKey);

ClientRequest request = new ClientRequest("http://...");
request.header("DKIM-Signature", signature);
request.body("text/plain", "some body to sign");
ClientResponse response = request.put();
</code></pre><p>To sign a message you need a PrivateKey. This can be
    generated by KeyTool or manually using regular, standard JDK Signature
    APIs. RESTEasy currently only supports RSA key pairs. The DKIMSignature
    class also allows you to add and control how various pieces of metadata
    are added to the DKIM-Signature header and the signature calculation. See
    the javadoc for more details.</p>

    <p>If you are including more than one signature, then just add
    additional DKIMSignature instances to the headers of the request or
    response.</p>

    <section class="section" id="d5e3094"><div class="titlepage"><div><div><h3 class="title">45.2.1. @Signed annotation</h3></div></div></div>
      

      <p>Instead of using the API, RESTEasy also provides you an
      annotation alternative to the manual way of signing using a
      DKIMSignature instances is to use the
      @org.jboss.resteasy.annotations.security.doseta.Signed annotation. It is
      required that you configure a KeyRepository as described later in this
      chapter. Here's an example:</p>

      <pre><code class="no-highlight">   @GET
   @Produces("text/plain")
   @Path("signedresource")
   @Signed(selector="burke", domain="sample.com", timestamped=true, expires=@After(hours=24))
   public String getSigned()
   {
      return "hello world";
   }

</code></pre><p>The above example using a bunch of the optional annotation
      attributes of @Signed to create the following Content-Signature
      header:</p>

      <pre><code class="no-highlight">DKIM-Signature: v=1;
                a=rsa-sha256;
                c=simple/simple;
                domain=sample.com;
                s=burke;
                t=02342342341;
                x=02342342322;
                bh=m0234fsefasf==;
                b=mababaddbb==
   
</code></pre><p><em class="parameter"><code>This annotation also works with the client proxy
      framework.</code></em></p>
    </section>
  </section>

  <section class="section" id="d5e3102"><div class="titlepage"><div><div><h2 class="title">45.3. Signature Verification API</h2></div></div></div>
    

    <p>If you want fine grain control over verification, this is an API to
    verify signatures manually. Its a little tricky because you'll need the
    raw bytes of the HTTP message body in order to verify the signature. You
    can get at an unmarshalled message body as well as the underlying raw
    bytes by using a org.jboss.resteasy.spi.MarshalledEntity injection. Here's
    an example of doing this on the server side:</p>

    <pre><code class="no-highlight">import org.jboss.resteasy.spi.MarshalledEntity;


@POST
@Consumes("text/plain")
@Path("verify-manual")
public void verifyManual(@HeaderParam("Content-Signature") DKIMSignature signature,
                         @Context KeyRepository repository, 
                         @Context HttpHeaders headers, 
                         MarshalledEntity&lt;String&gt; input) throws Exception
{
      Verifier verifier = new Verifier();
      Verification verification = verifier.addNew();
      verification.setRepository(repository);
      verification.setStaleCheck(true);
      verification.setStaleSeconds(100);
      try {
          verifier.verifySignature(headers.getRequestHeaders(), input.getMarshalledBytes, signature);
      } catch (SignatureException ex) {
      }
      System.out.println("The text message posted is: " + input.getEntity());
}
</code></pre><p>MarshalledEntity is a generic interface. The template
    parameter should be the Java type you want the message body to be
    converted into. You will also have to configure a KeyRepository. This is
    describe later in this chapter.</p>

    <p>The client side is a little bit different:</p>

    <pre><code class="no-highlight">ClientRequest request = new ClientRequest("http://localhost:9095/signed"));


ClientResponse&lt;String&gt; response = request.get(String.class);
Verifier verifier = new Verifier();
Verification verification = verifier.addNew();
verification.setRepository(repository);
response.getProperties().put(Verifier.class.getName(), verifier);

// signature verification happens when you get the entity
String entity = response.getEntity();

</code></pre><p><em class="parameter"><code>On the client side, you create a verifier and add
    it as a property to the ClientResponse. This will trigger the verification
    interceptors.</code></em></p>

    <section class="section" id="d5e3111"><div class="titlepage"><div><div><h3 class="title">45.3.1. Annotation-based verification</h3></div></div></div>
      

      <p>The easiest way to verify a signature sent in a HTTP request on
      the server side is to use the
      @@org.jboss.resteasy.annotations.security.doseta.Verify (or
      @Verifications which is used to verify multiple signatures). Here's an
      example:</p>

      <pre><code class="no-highlight">      @POST
      @Consumes("text/plain")
      @Verify
      public void post(String input)
      {
      }

</code></pre><p>In the above example, any DKIM-Signature headers attached to
      the posted message body will be verified. The public key to verify is
      discovered using the configured KeyRepository (discussed later in this
      chapter). You can also specify which specific signatures you want to
      verify as well as define multiple verifications you want to happen via
      the @Verifications annotation. Here's a complex example:</p>

      <pre><code class="no-highlight">@POST
@Consumes("text/plain")
@Verifications(
   @Verify(identifierName="d", identiferValue="inventory.com", stale=@After(days=2)),
   @Verify(identifierName="d", identiferValue="bill.com")
}
public void post(String input) {...}
</code></pre><p>The above is expecting 2 different signature to be included
      within the DKIM-Signature header.</p>

      <p>Failed verifications will throw an
      org.jboss.resteasy.security.doseta.UnauthorizedSignatureException. This
      causes a 401 error code to be sent back to the client. If you catch this
      exception using an ExceptionHandler you can browse the failure
      results.</p>
    </section>
  </section>

  <section class="section" id="d5e3119"><div class="titlepage"><div><div><h2 class="title">45.4. Managing Keys via a KeyRepository</h2></div></div></div>
    

    <p>RESTEasy manages keys for you through a
    org.jboss.resteasy.security.doseta.KeyRepository. By default, the
    KeyRepository is backed by a Java KeyStore. Private keys are always
    discovered by looking into this KeyStore. Public keys may also be
    discovered via a DNS text (TXT) record lookup if configured to do so. You
    can also implement and plug in your own implementation of
    KeyRepository.</p>

    <section class="section" id="d5e3122"><div class="titlepage"><div><div><h3 class="title">45.4.1. Create a KeyStore</h3></div></div></div>
      

      <p>Use the Java keytool to generate RSA key pairs. Key aliases MUST
      HAVE the form of:</p>

      <p>&lt;selector&gt;._domainKey.&lt;domain&gt;</p>

      <p>For example:</p>

      <pre><code class="no-highlight">$ keytool -genkeypair -alias burke._domainKey.example.com -keyalg RSA -keysize 1024 -keystore my-apps.jks </code></pre><p>You
      can always import your own official certificates too. See the JDK
      documentation for more details.</p>
    </section>

    <section class="section" id="d5e3129"><div class="titlepage"><div><div><h3 class="title">45.4.2. Configure Restreasy to use the KeyRepository</h3></div></div></div>
      

      <p>Next you need to configure the KeyRepository in your web.xml file
      so that it is created and made available to RESTEasy to discover private
      and public keys.You can reference a Java key store you want the Resteasy
      signature framework to use within web.xml using either
      <code class="literal">resteasy.keystore.classpath</code> or
      <code class="literal">resteasy.keystore.filename</code> context parameters. You
      must also specify the password (sorry its clear text) using the
      <code class="literal">resteasy.keystore.password</code> context parameter. The
      resteasy.context.objects is used to create the instance of the
      repository. For example:</p>

      <pre><code class="no-highlight">    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.doseta.keystore.classpath&lt;/param-name&gt;
        &lt;param-value&gt;test.jks&lt;/param-value&gt;
    &lt;/context-param&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.doseta.keystore.password&lt;/param-name&gt;
        &lt;param-value&gt;geheim&lt;/param-value&gt;
    &lt;/context-param&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.context.objects&lt;/param-name&gt;
        &lt;param-value&gt;org.jboss.resteasy.security.doseta.KeyRepository : org.jboss.resteasy.security.doseta.ConfiguredDosetaKeyRepository&lt;/param-value&gt;
    &lt;/context-param&gt;

</code></pre>

      <p>You can also manually register your own instance of a
      KeyRepository within an Application class. For example:</p>

      <pre><code class="no-highlight">import org.jboss.resteasy.core.Dispatcher;
import org.jboss.resteasy.security.doseta.KeyRepository;
import org.jboss.resteasy.security.doseta.DosetaKeyRepository;

import javax.ws.rs.core.Application;
import javax.ws.rs.core.Context;

public class SignatureApplication extends Application
{
   private HashSet&lt;Class&lt;?&gt;&gt; classes = new HashSet&lt;Class&lt;?&gt;&gt;();
   private KeyRepository repository;

   public SignatureApplication(@Context Dispatcher dispatcher)
   {
      classes.add(SignedResource.class);

      repository = new DosetaKeyRepository();
      repository.setKeyStorePath("test.jks");
      repository.setKeyStorePassword("password");
      repository.setUseDns(false);
      repository.start();

      dispatcher.getDefaultContextObjects().put(KeyRepository.class, repository);
   }

   @Override
   public Set&lt;Class&lt;?&gt;&gt; getClasses()
   {
      return classes;
   }
}

</code></pre>

      <p>On the client side, you can load a KeyStore manually, by
      instantiating an instance of
      org.jboss.resteasy.security.doseta.DosetaKeyRepository. You then set a
      request attribute, "org.jboss.resteasy.security.doseta.KeyRepository",
      with the value of the created instance. Use the
      ClientRequest.getAttributes() method to do this. For example:</p>

      <pre><code class="no-highlight">DosetaKeyRepository keyRepository = new DoestaKeyRepository();
repository.setKeyStorePath("test.jks");
repository.setKeyStorePassword("password");
repository.setUseDns(false);
repository.start();

DKIMSignature signature = new DKIMSignature();
signature.setDomain("example.com");

ClientRequest request = new ClientRequest("http://...");
request.getAttributes().put(KeyRepository.class.getName(), repository);
request.header("DKIM-Signature", signatures);
</code></pre>
    </section>

    <section class="section" id="d5e3143"><div class="titlepage"><div><div><h3 class="title">45.4.3. Using DNS to Discover Public Keys</h3></div></div></div>
      

      <p>Public keys can also be discover by a DNS text record lookup. You
      must configure web.xml to turn this feature:</p>

      <pre><code class="no-highlight">    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.doseta.use.dns&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/context-param&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.doseta.dns.uri&lt;/param-name&gt;
        &lt;param-value&gt;dns://localhost:9095&lt;/param-value&gt;
    &lt;/context-param&gt;

</code></pre><p>The resteasy.doseta.dns.uri context-param is optional and
      allows you to point to a specific DNS server to locate text
      records.</p>

      <section class="section" id="d5e3148"><div class="titlepage"><div><div><h4 class="title">45.4.3.1. Configuring DNS TXT Records</h4></div></div></div>
        

        <p>DNS TXT Records are stored via a format described by the DOSETA
        specification. The public key is defined via a base 64 encoding. You
        can obtain this text encoding by exporting your public keys from your
        keystore, then using a tool like openssl to get the text-based format.
        For example:</p>

        <pre><code class="no-highlight">$ keytool -export -alias bill._domainKey.client.com -keystore client.jks -file bill.der 
$ openssl x509 -noout -pubkey -in bill.der -inform der &gt; bill.pem</code></pre><p>The
        output will look something like: </p>

        <pre><code class="no-highlight">-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCKxct5GHz8dFw0mzAMfvNju2b3
oeAv/EOPfVb9mD73Wn+CJYXvnryhqo99Y/q47urWYWAF/bqH9AMyMfibPr6IlP8m
O9pNYf/Zsqup/7oJxrvzJU7T0IGdLN1hHcC+qRnwkKddNmD8UPEQ4BXiX4xFxbTj
NvKWLZVKGQMyy6EFVQIDAQAB
-----END PUBLIC KEY-----
</code></pre>

        <p>The DNS text record entry would look like this:</p>

        <pre><code class="no-highlight">test2._domainKey        IN      TXT     "v=DKIM1; p=MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCIKFLFWuQfDfBug688BJ0dazQ/x+GEnH443KpnBK8agpJXSgFAPhlRvf0yhqHeuI+J5onsSOo9Rn4fKaFQaQNBfCQpHSMnZpBC3X0G5Bc1HWq1AtBl6Z1rbyFen4CmGYOyRzDBUOIW6n8QK47bf3hvoSxqpY1pHdgYoVK0YdIP+wIDAQAB; t=s"
</code></pre>

        <p>Notice that the newlines are take out. Also, notice that the
        text record is a name value ';' delimited list of parameters. The p
        field contains the public key.</p>
      </section>
    </section>
  </section>
</section>

    <section class="chapter" id="d5e3157"><div class="titlepage"><div><div><h1 class="title">Chapter 46. Body Encryption and Signing via SMIME</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="section"><a href="#d5e3160">46.1. Maven settings</a></span></li><li><span class="section"><a href="#d5e3165">46.2. Message Body Encryption</a></span></li><li><span class="section"><a href="#d5e3176">46.3. Message Body Signing</a></span></li><li><span class="section"><a href="#d5e3187">46.4. application/pkcs7-signature</a></span></li></ul></div>
  

  <p>S/MIME (Secure/Multipurpose Internet Mail Extensions) is a standard
  for public key encryption and signing of MIME data. MIME data being a set of
  headers and a message body. Its most often seen in the email world when
  somebody wants to encrypt and/or sign an email message they are sending
  across the internet. It can also be used for HTTP requests as well which is
  what the RESTEasy integration with S/MIME is all about. RESTEasy allows you
  to easily encrypt and/or sign an email message using the S/MIME standard.
  While the API is described here, you may also want to check out the example
  projects that come with the RESTEasy distribution. It shows both Java and
  Python clients exchanging S/MIME formatted messages with a JAX-RS
  service.</p>

  <section class="section" id="d5e3160"><div class="titlepage"><div><div><h2 class="title">46.1. Maven settings</h2></div></div></div>
    

    <p>You must include the resteasy-crypto project to use the smime framework.</p>

    <pre><code class="no-highlight">        &lt;dependency&gt;
            &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
            &lt;artifactId&gt;resteasy-crypto&lt;/artifactId&gt;
            &lt;version&gt;4.7.10.Final&lt;/version&gt;
        &lt;/dependency&gt;

</code></pre>
  </section>

  <section class="section" id="d5e3165"><div class="titlepage"><div><div><h2 class="title">46.2. Message Body Encryption</h2></div></div></div>
    

    <p>While HTTPS is used to encrypt the entire HTTP message, S/MIME
    encryption is used solely for the message body of the HTTP request or
    response. This is very useful if you have a representation that may be
    forwarded by multiple parties (for example, HornetQ's REST Messaging
    integration!) and you want to protect the message from prying eyes as it
    travels across the network. RESTEasy has two different interfaces for
    encrypting message bodies. One for output, one for input. If your client
    or server wants to send an HTTP request or response with an encrypted
    body, it uses the
    <code class="literal">org.jboss.resteasy.security.smime.EnvelopedOutput</code> type.
    Encrypting a body also requires an X509 certificate which can be generated
    by the Java keytool command-line interface, or the openssl tool that comes
    installed on many OS's. Here's an example of using the
    <code class="literal">EnvelopedOutput</code> interface:</p>

    <pre><code class="no-highlight">// server side   

@Path("encrypted")
@GET
public EnvelopedOutput getEncrypted()
{
   Customer cust = new Customer();
   cust.setName("Bill");
   
   X509Certificate certificate = ...;
   EnvelopedOutput output = new EnvelopedOutput(cust, MediaType.APPLICATION_XML_TYPE);
   output.setCertificate(certificate);
   return output;
}


// client side
X509Certificate cert = ...; 
Customer cust = new Customer();
cust.setName("Bill");
EnvelopedOutput output = new EnvelopedOutput(cust, "application/xml");
output.setCertificate(cert);
Response res = target.request().post(Entity.entity(output, "application/pkcs7-mime").post();

</code></pre>

    <p>An EnvelopedOutput instance is created passing in the entity you
    want to marshal and the media type you want to marshal it into. So in this
    example, we're taking a Customer class and marshalling it into XML before
    we encrypt it. RESTEasy will then encrypt the EnvelopedOutput using the
    BouncyCastle framework's SMIME integration. The output is a Base64
    encoding and would look something like this:</p>

    <pre><code class="no-highlight">Content-Type: application/pkcs7-mime; smime-type=enveloped-data; name="smime.p7m"
Content-Transfer-Encoding: base64
Content-Disposition: attachment; filename="smime.p7m"

MIAGCSqGSIb3DQEHA6CAMIACAQAxgewwgekCAQAwUjBFMQswCQYDVQQGEwJBVTETMBEGA1UECBMK
U29tZS1TdGF0ZTEhMB8GA1UEChMYSW50ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkAgkA7oW81OriflAw
DQYJKoZIhvcNAQEBBQAEgYCfnqPK/O34DFl2p2zm+xZQ6R+94BqZHdtEWQN2evrcgtAng+f2ltIL
xr/PiK+8bE8wDO5GuCg+k92uYp2rLKlZ5BxCGb8tRM4kYC9sHbH2dPaqzUBhMxjgWdMCX6Q7E130
u9MdGcP74Ogwj8fNl3lD4sx/0k02/QwgaukeY7uNHzCABgkqhkiG9w0BBwEwFAYIKoZIhvcNAwcE
CDRozFLsPnSgoIAEQHmqjSKAWlQbuGQL9w4nKw4l+44WgTjKf7mGWZvYY8tOCcdmhDxRSM1Ly682
Imt+LTZf0LXzuFGTsCGOUo742N8AAAAAAAAAAAAA
</code></pre>

    <p>Decrypting an S/MIME encrypted message requires using the
    org.jboss.resteasy.security.smime.EnvelopedInput interface. You also need
    both the private key and X509Certificate used to encrypt the message.
    Here's an example:</p>

    <pre><code class="no-highlight">// server side

@Path("encrypted")
@POST
public void postEncrypted(EnvelopedInput&lt;Customer&gt; input)
{
   PrivateKey privateKey = ...;
   X509Certificate certificate = ...;
   Customer cust = input.getEntity(privateKey, certificate);
}

// client side

ClientRequest request = new ClientRequest("http://localhost:9095/smime/encrypted");
EnvelopedInput input = request.getTarget(EnvelopedInput.class);
Customer cust = (Customer)input.getEntity(Customer.class, privateKey, cert);

</code></pre>

    <p>Both examples simply call the getEntity() method passing in the
    PrivateKey and X509Certificate instances requires to decrypt the message.
    On the server side, a generic is used with EnvelopedInput to specify the
    type to marshal to. On the server side this information is passed as a
    parameter to getEntity(). The message is in MIME format: a Content-Type
    header and body, so the EnvelopedInput class now has everything it needs
    to know to both decrypt and unmarshall the entity. </p>
  </section>

  <section class="section" id="d5e3176"><div class="titlepage"><div><div><h2 class="title">46.3. Message Body Signing</h2></div></div></div>
    

    <p>S/MIME also allows you to digitally sign a message. It is a bit
    different than the Doseta Digital Signing Framework. Doseta is an HTTP
    header that contains the signature. S/MIME uses the multipart/signed data
    format which is a multipart message that contains the entity and the
    digital signature. So Doseta is a header, S/MIME is its own media type.
    Generally I would prefer Doseta as S/MIME signatures require the client to
    know how to parse a multipart message and Doseta doesn't. Its up to you
    what you want to use.</p>

    <p>RESTEasy has two different interfaces for creating a
    multipart/signed message. One for input, one for output. If your client or
    server wants to send an HTTP request or response with an multipart/signed
    body, it uses the
    <code class="literal">org.jboss.resteasy.security.smime.SignedOutput</code> type.
    This type requires both the PrivateKey and X509Certificate to create the
    signature. Here's an example of signing an entity and sending a
    multipart/signed entity.</p>

    <pre><code class="no-highlight">// server-side

   @Path("signed")
   @GET
   @Produces("multipart/signed")
   public SignedOutput getSigned()
   {
      Customer cust = new Customer();
      cust.setName("Bill");

      SignedOutput output = new SignedOutput(cust, MediaType.APPLICATION_XML_TYPE);
      output.setPrivateKey(privateKey);
      output.setCertificate(certificate);
      return output;
   }


// client side
      Client client = ClientBuilder.newClient();
      WebTarget target = client.target("http://localhost:9095/smime/signed");
      Customer cust = new Customer();
      cust.setName("Bill");
      SignedOutput output = new SignedOutput(cust, "application/xml");
      output.setPrivateKey(privateKey);
      output.setCertificate(cert);
      Response res = target.request().post(Entity.entity(output, "multipart/signed");

</code></pre>

    <p>An SignedOutput instance is created passing in the entity you want
    to marshal and the media type you want to marshal it into. So in this
    example, we're taking a Customer class and marshalling it into XML before
    we sign it. RESTEasy will then sign the SignedOutput using the
    BouncyCastle framework's SMIME integration. The output iwould look
    something like this:</p>

    <pre><code class="no-highlight">Content-Type: multipart/signed; protocol="application/pkcs7-signature"; micalg=sha1;  boundary="----=_Part_0_1083228271.1313024422098"

------=_Part_0_1083228271.1313024422098
Content-Type: application/xml
Content-Transfer-Encoding: 7bit

&lt;customer name="bill"/&gt;
------=_Part_0_1083228271.1313024422098
Content-Type: application/pkcs7-signature; name=smime.p7s; smime-type=signed-data
Content-Transfer-Encoding: base64
Content-Disposition: attachment; filename="smime.p7s"
Content-Description: S/MIME Cryptographic Signature

MIAGCSqGSIb3DQEHAqCAMIACAQExCzAJBgUrDgMCGgUAMIAGCSqGSIb3DQEHAQAAMYIBVzCCAVMC
AQEwUjBFMQswCQYDVQQGEwJBVTETMBEGA1UECBMKU29tZS1TdGF0ZTEhMB8GA1UEChMYSW50ZXJu
ZXQgV2lkZ2l0cyBQdHkgTHRkAgkA7oW81OriflAwCQYFKw4DAhoFAKBdMBgGCSqGSIb3DQEJAzEL
BgkqhkiG9w0BBwEwHAYJKoZIhvcNAQkFMQ8XDTExMDgxMTAxMDAyMlowIwYJKoZIhvcNAQkEMRYE
FH32BfR1l1vzDshtQvJrgvpGvjADMA0GCSqGSIb3DQEBAQUABIGAL3KVi3ul9cPRUMYcGgQmWtsZ
0bLbAldO+okrt8mQ87SrUv2LGkIJbEhGHsOlsgSU80/YumP+Q4lYsVanVfoI8GgQH3Iztp+Rce2c
y42f86ZypE7ueynI4HTPNHfr78EpyKGzWuZHW4yMo70LpXhk5RqfM9a/n4TEa9QuTU76atAAAAAA
AAA=
------=_Part_0_1083228271.1313024422098--
</code></pre>

    <p>To unmarshal and verify a signed message requires using the
    <code class="literal">org.jboss.resteasy.security.smime.SignedInput</code>
    interface. You only need the X509Certificate to verify the message. Here's
    an example of unmarshalling and verifying a multipart/signed
    entity.</p>

    <pre><code class="no-highlight">// server side

   @Path("signed")
   @POST
   @Consumes("multipart/signed")
   public void postSigned(SignedInput&lt;Customer&gt; input) throws Exception
   {
      Customer cust = input.getEntity();
      if (!input.verify(certificate))
      {
         throw new WebApplicationException(500);
      }
   }

// client side
      Client client = ClientBuilder.newClient();
      WebTarget target = client.target("http://localhost:9095/smime/signed");
      SignedInput input = target.request().get(SignedInput.class);
      Customer cust = (Customer)input.getEntity(Customer.class)
      input.verify(cert);

</code></pre>
  </section>
    <section class="section" id="d5e3187"><div class="titlepage"><div><div><h2 class="title">46.4. application/pkcs7-signature</h2></div></div></div>
        
        <p>
            application/pkcs7-signature is a data format that includes both the data and the signature in one ASN.1
            binary encoding.
        </p>
        <p>
            SignedOutput and SignedInput can be used to return application/pkcs7-signature format in binary form.  Just
            change the @Produces or @Consumes to that media type to send back that format.
        </p>
        <p>
            Also, if your @Produces or @Consumes is text/plain instead, SignedOutput will be base64 encoded and sent
            as a string.
        </p>
    </section>
</section>

   <section class="chapter" id="RESTEasy_EJB_Integration"><div class="titlepage"><div><div><h1 class="title">Chapter 47. EJB Integration</h1></div></div></div>


<p>

To integrate with EJB you must first modify your EJB's published interfaces.  RESTEasy currently only has simple portable integration with EJBs so you must also manually configure your RESTEasy WAR.
</p>
<p>


</p>
<p>

RESTEasy currently only has simple integration with EJBs.  To make an EJB a JAX-RS resource, you must annotate an SLSB's @Remote or @Local interface with JAX-RS annotations:
</p>
<p>

</p><pre><code class="no-highlight">
@Local
@Path("/Library")
public interface Library {
   
   @GET
   @Path("/books/{isbn}")
   public String getBook(@PathParam("isbn") String isbn);
}

@Stateless
public class LibraryBean implements Library {

...

}
</code></pre><p>
</p>
<p>

</p>
<p>


</p>
<p>

Next, in RESTEasy's web.xml file you must manually register the EJB with RESTEasy using the resteasy.jndi.resources &lt;context-param&gt;
</p>
<p>

</p><pre><code class="no-highlight">
&lt;web-app&gt;
   &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;
   &lt;context-param&gt;
      &lt;param-name&gt;resteasy.jndi.resources&lt;/param-name&gt;
      &lt;param-value&gt;LibraryBean/local&lt;/param-value&gt;
   &lt;/context-param&gt;

   ...
&lt;/web-app&gt;
</code></pre><p>
</p>
<p>

This is the only portable way we can offer EJB integration.  Future versions of RESTEasy will have tighter integration
    with WildFly so you do not have to do any manual registrations or modifications to web.xml.  For right now though,
    we're focusing on portability.
</p>
<p>

</p>
<p>


</p>
<p>

If you're using RESTEasy with an EAR and EJB, a good structure to have is:
</p>
<p>

</p><pre><code class="no-highlight">
my-ear.ear
|------myejb.jar
|------resteasy-jaxrs.war
       |
       ----WEB-INF/web.xml
       ----WEB-INF/lib (nothing)
|------lib/
       |
       ----All RESTEasy jar files
</code></pre><p>
</p>
<p>

From the distribution, remove all libraries from WEB-INF/lib and place them in a common EAR lib.  OR.  Just place the RESTEasy jar dependencies in your application server's system classpath.  (i.e. In JBoss put them in server/default/lib)
</p>
<p>

An example EAR project is available from our testsuite here.
</p>
<p>


</p>
</section>

   <section class="chapter" id="RESTEasy_Spring_Integration"><div class="titlepage"><div><div><h1 class="title">Chapter 48. Spring Integration</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="section"><a href="#BasicIntegration">48.1. Basic Integration</a></span></li><li><span class="section"><a href="#CustomizedConfiguration">48.2. Customized Configuration</a></span></li><li><span class="section"><a href="#SpringMVC">48.3. Spring MVC Integration</a></span></li><li><span class="section"><a href="#SpringUndertow">48.4. Undertow Embedded Spring Container</a></span></li><li><span class="section"><a href="#SpringWebAnnotation">48.5. Processing Spring Web REST annotations in RESTEasy</a></span></li><li><span class="section"><a href="#SpringBootStarter">48.6. Spring Boot starter</a></span></li><li><span class="section"><a href="#SpringUpgradeInWildfly">48.7. Upgrading in WildFly</a></span></li></ul></div>
    
    <p>RESTEasy integrates with Springframework in various forms. In this chapter we introduce different methods to
        integrate Springframework with RESTEasy.
    </p>
    <p>RESTEasy currently supports Spring version 5.3.25</p>
    <section class="section" id="BasicIntegration"><div class="titlepage"><div><div><h2 class="title">48.1. Basic Integration</h2></div></div></div>
        
        <p>For Maven users, you must use the <code class="code">resteasy-spring</code> artifact. And here is the dependency you
            should use:
        </p>
        <pre><code class="no-highlight">&lt;dependency&gt;
    &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
    &lt;artifactId&gt;resteasy-spring&lt;/artifactId&gt;
    &lt;version&gt;4.7.10.Final&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
        <p>
            RESTEasy comes with its own <code class="code">ContextLoaderListener</code> that registers a RESTEasy specific
            <code class="code">BeanPostProcessor</code>
            that processes JAX-RS annotations when a bean is created by a <code class="code">BeanFactory</code>. And it will
            automatically scan for <code class="code">@Provider</code> and JAX-RS resource annotations on your
            bean class and
            register them as JAX-RS resources.
        </p>
        <p>Here is the content that you should add into your <code class="code">web.xml</code> file:
        </p>
        <pre><code class="no-highlight">&lt;listener&gt;
    &lt;listener-class&gt;org.jboss.resteasy.plugins.server.servlet.ResteasyBootstrap&lt;/listener-class&gt;
&lt;/listener&gt;

&lt;listener&gt;
    &lt;listener-class&gt;org.jboss.resteasy.plugins.spring.SpringContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;</code></pre>
        <p>
            Please note that the <code class="code">SpringContextLoaderListener</code> must be declared after <code class="code">
            ResteasyBootstrap
        </code> as it
            uses
            <code class="code">ServletContext</code>
            attributes initialized by it.
        </p>
        <p>
            And you can configure the Springframework to scan for the JAX-RS resources and beans in a Spring
            configuration file. The content of the file is shown as follow:
        </p>
        <pre><code class="no-highlight">&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd

		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;context:component-scan base-package="org.jboss.resteasy.examples.springbasic"&gt;
        &lt;context:include-filter type="annotation" expression="javax.ws.rs.Path"/&gt;
    &lt;/context:component-scan&gt;
    &lt;context:annotation-config/&gt;

&lt;/beans&gt;</code></pre>
        <p>
            Let's say the above file is named <code class="code">resteasy-spring-basic.xml</code>, then in your <code class="code">web.xml</code> the
            can be configured like this:
        </p>
        <pre><code class="no-highlight">&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;classpath:resteasy-spring-basic.xml&lt;/param-value&gt;
&lt;/context-param&gt;</code></pre>
        <p>In addition, you need to configure your RESTEasy servlet in <code class="code">web.xml</code>. Here is the example:
        </p>
        <pre><code class="no-highlight">&lt;servlet&gt;
    &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher&lt;/servlet-class&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/rest/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</code></pre>
        <p>Instead of using <code class="code">HttpServletDispatcher</code> for deployment, you can also use the <code class="code">
            FilterDispatcher
        </code> in <code class="code">web.xml</code>:
        </p>
        <pre><code class="no-highlight">&lt;filter&gt;
    &lt;filter-name&gt;resteasy-filter&lt;/filter-name&gt;
    &lt;filter-class&gt;
        org.jboss.resteasy.plugins.server.servlet.FilterDispatcher
    &lt;/filter-class&gt;
&lt;/filter&gt;</code></pre>
        <p>To see a complete example of the above basic usage, please check the <a class="ulink" href="https://github.com/resteasy/resteasy-examples/tree/master/resteasy-spring-basic">Basic Example
        </a> we provided.
        </p>
    </section>
    <section class="section" id="CustomizedConfiguration"><div class="titlepage"><div><div><h2 class="title">48.2. Customized Configuration</h2></div></div></div>
        
        <p>
            If you do not want to use the <code class="code">SpringContextLoaderListener</code> provided by RESTEasy, and want to
            create your bean factories, then you can manually
            register the RESTEasy <code class="code">BeanFactoryPostProcessor</code> by creating an instance of the RESTEasy
            <code class="code">SpringBeanProcessor</code>.
        </p>
        <p>And you must configure the <code class="code">RestasyBootstrap</code> into the scope to create the <code class="code">
            ResteasyDeployment
        </code> so the relative
            classes can be fetched from <code class="code">ServletContext</code>.
        </p>
        <p>
            There is also a
            <code class="code">SpringBeanProcessorServletAware</code>
            class that implements the <code class="code">ServletContextAware</code> interface provided by Springframework.
            The <code class="code">SpringBeanProcessorServletAware</code> can be used to fetch the
            <code class="code">Registry</code>
            and <code class="code">ResteasyProviderFactory</code> from the <code class="code">ServletContext</code>.
        </p>
        <p>To demonstrate the above process, we have also provide an example. Please check the
            <a class="ulink" href="https://github.com/resteasy/resteasy-examples/tree/master/resteasy-spring-customized">Spring and
                Resteasy Customized Example
            </a>
            we provided.
        </p>
        <p>
            Our Spring integration supports both singletons and the "prototype" scope. RESTEasy handles injecting
            <code class="code">@Context</code>
            references. Constructor injection is not supported though. Also, with the "prototype" scope,
            RESTEasy will inject any <code class="code">@*Param</code> annotated fields or setters before the request is dispatched.
        </p>
        <p>
            NOTE: You can only use auto-proxied beans with our base Spring integration. You will have undesirable
            affects if you are doing handcoded proxying with Spring, i.e., with <code class="code">ProxyFactoryBean</code>. If you
            are using
            auto-proxied beans, you will be ok.
        </p>
    </section>
    <section class="section" id="SpringMVC"><div class="titlepage"><div><div><h2 class="title">48.3. Spring MVC Integration</h2></div></div></div>
        
        <p>
            RESTEasy can also integrate with the Spring MVC framework. Generally speaking, JAX-RS can be combined with a
            Spring <code class="code">DispatcherServlet</code> and used in the same web application.
        </p>
        <p>
            An application combined in this way
            allows you to dispatch to either the Spring controller or the JAX-RS resource
            using the same base URL. In addition you can use the Spring <code class="code">ModelAndView</code> objects as return
            arguments from <code class="code">@GET</code> resource methods.
        </p>
        <p>The setup requires you to use the Spring <code class="code">DispatcherServlet</code> in your <code class="code">web.xml
        </code> file, as well
            as importing the <code class="code">springmvc-resteasy.xml</code> file into your base Spring beans xml file. Here's an
            example <code class="code">web.xml</code> file:

            </p><pre><code class="no-highlight">&lt;web-app version="3.0" xmlns="http://java.sun.com/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"&gt;
    &lt;display-name&gt;resteasy-spring-mvc&lt;/display-name&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;resteasy-spring-mvc&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.jboss.resteasy.springmvc.ResteasySpringDispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:resteasy-spring-mvc-servlet.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;resteasy-spring-mvc&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/rest/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;
</code></pre><p>
        </p>
        <p>Then within the <code class="code">resteasy-spring-mvc-servlet.xml</code>, it should import the <code class="code">
            springmvc-resteasy.xml
        </code> file:
        </p>
        <pre><code class="no-highlight">&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd
    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-2.5.xsd
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
"&gt;

    &lt;!-- Import basic SpringMVC RESTEasy integration --&gt;
    &lt;import resource="classpath:springmvc-resteasy.xml"/&gt;
....</code></pre>
        <p>
            And then you need to tell Spring the package to scan for your JAX-RS resource classes:
            </p><pre><code class="no-highlight">&lt;context:component-scan base-package="org.jboss.resteasy.examples.springmvc"/&gt;
&lt;context:annotation-config/&gt;</code></pre><p>
            Above is the basic configuration for Spring MVC framework. To see a complete example, please check the
            <a class="ulink" href="https://github.com/resteasy/resteasy-examples/tree/master/resteasy-spring-mvc">Spring MVC
                Integration Example
            </a>
            we provided.
        </p>
        <p>
            In addition, A <code class="code">javax.ws.rs.core.Application</code> subclass can be combined with a Spring
            <code class="code">DispatcherServlet</code>
            and used in the same web application.
        </p>
        <p>
            A servlet definition is required
            for both the Spring <code class="code">DispatcherServlet</code> and the <code class="code">javax.ws.rs.core.Application</code> subclass
            in the <code class="code">web.xml</code>,
            as well as RESTEasy Configuration Switch, <code class="code">resteasy.scan.resources</code>. Here is an example
            of the minimum configuration information needed in the <code class="code">web.xml</code>.

            </p><pre><code class="no-highlight">&lt;web-app&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;mySpring&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;mySpring&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;myAppSubclass&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.my.app.EntryApplicationSubclass&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;myAppSubclass&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;!-- required RESTEasy Configuration Switch directs auto scanning
         of the archive for JAX-RS resource files
    --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.scan.resources&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/context-param&gt;
&lt;/web-app&gt;</code></pre><p>
        </p>
        <p>Note that RESTEasy parameters like resteasy.scan.resources may be set in a variety
            of ways. See
            <a class="xref" href="#microprofile_config" title="3.4. Configuration">Section 3.4, “Configuration”</a>
            for more information about application configuration.
        </p>
        <p>
            If your web application contains JAX-RS provider classes the RESTEasy Configuration
            Switch, <code class="code">resteasy.scan.providers</code>, will also be needed. And if the url-pattern for the
            JAX-RS Application subclass is other than <code class="code">/*</code> you will need to declare the RESTEasy
            Configuration Switch, <code class="code">resteasy.servlet.mapping.prefix</code>. This switch can be declare
            either as a context-param or as a servlet init-param. It's value must be the text
            that preceeds the <code class="code">/*</code>. Here is an example of such a <code class="code">web.xml</code>:

            </p><pre><code class="no-highlight">&lt;web-app&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;spring&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;spring&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;myAppSubclass&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.my.app.EntryApplicationSubclass&lt;/servlet-class&gt;

        &lt;init-param&gt;
            &lt;param-name&gt;resteasy.servlet.mapping.prefix&lt;/param-name&gt;
            &lt;param-value&gt;/resources&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;myAppSubclass&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/resources/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.scan.resources&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/context-param&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.scan.providers&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/context-param&gt;
&lt;/web-app&gt;</code></pre><p>
        </p>
        <p>Above are the usages of RESTEasy Spring MVC integration usages.</p>
    </section>
    <section class="section" id="SpringUndertow"><div class="titlepage"><div><div><h2 class="title">48.4. Undertow Embedded Spring Container</h2></div></div></div>
        
        <p>
            We provide a undertow-based embedded spring container module, called "resteasy-undertow-spring". To use it,
            you need to add the following additional dependencies into your project:
        </p>
        <pre><code class="no-highlight">&lt;dependency&gt;
  &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
  &lt;artifactId&gt;resteasy-undertow&lt;/artifactId&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
  &lt;artifactId&gt;resteasy-undertow-spring&lt;/artifactId&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
        <p>In the "resteasy-undertow-spring" module, we have a embedded server class called
            "UndertowJaxrsSpringServer". In its "undertowDeployment(...)" method, it will accept the spring context
            configuration file:
        </p>
        <pre><code class="no-highlight">public DeploymentInfo undertowDeployment(String contextConfigLocation, String mapping)
</code></pre>
        <p>
            We can provide a minimal spring config like the following:
        </p>
        <pre><code class="no-highlight">&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:util="http://www.springframework.org/schema/util"
       xsi:schemaLocation="
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd
        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-2.5.xsd
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        "&gt;
    &lt;context:component-scan base-package="org.jboss.resteasy.springmvc.test"/&gt;
    &lt;context:annotation-config/&gt;
    &lt;import resource="classpath:springmvc-resteasy.xml"/&gt;
&lt;/beans&gt;</code></pre>
        <p>In above configuration, the "springmvc-resteasy.xml" in the classpath is provided by the "resteasy-spring"
            module by default. Let's name the above configuration file with "spring-servlet.xml", and the following code
            will include it and setup the UndertowJaxrsSpringServer and start it:
        </p>
        <pre><code class="no-highlight">UndertowJaxrsSpringServer server = new UndertowJaxrsSpringServer();
server.start();

DeploymentInfo deployment = server.undertowDeployment("classpath:spring-servlet.xml", null);
deployment.setDeploymentName(BasicSpringTest.class.getName());
deployment.setContextPath("/");
deployment.setClassLoader(BasicSpringTest.class.getClassLoader());

server.deploy(deployment);</code></pre>
        <p>Above is the code example to setup and start UndertowJaxrsSpringServer. To see a complete example, please
            check the <a class="ulink" href="https://github.com/resteasy/resteasy-examples/tree/master/resteasy-spring-undertow">
                Demo Of Undertow Embedded Spring Container
            </a> as usage example.
        </p>
    </section>
    <section class="section" id="SpringWebAnnotation"><div class="titlepage"><div><div><h2 class="title">48.5. Processing Spring Web REST annotations in RESTEasy</h2></div></div></div>
        
        <p>
            RESTEasy also provides the ability to process Spring Web REST annotations (i.e. Spring classes annotated
            with <code class="code">@RestController</code>)
            and handle related REST requests without delegating to Spring MVC. This functionality is currently
            experimental.
        </p>
        <p>
            In order for RESTEasy to be able to process Spring <code class="code">@RestController</code>, you first need to include
            the following
            dependency.
        </p>
        <p>
            </p><pre><code class="no-highlight">&lt;dependency&gt;
    &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
    &lt;artifactId&gt;resteasy-spring-web&lt;/artifactId&gt;
    &lt;version&gt;4.7.10.Final&lt;/version&gt;
&lt;/dependency&gt;</code></pre><p>
        </p>
        <p>
            Currently RESTEasy does not auto-scan for <code class="code">@RestController</code> annotated classes,
            so you need to add all <code class="code">@RestController</code> annotated classes to your <code class="code">web.xml</code> file as
            shown in the following
            example.
        </p>
        <pre><code class="no-highlight">&lt;web-app&gt;
   &lt;display-name&gt;RESTEasy application using Spring REST annotations&lt;/display-name&gt;

    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.scanned.resource.classes.with.builder&lt;/param-name&gt;
        &lt;param-value&gt;org.jboss.resteasy.spi.metadata.SpringResourceBuilder:org.example.Controller1,org.example.Controller2&lt;/param-value&gt;
    &lt;/context-param&gt;

   ...
&lt;/web-app&gt;</code></pre>
        <p>
            In the example above, <code class="code">Controller1</code> and <code class="code">Controller2</code> are registered and are expected
            to be annotated with
            <code class="code">@RestController</code>.
        </p>
        <p>
            The list of the currently supported annotations can be found below:
        </p>
        <div class="table" id="d5e3344"><div class="table-title">Table 48.1. </div><div class="table-contents">
            <table style="border-collapse: collapse;border-top: 1px solid ; border-bottom: 1px solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 1px  ; border-bottom: 1px  ; ">Annotation</th><th style="border-bottom: 1px  ; ">Comment</th></tr></thead><tbody><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">@RestController</td><td style="border-bottom: 1px  ; "> </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">@RequestMapping</td><td style="border-bottom: 1px  ; "> </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">@GetMapping</td><td style="border-bottom: 1px  ; "> </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">@PostMapping</td><td style="border-bottom: 1px  ; "> </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">@PutMapping</td><td style="border-bottom: 1px  ; "> </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">@DeleteMapping</td><td style="border-bottom: 1px  ; "> </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">@PatchMapping</td><td style="border-bottom: 1px  ; "> </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">@RequestParam</td><td style="border-bottom: 1px  ; "> </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">@RequestHeader</td><td style="border-bottom: 1px  ; "> </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">@MatrixVariable</td><td style="border-bottom: 1px  ; "> </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">@PathVariable</td><td style="border-bottom: 1px  ; "> </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">@CookieValue</td><td style="border-bottom: 1px  ; "> </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">@RequestBody</td><td style="border-bottom: 1px  ; "> </td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">@ResponseStatus</td><td style="border-bottom: 1px  ; ">Only supported as a method annotation</td></tr><tr><td style="border-right: 1px  ; ">@RequestParam</td><td> </td></tr></tbody></table>
        </div></div><br class="table-break"/>
        <p>
            Furthermore, the use of <code class="code">org.springframework.http.ResponseEntity</code> as a return value is
            supported as
            is the use of <code class="code">javax.servlet.http.HttpServletRequest</code> and
            <code class="code">javax.servlet.http.HttpServletResponse</code>
            as method parameters.
        </p>
        <p>To see an example of the usage, please check the <a class="ulink" href="https://github.com/resteasy/resteasy-examples/tree/master/resteasy-spring-rest">RESTEasy support of
            Spring REST annotations
        </a> sample project we provided.
        </p>
    </section>
    <section class="section" id="SpringBootStarter"><div class="titlepage"><div><div><h2 class="title">48.6. Spring Boot starter</h2></div></div></div>
        
        <p>
            The RESTEasy project has its support for Spring Boot integration. It was originally developed by PayPal team
            and has been donated to RESTEasy community. The project is currently maintained here:
            <a class="ulink" href="https://github.com/resteasy/resteasy-spring-boot">RESTEasy Spring Boot Starter Project</a>.
        </p>
        <p>
            Here is the usage in brief:
        </p>
        <p>Firstly, add dependency to your Spring Boot application:
            </p><pre><code class="no-highlight">&lt;dependency&gt;
   &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
   &lt;artifactId&gt;resteasy-spring-boot-starter&lt;/artifactId&gt;
   &lt;version&gt;${latest_version_of_restesy_spring_boot}&lt;/version&gt;
   &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</code></pre><p>
        </p>
        <p>
            And then you can use Spring annotation <code class="code">@Component</code> to register your JAX-RS <code class="code">Application
        </code> class:
            </p><pre><code class="no-highlight">package com.sample.app;

import org.springframework.stereotype.Component;
import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;

@Component
@ApplicationPath("/sample-app/")
public class JaxrsApplication extends Application {
}</code></pre><p>
        </p>
        <p>
            Finally, to register JAX-RS resources and providers, just define them as Spring beans, and they will be
            automatically registered. Notice that JAX-RS resources can be singleton or request scoped, while JAX-RS
            providers must be singletons.
        </p>
        <p>To see complete examples, please check the <a class="ulink" href="https://github.com/resteasy/resteasy-spring-boot/tree/master/sample-app">sample-app
        </a> in the project codebase.
        </p>
    </section>
    <section class="section" id="SpringUpgradeInWildfly"><div class="titlepage"><div><div><h2 class="title">48.7. Upgrading in WildFly</h2></div></div></div>
        
        <p>
            <span class="bold"><strong>Note.</strong></span>
            As noted in<a class="xref" href="#upgrading-wildfly" title="3.1.2. Upgrading RESTEasy within WildFly">Section 3.1.2, “Upgrading RESTEasy within WildFly”</a>, the RESTEasy distribution comes with a zip file
            called <code class="code">resteasy-jboss-modules-&lt;version&gt;.zip</code>,
            which can be unzipped into the modules/system/layers/base/ directory of WildFly to upgrade to a new version
            of RESTEasy.
            Because of the way resteasy-spring is used in WildFly, after unzipping the zip file, it is also necessary to
            remove the
            old resteasy-spring jar from
            modules/system/layers/base/org/jboss/resteasy/resteasy-spring/main/bundled/resteasy-spring-jar.
        </p>
    </section>
</section>

   <section class="chapter" id="CDI"><div class="titlepage"><div><div><h1 class="title">Chapter 49. CDI Integration</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="section"><a href="#d5e3425">49.1. Using CDI beans as JAX-RS components</a></span></li><li><span class="section"><a href="#d5e3432">49.2. Default scopes</a></span></li><li><span class="section"><a href="#d5e3444">49.3. Configuration within WildFly</a></span></li><li><span class="section"><a href="#d5e3447">49.4. Configuration with different distributions</a></span></li></ul></div>
    
    <p>This module provides integration with JSR-299 (Contexts and
        Dependency Injection for the Java EE platform)
    </p>
    <section class="section" id="d5e3425"><div class="titlepage"><div><div><h2 class="title">49.1. Using CDI beans as JAX-RS components</h2></div></div></div>
        
        <p>
            Both the JAX-RS and CDI specifications introduce their own
            component
            model. On the one hand, every class placed in a CDI archive that
            fulfills a set of basic constraints is implicitly a CDI bean. On
            the
            other hand, explicit decoration of your Java class with
            <code class="code">@Path</code>
            or
            <code class="code">@Provider</code>
            is required for it to become a JAX-RS component.
            Without the
            integration code, annotating a class suitable for being a CDI bean
            with
            JAX-RS annotations leads into a faulty result (JAX-RS component
            not managed by CDI)
            The
            resteasy-cdi module is a bridge that
            allows
            RESTEasy
            to work with class
            instances obtained from the CDI
            container.
        </p>
        <p>
            During a
            web
            service
            invocation, resteasy-cdi asks the CDI
            container
            for the
            managed
            instance
            of a JAX-RS component. Then, this
            instance is
            passed
            to
            RESTEasy.
            If a
            managed instance is not available for
            some
            reason (the
            class is
            placed
            in a jar which is not a bean deployment
            archive),
            RESTEasy
            falls back to
            instantiating the class itself.
        </p>
        <p>
            As a result, CDI services like injection, lifecycle management,
            events, decoration and interceptor bindings can be used in JAX-RS
            components.
        </p>
    </section>
    <section class="section" id="d5e3432"><div class="titlepage"><div><div><h2 class="title">49.2. Default scopes</h2></div></div></div>
        
        <p>
            A CDI bean that does not explicitly define a scope is
            <code class="code">@Dependent</code>
            scoped by default.
            This pseudo scope means that the bean adapts to the
            lifecycle of
            the bean it is
            injected into. Normal scopes (request,
            session,
            application) are more suitable for JAX-RS components as they
            designate component's lifecycle boundaries explicitly. Therefore, the
            resteasy-cdi
            module alters the default
            scoping in
            the following way:
        </p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                <p>
                    If a JAX-RS root resource does not define a scope
                    explicitly,
                    it is
                    bound to the Request scope.
                </p>
            </li><li class="listitem">
                <p>
                    If a JAX-RS Provider or
                    <code class="code">javax.ws.rs.Application</code>
                    subclass
                    does not define a scope explicitly, it is bound to the
                    Application
                    scope.
                </p>
            </li></ul></div>
        <div style="margin-left: 0.5in; margin-right: 0.5in;" class="warning"><h2>Warning</h2>
            <p>
                Since the scope of all beans that do not declare a scope is
                modified by resteasy-cdi, this affects session beans as well. As a
                result, a conflict occurs if the scope of a stateless session bean
                or singleton is changed automatically as the spec prohibits these
                components to
                be @RequestScoped.
                Therefore, you
                need to explicitly
                define a scope
                when using stateless session
                beans or singletons. This
                requirement is likely to
                be removed in
                future releases.
            </p>
        </div>
    </section>
    <section class="section" id="d5e3444"><div class="titlepage"><div><div><h2 class="title">49.3. Configuration within WildFly</h2></div></div></div>
        
        <p>
            CDI integration is provided with no additional configuration with WildFly.
        </p>
    </section>
    <section class="section" id="d5e3447"><div class="titlepage"><div><div><h2 class="title">49.4. Configuration with different distributions</h2></div></div></div>
        
        <p>
            Provided you have an
            existing RESTEasy application, all that needs to
            be done is to
            add the
            resteasy-cdi jar into your project's
            <code class="code">WEB-INF/lib</code>
            directory.
            When using
            maven, this can be achieve by defining the
            following
            dependency.
            </p><pre><code class="no-highlight">&lt;dependency&gt;
	&lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
	&lt;artifactId&gt;resteasy-cdi&lt;/artifactId&gt;
	&lt;version&gt;${project.version}&lt;/version&gt;
&lt;/dependency&gt;</code></pre><p>
        </p>
        <p>
            Furthermore, when running a pre-Servlet 3 container, the
            following context parameter needs to be specified in web.xml. (This
            is done
            automatically via web-fragment in a Servlet 3 environment)
        </p>
        <pre><code class="language-xml">&lt;context-param&gt;
	&lt;param-name&gt;resteasy.injector.factory&lt;/param-name&gt;
	&lt;param-value&gt;org.jboss.resteasy.cdi.CdiInjectorFactory&lt;/param-value&gt;
&lt;/context-param&gt;</code></pre>
        <p>
            When deploying an application to a Servlet container that does not
            support CDI out of the box
            (Tomcat, Jetty, Google App Engine), a CDI implementation needs to be
            added first.
            <a class="ulink" href="http://docs.jboss.org/weld/reference/latest/en-US/html/environments.html">Weld-servlet module
            </a>
            can be used for this purpose.
        </p>
    </section>
</section>

    <section class="chapter" id="Guice1"><div class="titlepage"><div><div><h1 class="title">Chapter 50. Guice 3.0 Integration</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="section"><a href="#d5e3465">50.1. Request Scope</a></span></li><li><span class="section"><a href="#d5e3469">50.2. Binding JAX-RS utilities</a></span></li><li><span class="section"><a href="#d5e3472">50.3. Configuring Stage</a></span></li><li><span class="section"><a href="#d5e3476">50.4. Custom Injector creation</a></span></li></ul></div>
    
    <p>RESTEasy has some simple integration with Guice 3.0.  RESTEasy will scan the binding types for a Guice Module
        for @Path and @Provider annotations.  It will register these bindings with RESTEasy.  The guice-hello
    project that comes in the RESTEasy examples/ directory gives a nice example of this.</p>
<pre><code class="no-highlight">
@Path("hello")
public class HelloResource
{
   @GET
   @Path("{name}")
   public String hello(@PathParam("name") final String name) {
      return "Hello " + name;
   }
}
</code></pre>
    <p>First you start off by specifying a JAX-RS resource class.  The HelloResource is just that.  Next you
    create a Guice Module class that defines all your bindings:</p>
<pre><code class="no-highlight">
import com.google.inject.Module;
import com.google.inject.Binder;

public class HelloModule implements Module
{
    public void configure(final Binder binder)
    {
       binder.bind(HelloResource.class);
    }
}
</code></pre>
    <p>You put all these classes somewhere within your WAR WEB-INF/classes or in a JAR within WEB-INF/lib.  Then
    you need to create your web.xml file.  You need to use the GuiceResteasyBootstrapServletContextListener as
    follows</p>
<pre><code class="no-highlight">

&lt;web-app&gt;
    &lt;display-name&gt;Guice Hello&lt;/display-name&gt;

    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.guice.modules&lt;/param-name&gt;
        &lt;param-value&gt;org.jboss.resteasy.examples.guice.hello.HelloModule&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;listener&gt;
        &lt;listener-class&gt;
            org.jboss.resteasy.plugins.guice.GuiceResteasyBootstrapServletContextListener
        &lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
        &lt;servlet-class&gt;
            org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher
        &lt;/servlet-class&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;

</code></pre>
    <p>GuiceResteasyBootstrapServletContextListener is a subclass of ResteasyBootstrap, so you can use
    any other RESTEasy configuration option within your web.xml file.  Also notice that there is a
    resteasy.guice.modules context-param.  This can take a comma delimited list of class names that
    are Guice Modules.</p>
    <section class="section" id="d5e3465"><div class="titlepage"><div><div><h2 class="title">50.1. Request Scope</h2></div></div></div>
      
      <p>
        Add the RequestScopeModule to your modules to allow objects to be scoped to the HTTP request by adding
        the @RequestScoped annotation to your fields in resource classes. All the objects injectable via the @Context annotation are 
        also injectable, except ServletConfig and ServletContext.
        Note that RequestScopeModule will already be added if any of your modules extends com.google.inject.servlet.ServletModule.
        In such cases you should not add it again to avoid injector creation errors.
      </p>
<pre><code class="no-highlight">

import javax.inject.Inject;
import javax.servlet.http.HttpServletRequest;
import javax.ws.rs.core.Context;

import org.jboss.resteasy.plugins.guice.RequestScoped;

public class MyClass
{
    @Inject @RequestScoped @Context
    private HttpRequest request;
}

</code></pre>
    </section>
    <section class="section" id="d5e3469"><div class="titlepage"><div><div><h2 class="title">50.2. Binding JAX-RS utilities</h2></div></div></div>
        
        <p>
            Add the JaxrsModule to bind javax.ws.rs.ext.RuntimeDelegate, javax.ws.rs.core.Response.ResponseBuilder, javax.ws.rs.core.UriBuilder, javax.ws.rs.core.Variant.VariantListBuilder and org.jboss.resteasy.client.ClientExecutor.
        </p>
    </section>
    <section class="section" id="d5e3472"><div class="titlepage"><div><div><h2 class="title">50.3. Configuring Stage</h2></div></div></div>
        
        <p>
            You can configure the stage Guice uses to deploy your modules by specific a context param, resteasy.guice.stage.
            If this value is not specified, RESTEasy uses whatever Guice's default is.
        </p>
<pre><code class="no-highlight">

&lt;web-app&gt;
    &lt;display-name&gt;Guice Hello&lt;/display-name&gt;

    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.guice.modules&lt;/param-name&gt;
        &lt;param-value&gt;org.jboss.resteasy.examples.guice.hello.HelloModule&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.guice.stage&lt;/param-name&gt;
        &lt;param-value&gt;PRODUCTION&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;listener&gt;
        &lt;listener-class&gt;
            org.jboss.resteasy.plugins.guice.GuiceResteasyBootstrapServletContextListener
        &lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
        &lt;servlet-class&gt;
            org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher
        &lt;/servlet-class&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;

</code></pre>        
    </section>
    <section class="section" id="d5e3476"><div class="titlepage"><div><div><h2 class="title">50.4. Custom Injector creation</h2></div></div></div>
      
      <p>
        GuiceResteasyBootstrapServletContextListener can be extended to allow more flexibility in the way the Injector and Modules
        are created.  Three methods can be overridden: getModules(), withInjector() and getStage(). Register your subclass as the
        listener in the web.xml.
      </p>
      <p>
        Override getModules() when you need to pass arguments to your modules' constructor or perform more complex operations.
      </p>
      <p>
        Override withInjector(Injector) when you need to interact with the Injector after it has been created.
      </p>
      <p>
        Override getStage(ServletContext) to set the Stage yourself.
      </p>
<pre><code class="no-highlight">

&lt;web-app&gt;
    &lt;!-- other tags omitted --&gt;
    &lt;listener&gt;
      &lt;listener-class&gt;
         org.jboss.resteasy.plugins.guice.GuiceResteasyBootstrapServletContextListener
      &lt;/listener-class&gt;
    &lt;/listener&gt;
&lt;/web-app&gt;

public class MyServletContextListener extends GuiceResteasyBootstrapServletContextListener
{

    @Override
    protected List&lt;? extends Module&gt; getModules(ServletContext context)
    {
        return Arrays.asList(new JpaPersistModule("consulting_hours"), new MyModule());
    }
    
    @Override
    public void withInjector(Injector injector)
    {
        injector.getInstance(PersistService.class).start();
    }
}

</code></pre>        
    </section>
</section>

   <section class="chapter" id="RESTEasy_Client_Framework"><div class="titlepage"><div><div><h1 class="title">Chapter 51. RESTEasy Client API</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="section"><a href="#d5e3485">51.1. JAX-RS 2.0 Client API</a></span></li><li><span class="section"><a href="#proxies">51.2. RESTEasy Proxy Framework</a></span><ul><li><span class="section"><a href="#Custom_client-side_responses">51.2.1. Abstract Responses</a></span></li><li><span class="section"><a href="#Response_proxies">51.2.2. Response proxies</a></span></li><li><span class="section"><a href="#ClientURI">51.2.3. Giving client proxy an ad hoc URI</a></span></li><li><span class="section"><a href="#Sharing_interfaces">51.2.4. Sharing an interface between client and server</a></span></li></ul></li><li><span class="section"><a href="#transport_layer">51.3. Apache HTTP Client 4.x and other backends</a></span><ul><li><span class="section"><a href="#http_redirect">51.3.1. HTTP redirect</a></span></li><li><span class="section"><a href="#https">51.3.2. Configuring SSL</a></span></li><li><span class="section"><a href="#http_proxy">51.3.3. HTTP proxy</a></span></li><li><span class="section"><a href="#apache_4_3">51.3.4. Apache HTTP Client 4.3 APIs</a></span></li><li><span class="section"><a href="#apache_asynch">51.3.5. Asynchronous HTTP Request Processing</a></span></li><li><span class="section"><a href="#jetty_client">51.3.6. Jetty Client Engine</a></span></li><li><span class="section"><a href="#vertx_client">51.3.7. Vertx Client Engine</a></span></li><li><span class="section"><a href="#reactor_netty_client">51.3.8. Reactor Netty Client Engine</a></span></li></ul></li></ul></div>
    

    <section class="section" id="d5e3485"><div class="titlepage"><div><div><h2 class="title">51.1. JAX-RS 2.0 Client API</h2></div></div></div>
        
        <p>JAX-RS 2.0 introduces a new client API so that you can make http requests to your remote RESTful web services.
        It is a 'fluent' request building API with really 3 main classes:  Client, WebTarget, and Response.  The Client
        interface is a builder of WebTarget instances.  WebTarget represents a distinct URL or URL template from which
        you can build more sub-resource WebTargets or invoke requests on.</p>
        <p>
            There are really two ways to create a Client.  Standard way, or you can use the ResteasyClientBuilder class.
            The advantage of the latter is that it gives you a few more helper methods to configure your client.
        </p>
        <pre><code class="no-highlight">
            Client client = ClientBuilder.newClient();
            ... or...
            Client client = ClientBuilder.newBuilder().build();
            WebTarget target = client.target("http://foo.com/resource");
            Response response = target.request().get();
            String value = response.readEntity(String.class);
            response.close();  // You should close connections!

            Client client = ClientBuilder.newClient();
            WebTarget target = client.target("http://foo.com/resource");
        </code></pre>
        <p>
            RESTEasy will automatically load a set of default providers. (Basically all classes listed in all
            META-INF/services/javax.ws.rs.ext.Providers files).  Additionally, you can manually register other providers,
            filters, and interceptors through the Configuration object provided by the method call Client.configuration().
            Configuration also lets you set various configuration properties that may be needed.
        </p>
        <p>
            Each WebTarget has its own Configuration instance which inherits the components and properties registered with
            its parent.  This allows you to set specific configuration options per target resource.  For example, username
            and password.
        </p>
        
        <p>
        One RESTEasy extension to the client API is the ability to specify that requests should be sent in "chunked" transfer mode.
        There are two ways of doing that. One is to configure an <code class="classname">org.jboss.resteasy.client.jaxrs.ResteasyWebTarget</code>
        so that all requests to that target are sent in chunked mode:
        </p>
        
        <pre><code class="no-highlight">
      ResteasyClient client = (ResteasyClient)ClientBuilder.newClient();
      ResteasyWebTarget target = client.target("http://localhost:8081/test");
      target.setChunked(b.booleanValue());
      Invocation.Builder request = target.request();
        </code></pre>
        
        <p>
        Alternatively, it is possible to configure a particular request to be sent in chunked mode:
        </p>
        
        <pre><code class="no-highlight">
      ResteasyClient client = (ResteasyClient)ClientBuilder.newClient();
      ResteasyWebTarget target = client.target("http://localhost:8081/test");
      ClientInvocationBuilder request = (ClientInvocationBuilder) target.request();
      request.setChunked(b);
        </code></pre>
        
        <p>
        Note that <code class="classname">org.jboss.resteasy.client.jaxrs.internal.ClientInvocationBuilder</code>,
        unlike <code class="classname">javax.ws.rs.client.Invocation.Builder</code>, is a RESTEasy class.
        </p>
        
        <p>
        <span class="bold"><strong>Note. </strong></span> The ability to send in chunked mode depends on the underlying
        transport layer; in particular, it depends on which implementation of
        <code class="classname">org.jboss.resteasy.client.jaxrs.ClientHttpEngine</code> is being used. Currently,
        only the default implementation, <code class="classname">ApacheHttpClient43Engine</code>,
        supports chunked mode. See Section <a class="link" href="#transport_layer" title="51.3. Apache HTTP Client 4.x and other backends">Apache HTTP Client 4.x and other backends</a>
        for more information.
        </p>

		<div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2>
			<p>
	          To follow REST principles and avoid introducing state management in applications, <code class="classname">javax.ws.rs.client.Client</code> instances do not provide support for cookie management by default.
	          However, you can enable it if necessary using <code class="classname">ResteasyClientBuilder</code>:
			</p>
			<pre><code class="no-highlight">
				Client client = ((ResteasyClientBuilder) ClientBuilder.newBuilder()).enableCookieManagement().build();
			</code></pre>
		</div>
    </section>
    <p>

    </p>

    <section class="section" id="proxies"><div class="titlepage"><div><div><h2 class="title">51.2. RESTEasy Proxy Framework</h2></div></div></div>
        
    <p>

        The RESTEasy Proxy  Framework is the mirror opposite of the JAX-RS server-side specification. Instead of using
        JAX-RS annotations to map an incoming request to your RESTFul Web Service method, the client framework builds an
        HTTP request that it uses to invoke on a remote RESTful Web Service. This remote service does not have to be a
        JAX-RS service and can be any web resource that accepts HTTP requests.
    </p>
    <p>

        RESTEasy has a client proxy framework that allows you to use JAX-RS annotations to invoke on a remote HTTP
        resource.
        The way it works is that you write a Java interface and use JAX-RS annotations on methods and the interface. For
        example:
    </p>
    <p>

</p><pre><code class="no-highlight">
public interface SimpleClient
{
   @GET
   @Path("basic")
   @Produces("text/plain")
   String getBasic();

   @PUT
   @Path("basic")
   @Consumes("text/plain")
   void putBasic(String body);

   @GET
   @Path("queryParam")
   @Produces("text/plain")
   String getQueryParam(@QueryParam("param")String param);

   @GET
   @Path("matrixParam")
   @Produces("text/plain")
   String getMatrixParam(@MatrixParam("param")String param);

   @GET
   @Path("uriParam/{param}")
   @Produces("text/plain")
   int getUriParam(@PathParam("param")int param);
}</code></pre><p>
    </p>
    <p>

        RESTEasy has a simple API based on Apache HttpClient. You generate a proxy then you can invoke methods on the
        proxy. The invoked method gets translated to an HTTP request based on how you annotated the method and posted to
        the server. Here's how you would set this up:
    </p>
    <p>

        </p><pre><code class="no-highlight">
            Client client = ClientBuilder.newClient();
            WebTarget target = client.target("http://example.com/base/uri");
            ResteasyWebTarget rtarget = (ResteasyWebTarget)target;

            SimpleClient simple = rtarget.proxy(SimpleClient.class);
            simple.putBasic("hello world");
        </code></pre><p>
        Alternatively you can use the RESTEasy client extension interfaces directly:
        </p><pre><code class="no-highlight">
            ResteasyClient client = (ResteasyClient)ClientBuilder.newClient();
            ResteasyWebTarget target = client.target("http://example.com/base/uri");

            SimpleClient simple = target.proxy(SimpleClient.class);
            simple.putBasic("hello world");
        </code></pre><p>

    </p>
    <p>

        @CookieParam works the mirror opposite of its server-side counterpart and creates a cookie header to send to the
        server. You do not need to use @CookieParam if you allocate your own javax.ws.rs.core.Cookie object and pass it
        as
        a parameter to a client proxy method. The client framework understands that you are passing a cookie to the
        server
        so no extra metadata is needed.
    </p>
    <p>
     The framework also supports the JAX-RS locator pattern, but on the client side.  So, if you have a method annotated only with @Path, that proxy method
     will return a new proxy of the interface returned by that method.
    </p>
    <section class="section" id="Custom_client-side_responses"><div class="titlepage"><div><div><h3 class="title">51.2.1. Abstract Responses</h3></div></div></div>
        

        <p>

            Sometimes you are interested not only in the response body of a client request, but also either the response
            code and/or response headers. The Client-Proxy framework has two ways to get at this information
        </p>
        <p>


        </p>
        <p>

            You may return a javax.ws.rs.core.Response.Status enumeration from your method calls:
        </p>
        <p>

            </p><pre><code class="no-highlight">
@Path("/")
public interface MyProxy {
   @POST
   Response.Status updateSite(MyPojo pojo);
}
            </code></pre><p>
        </p>
        <p>

            Internally, after invoking on the server, the client proxy internals will convert the HTTP response code into
            a
            Response.Status enum.
        </p>
        <p>


        </p>
        <p>

            If you are interested in everything, you can get it with the javax.ws.rs.core.Response class:
        </p>
        <p>

            </p><pre><code class="no-highlight">
@Path("/")
public interface LibraryService {

   @GET
   @Produces("application/xml")
   Response getAllBooks();
}</code></pre><p>
        </p>
     </section>
     
    <section class="section" id="Response_proxies"><div class="titlepage"><div><div><h3 class="title">51.2.2. Response proxies</h3></div></div></div>
        
        <p>
           A further extension implemented by the RESTEasy client proxy framework is the "response proxy facility",
           where a client proxy method returns an interface that represents the information
           contained in a <code class="classname">javax.ws.rs.core.Response</code>. Such an interface must be annotated with
           <code class="classname">@ResponseObject</code> from package <code class="classname">org.jboss.resteasy.annotations</code>,
           and its methods may be further annotated with <code class="classname">@Body</code>, <code class="classname">@LinkHeaderParam</code>,
           and <code class="classname">@Status</code> from the same package,  as well as <code class="classname">javax.ws.rs.HeaderParam</code>.
           Consider the following example.
        </p>
        
        <pre><code class="no-highlight">
   @ResponseObject
   public interface TestResponseObject {
      
      @Status
      int status();

      @Body
      String body();

      @HeaderParam("Content-Type")
      String contentType();
      
      ClientResponse response();
   }

   @Path("test")
   public interface TestClient {
   
      @GET
      TestResponseObject get();
   }

   @Path("test")
   public static class TestResource {

      @GET
      @Produces("text/plain")
      public String get() {
         return "ABC";
      }
   }
        </code></pre>
        
        <p>
           Here, <code class="classname">TestClient</code> will define the client side proxy for <code class="classname">TestResource</code>.
           Note that <code class="methodname">TestResource.get()</code> returns a <code class="classname">String</code> but the proxy
           based on <code class="classname">TestClient</code> will return a <code class="classname">TestResponseObject</code> on a 
           call to <code class="methodname">get()</code>:
        </p>

        <pre><code class="no-highlight">
      Client client = ClientBuilder.newClient();
      TestClient ClientInterface = ProxyBuilder.builder(TestClient.class, client.target("http://localhost:8081")).build();
      TestResponseObject tro = ClientInterface.get();
        </code></pre>
        
        <p>
           The methods of <code class="classname">TestResponseObject</code> provide access to various pieces of information about the
           response received from <code class="methodname">TestResponse.get()</code>. This is where the annotations on those methods
           come into play. <code class="methodname">status()</code> is annotated with <code class="classname">@Status</code>, and a call to
           <code class="methodname">status()</code> returns the HTTP status. Similarly, <code class="methodname">body()</code> returns the
           returned entity, and <code class="methodname">contentType()</code> returns the value of the response header Content-Type:
        </p>
        
        <pre><code class="no-highlight">
      System.out.println("status: " + tro.status());
      System.out.println("entity: " + tro.body());
      System.out.println("Content-Type: " + tro.contentType());
        </code></pre>
        
        <p>
           will yield
        </p>

        <pre><code class="no-highlight">
status: 200
entity: ABC
Content-Type: text/plain;charset=UTF-8        
        </code></pre>
        
        <p>
           Note that there is one other method in <code class="classname">TestResponseObject</code>, <code class="methodname">response()</code>,
           that has no annotation. When RESTEasy sees a method in an interface annotated with <code class="classname">@ResponseObject</code>
           that returns a <code class="classname">javax.ws.rs.core.Response</code> (or a subclass thereof), it will return a
           <code class="classname">org.jboss.resteasy.client.jaxrs.internal.ClientResponse</code>. For example,
        </p>
        
        <pre><code class="no-highlight">
      ClientResponse clientResponse =  tro.response();
      System.out.println("Content-Length: " + clientResponse.getLength());
        </code></pre>
        
        <p>
           Perhaps the most interesting piece of the response proxy facility is the treatment of methods 
           annotated with <code class="classname">@LinkHeaderParam</code>. Its simplest use is to assist in 
           accessing a <code class="classname">javax.ws.rs.core.Link</code> returned by a resource method. For 
           example, let's add
        </p>
        
        <pre><code class="no-highlight">
      @GET
      @Path("/link-header")
      public Response getWithHeader(@Context UriInfo uri) {
         URI subUri = uri.getAbsolutePathBuilder().path("next-link").build();
         Link link = new LinkBuilderImpl().uri(subUri).rel("nextLink").build();
         return Response.noContent().header("Link", link.toString()).build();
      }
        </code></pre>
        
        <p>
           to <code class="classname">TestResource</code>, add
        </p>
        
        <pre><code class="no-highlight">
       @GET
       @Path("link-header")
       ResponseObjectInterface performGetBasedOnHeader();
        </code></pre>
        
        <p>
           to <code class="classname">ClientInterface</code>, and add
        </p>
        
        <pre><code class="no-highlight">
       @LinkHeaderParam(rel = "nextLink")
       URI nextLink();
        </code></pre>
        
        <p>
           to <code class="classname">ResponseObjectInterface</code>. Then calling       
        </p>
        
        <pre><code class="no-highlight">
      ResponseObjectInterface obj = ClientInterface.performGetBasedOnHeader();
      System.out.println("nextLink(): " + obj.nextLink());
        </code></pre>
        
        <p>
           will access the <code class="classname">LinkHeader</code> returned by <code class="methodname">TestResource.getWithHeader()</code>:
        </p>
        
        <pre><code class="no-highlight">
nextlink: http://localhost:8081/test/link-header/next-link
        </code></pre>
        
        <p>
           Last but not least, let's add
        </p>
        
        <pre><code class="no-highlight">
      @GET
      @Produces("text/plain")
      @Path("/link-header/next-link")
      public String getHeaderForward() {
         return "forwarded";
      }
        </code></pre>
        
        <p>
           to <code class="classname">TestResource</code> and
        </p>
        
        <pre><code class="no-highlight">
       @GET
       @LinkHeaderParam(rel = "nextLink")
       String followNextLink();
        </code></pre>
        
        <p>
           to <code class="classname">ResponseObjectInterface</code>. Note that, unlike
           <code class="methodname">ResponseObjectInterface.nextLink()</code>, <code class="methodname">followNextLink()</code>
           is annotated with <code class="classname">@GET</code>; that is, it qualifies as (the client proxy to) a resource
           method. When executing <code class="methodname">followNextLink()</code>, RESTEasy will retrieve the value
           of the <code class="classname">Link</code> returned by <code class="methodname">TestResource.getWithHeader()</code>
           and then will make a GET invocation on the <code class="classname">URL</code> in that <code class="classname">Link</code>.
           Calling
        </p>
        
        <pre><code class="no-highlight">
      System.out.println("followNextLink(): " + obj.followNextLink());
        </code></pre>
        
        <p>
           causes RESTEasy to retrieve the <code class="classname">URL</code> http://localhost:8081/test/link-header/next-link
           from the call to <code class="methodname">TestResource.getWithHeader()</code> and then perform a GET on it,
           invoking <code class="methodname">TestResource.getHeaderForward()</code>:
        </p>
        
        <pre><code class="no-highlight">
followNextLink(): forwarded
        </code></pre>
        
        <p><span class="bold"><strong>Note.</strong></span> This facility for extracting a <code class="classname">URL</code>
        and following it is a step toward supporting the Representation State Transfer principle of HATEOAS.
        For more information, see
        <a class="ulink" href="http://shop.oreilly.com/product/0636920028925.do">RESTful Java with JAX-RS 2.0, 2nd Edition</a>
        by Bill Burke.
        </p>
    </section>
    
    <section class="section" id="ClientURI"><div class="titlepage"><div><div><h3 class="title">51.2.3. Giving client proxy an ad hoc URI</h3></div></div></div>
      
      
      <p>
          Client proxies figure out appropriate URIs for targeting resource methods by looking at <code class="classname">@Path</code> 
          annotations in the client side interface, but it is also possible to pass URIs explicitly to the proxy through the
          use of the <code class="classname">org.jboss.resteasy.annotations.ClientURI</code> annotation. For example, let 
          <code class="classname">TestResource</code> be a client side interface and <code class="classname">TestResourceImpl</code> a server resource:
      </p>
      
      <pre><code class="no-highlight">
   @Path("")
   public interface TestResource {
      
      @GET
      @Path("dispatch")
      public String dispatch(@ClientURI String uri);
   }
   
   @Path("")
   public static class TestResourceImpl {
      
      @GET
      @Path("a")
      public String a() {
         return "a";
      }
      
      @GET
      @Path("b")
      public String b() {
         return "b";
      }
   }
      </code></pre>
      
      <p>
          Calling <code class="methodname">TestResource.dispatch()</code> allows specifying a specific URI for accessing a resource method. In the
          following, let BASE_URL be the address of the <code class="classname">TestResourceImpl</code> resource.
      </p>
      
      <pre><code class="no-highlight">
   private static String BASE_URL = "http://localhost:8081/";
   ...
   public void test() throws Exception
   {
      ResteasyClient client = (ResteasyClient)ClientBuilder.newClient();
      TestResource proxy = client.target(BASE_URL).proxy(TestResource.class);
      String name = proxy.dispatch(BASE_URL + "a");
      System.out.println("name: " + name);
      name = proxy.dispatch(BASE_URL + "b");
      System.out.println("name: " + name);
      client.close();
   }
      </code></pre>
      
      <p>
          Then passing "http://localhost:8081/a" and "http://localhost/b" to <code class="methodname">dispatch()</code> invokes
          <code class="methodname">TestResourceImp.a()</code> and <code class="methodname">TestResourceImpl.b()</code> respectively, yielding
          the output
      </p>
      
      <pre><code class="no-highlight">
name: a
name: b
      </code></pre>
    </section>
    
    <section class="section" id="Sharing_interfaces"><div class="titlepage"><div><div><h3 class="title">51.2.4. Sharing an interface between client and server</h3></div></div></div>
        
        <p>
            It is generally possible to share an interface between the client and server. In this scenario, you just
            have your JAX-RS services implement an annotated interface
            and then reuse that same interface to create client proxies to invoke on the client-side.
        </p>

    </section>
    </section>
    
    
    

   
   <section class="section" id="transport_layer"><div class="titlepage"><div><div><h2 class="title">51.3. Apache HTTP Client 4.x and other backends</h2></div></div></div>
     

       <p>
           Network communication between the client and server is handled by default in RESTEasy.
           The interface between the RESTEasy Client Framework and the network
           is defined by RESTEasy's <code class="code">ClientHttpEngine</code> interface.
           RESTEasy ships with multiple implementations of this interface.
       </p>
       <p>
           The default
           implementation is <code class="code">ApacheHttpClient43Engine</code>, which uses
           version 4.3 of the <code class="code">HttpClient</code> from the Apache
           <code class="code">HttpComponents</code> project.
       </p>
       <p>
           <code class="code">ApacheHttpAsyncClient4Engine</code>, instead, is built on top
           of <span class="emphasis"><em>HttpAsyncClient</em></span> (still from the Apache
           <span class="emphasis"><em>HttpComponents</em></span> project) with internally dispatches requests
           using a non-blocking IO model.
       </p>
       <p>
           <code class="code">JettyClientEngine</code> is built on top
           of <span class="emphasis"><em>Eclipse Jetty</em></span> HTTP engine, which is possibly an interesting
           option for those already running on the Jetty server.
       </p>
       <p>
           <code class="code">VertxClientHttpEngine</code> is built on top
           of <span class="emphasis"><em>Eclipse Vert.x</em></span>, which provides a non-blocking HTTP client based
           on Vert.x framework.
       </p>
       <p>
           <code class="code">ReactorNettyClientHttpEngine</code> is built on top
           of <span class="emphasis"><em>Reactor Netty</em></span>, which provides a non-blocking HTTP client based
           on Netty framework.
       </p>
       <p>
           Finally,
           <code class="code">InMemoryClientEngine</code> is
           an implementation that dispatches requests to a server in the same JVM and
           <code class="code">URLConnectionEngine</code> is an implementation that uses
           <code class="code">java.net.HttpURLConnection</code>.
       </p>

       <div class="table" id="d5e3660"><div class="table-title">Table 51.1. </div><div class="table-contents">
           <table style="border-collapse: collapse;border-top: 1px solid ; border-bottom: 1px solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 1px  ; border-bottom: 1px  ; ">RESTEasy ClientHttpEngine implementations</th><th style="border-bottom: 1px  ; "> </th></tr></thead><tbody><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">ApacheHttpClient43Engine</td><td style="border-bottom: 1px  ; ">Uses HttpComponents HttpClient 4.3+</td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">ApacheHttpAsyncClient4Engine</td><td style="border-bottom: 1px  ; ">Uses HttpComponents HttpAsyncClient</td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">JettyClientEngine</td><td style="border-bottom: 1px  ; ">Uses Eclipse Jetty</td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">ReactorNettyClientHttpEngine</td><td style="border-bottom: 1px  ; ">Uses Reactor Netty</td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">VertxClientHttpEngine</td><td style="border-bottom: 1px  ; ">Uses Eclipse Vert.x</td></tr><tr><td style="border-right: 1px  ; border-bottom: 1px  ; ">InMemoryClientEngine</td><td style="border-bottom: 1px  ; ">Dispatches requests to a server in the same JVM</td></tr><tr><td style="border-right: 1px  ; ">URLConnectionEngine</td><td>Uses java.net.HttpURLConnection</td></tr></tbody></table>
       </div></div><br class="table-break"/>

       <p>
           The RESTEasy Client Framework can also be customized.  The user can provide
           their own implementations of
           <code class="code">ClientHttpEngine</code> to the
           <code class="code">ResteasyClient</code>.
       </p>

       <pre><code class="no-highlight">
ClientHttpEngine myEngine = new ClientHttpEngine() {
    protected SSLContext sslContext;
    protected HostnameVerifier hostnameVerifier;


    @Override
    public ClientResponse invoke(ClientInvocation request) {
        // implement your processing code and return a
        // org.jboss.resteasy.client.jaxrs.internal.ClientResponse
        // object.
    }

    @Override
    public SSLContext getSslContext() {
       return sslContext;
    }

    @Override
    public HostnameVerifier getHostnameVerifier() {
       return hostnameVerifier;
    }

    @Override
    public void close() {
       // do nothing
    }
};

ResteasyClient client = ((ResteasyClientBuilder)ClientBuilder.newBuilder()).httpEngine(myEngine).build();
       </code></pre>

       <p>
           RESTEasy and <code class="classname">HttpClient</code> make reasonable default decisions so
           that it is possible to use the client framework without ever referencing
           <code class="classname">HttpClient</code>. For some applications it may be necessary to drill
           down into the <code class="classname">HttpClient</code> details.
           <code class="classname">ApacheHttpClient43Engine</code> can
           be supplied with an instance of
           <code class="classname">org.apache.http.client.HttpClient</code> and an instance of
           <code class="classname">org.apache.http.protocol.HttpContext</code>, which can carry
           additional configuration details into the <code class="classname">HttpClient</code> layer.

       </p>
           <code class="classname">HttpContextProvider</code>
           is a RESTEasy provided interface through which a custom
           <code class="classname">HttpContext</code> is supplied to
           <code class="classname">ApacheHttpClient43Engine</code>.
       <p>

       </p><pre><code class="no-highlight">
package org.jboss.resteasy.client.jaxrs.engines;

import org.apache.http.protocol.HttpContext;

public interface HttpContextProvider {
   HttpContext getContext();
}
       </code></pre><p>

       </p>

       <p>
           Here is an example of providing a custom HttpContext
       </p>

       <pre><code class="no-highlight">
DefaultHttpClient httpClient = new DefaultHttpClient();
ApacheHttpClient43Engine engine = new ApacheHttpClient43Engine(httpClient,
   new HttpContextProvider() {
           @Override
           public HttpContext getContext() {
              // Configure HttpClient to authenticate preemptively
              // by prepopulating the authentication data cache.
              // 1. Create AuthCache instance
              AuthCache authCache = new BasicAuthCache();
              // 2. Generate BASIC scheme object and add it to the local auth cache
              BasicScheme basicAuth = new BasicScheme();
              authCache.put(getHttpHost(url), basicAuth);
              // 3. Add AuthCache to the execution context
              BasicHttpContext localContext = new BasicHttpContext();
              localContext.setAttribute(ClientContext.AUTH_CACHE, authCache);
              return localContext;
           }
});
       </code></pre>

    <section class="section" id="http_redirect"><div class="titlepage"><div><div><h3 class="title">51.3.1. HTTP redirect</h3></div></div></div>
      
      <p>
         The <code class="classname">ClientHttpEngine</code> implementations based on Apache
         <code class="classname">HttpClient</code> support HTTP redirection.
         The feaure is disabled by default and has to be enabled by users explicitly:
         </p><pre><code class="no-highlight">
ApacheHttpClient43Engine engine = new ApacheHttpClient43Engine();
engine.setFollowRedirects(true);
Client client = ((ResteasyClientBuilder)ClientBuilder.newBuilder()).httpEngine(engine).build();
     </code></pre><p>
      </p>
    </section>
    <section class="section" id="https"><div class="titlepage"><div><div><h3 class="title">51.3.2. Configuring SSL</h3></div></div></div>
        
        <p>
            To enable SSL on client, a <code class="classname">ClientHttpEngine</code> containing a SSLContext can be created to build
            client as in the following example:
            </p><pre><code class="no-highlight">
ClientHttpEngine myEngine = new ClientHttpEngine() {
   ...
   public void setSslContext(SSLContext sslContext) {
      this.sslContext = sslContext;
   }

   @Override
   public HostnameVerifier getHostnameVerifier() {
      return hostnameVerifier;
   }
};
myEngine.setSslContext(mySslContext)
ResteasyClient client = ((ResteasyClientBuilder)ClientBuilder.newBuilder()).httpEngine(myEngine).build();
            </code></pre><p>
            An alternative is to set up a keystore and truststore and pass a custom SslContext to ClientBuilder:
            </p><pre><code class="no-highlight">
Client sslClient = ClientBuilder.newBuilder().sslContext(mySslContext).build();
            </code></pre><p>
            If you don't want to create a SSLContext, you can build client with a keystore and truststore. Note if both
            SSLContext and keystore/truststore are configured, the later will be ignored by Resteasy ClientBuilder.
            </p><pre><code class="no-highlight">
Client sslClient = ClientBuilder.newBuilder().keystore(keystore,mypassword).
                      trustKeystore(trustStore).build();
            </code></pre><p>
            During handshaking, a custom HostNameVerifier can be called to allow the connection if URL's hostname and
            the server's identification hostname match.
            </p><pre><code class="no-highlight">
Client sslClient =  ((ResteasyClientBuilder)ClientBuilder.newBuilder()).sslContext(mysslContext)
                       .hostnameVerifier(myhostnameVerifier).build();
            </code></pre><p>
            Resteasy provides another simple way to set up a HostnameVerifier. It allows configuring ResteasyClientBuilder with
            a <code class="classname">HostnameVerificationPolicy</code> without creating a custom HostNameVerifier:
            </p><pre><code class="no-highlight">
Client sslClient =  ((ResteasyClientBuilder)ClientBuilder.newBuilder()).sslContext(mysslContext)
                       .hostnameVerification(ResteasyClientBuilder.HostnameVerificationPolicy.ANY).build();
            </code></pre><p>
            </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Setting HostnameVerificationPolicy.ANY will allow all connections without a check.</li><li class="listitem">HostnameVerificationPolicy.WILDCARD only allows wildcards in subdomain names i.e. *.foo.com.</li><li class="listitem">HostnameVerificationPolicy.STRICT checks if DNS names match the content of the Public Suffix List
            (https://publicsuffix.org/list/public_suffix_list.dat). Please note if this public suffix list isn't the check
            you want, you should create your own HostNameVerifier instead of this policy setting.</li></ul></div><p>
        </p>
    </section>
    <section class="section" id="http_proxy"><div class="titlepage"><div><div><h3 class="title">51.3.3. HTTP proxy</h3></div></div></div>
      
      <p>
         The <code class="classname">ClientHttpEngine</code> implementations based on Apache
         <code class="classname">HttpClient</code> support HTTP proxy.
         This feature can be enabled by setting specific properties on the builder:
         </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="classname">org.jboss.resteasy.jaxrs.client.proxy.host</code></li><li class="listitem"><code class="classname">org.jboss.resteasy.jaxrs.client.proxy.port</code></li><li class="listitem"><code class="classname">org.jboss.resteasy.jaxrs.client.proxy.scheme</code></li></ul></div><p>
         </p><pre><code class="no-highlight">
Client client = ClientBuilder.newBuilder().property("org.jboss.resteasy.jaxrs.client.proxy.host", "someproxy.com").property("org.jboss.resteasy.jaxrs.client.proxy.port", 8080).build();
     </code></pre><p>
      </p>
    </section>
    <section class="section" id="apache_4_3"><div class="titlepage"><div><div><h3 class="title">51.3.4. Apache HTTP Client 4.3 APIs</h3></div></div></div>
        
     <p>
         The RESTEasy Client framework automatically creates and properly configures the underlying
         Apache HTTP Client engine. When the <code class="classname">ApacheHttpClient43Engine</code> is
         manually created, though, the user can either let it build and use a default
         <code class="classname">HttpClient</code> instance or provide a custom one:
     </p>
     <pre><code class="no-highlight">
public ApacheHttpClient43Engine() {
   ...
}

public ApacheHttpClient43Engine(HttpClient httpClient) {
   ...
}

public ApacheHttpClient43Engine(HttpClient httpClient, boolean closeHttpClient) {
   ...
}
     </code></pre>
     <p>
         The <span class="emphasis"><em>closeHttpClient</em></span> parameter on the last constructor above allows controlling
         whether the Apache <code class="classname">HttpClient</code> is to be closed upon engine finalization.
         The default value is <span class="emphasis"><em>true</em></span>. When a custom <code class="classname">HttpClient</code>
         instance is not provided, the default instance will always be closed together with the engine.
     </p>

     <p>
         For more information about HttpClient (4.x), see the documentation
         at <a class="ulink" href="http://hc.apache.org/httpcomponents-client-ga/tutorial/html/">
         http://hc.apache.org/httpcomponents-client-ga/tutorial/html/</a>.
     </p>
     
     <p>
         <span class="bold"><strong>Note.</strong></span> It is important to understand
         the difference between "releasing" a connection and "closing" a
         connection.  <span class="bold"><strong>Releasing</strong></span> a connection
         makes it available for reuse.  <span class="bold"><strong>Closing</strong></span>
         a connection frees its resources and makes it unusable.
     </p>

     <p>
         If an execution of a request or a call on
         a proxy returns a class other than <code class="classname">Response</code>,
         then RESTEasy will take care of releasing the connection.  For example,
         in the fragments
     </p>
     
     <pre><code class="no-highlight">
WebTarget target = client.target("http://localhost:8081/customer/123");
String answer = target.request().get(String.class);
     </code></pre>
     
     <p>
         or
     </p>
     
     <pre><code class="no-highlight">
ResteasyWebTarget target = client.target("http://localhost:8081/customer/123");
RegistryStats stats = target.proxy(RegistryStats.class);
RegistryData data = stats.get();
     </code></pre>
     
     <p>
        RESTEasy will release the connection under the covers.  The only counterexample is the case
        in which the response is an instance of <code class="classname">InputStream</code>, which must
        be closed explicitly.
     </p>
     
     <p>
         On the other hand, if the result of an invocation is an instance of
         <code class="classname">Response</code>, then Response.close() method must be used to released the connection.
     </p>
     
     <pre><code class="no-highlight">
WebTarget target = client.target("http://localhost:8081/customer/123");
Response response = target.request().get();
System.out.println(response.getStatus());
response.close();
     </code></pre>
     
     <p>
         You should probably execute this in a try/finally block.  Again, releasing a connection only makes it available
         for another use. <span class="bold"><strong>It does not normally close the socket.</strong></span>
     </p>
         
     <p>
         On the other hand,
         <code class="methodname">ApacheHttpClient43Engine.finalize()</code> will close any open
         sockets, unless the user set <span class="emphasis"><em>closeHttpClient</em></span> as <span class="emphasis"><em>false</em></span> when building
         the engine, in which case he is responsible for closing the connections.
     </p>
     
     <p>
         Note that if <code class="classname">ApacheHttpClient43Engine</code> has created its own
         instance of <code class="classname">HttpClient</code>, it is not necessary to wait
         for <code class="methodname">finalize()</code> to close open sockets.  The
         <code class="classname">ClientHttpEngine</code> interface has a <code class="methodname">close()</code>
         method for this purpose.
     </p>

    <p>
        If your javax.ws.rs.client.Client class has created the engine automatically for you, you should
        call Client.close() and this will clean up any socket connections.
    </p>

    <p>
        Finally, given having explicit <code class="methodname">finalize()</code> methods can badly affect performances, the 
        <code class="classname">org.jboss.resteasy.client.jaxrs.engines.ManualClosingApacheHttpClient43Engine</code> flavour
        of <code class="classname">org.jboss.resteasy.client.jaxrs.engines.ApacheHttpClient43Engine</code> can be used. With
        that the user is always responsible for calling <code class="methodname">close()</code> as no <code class="methodname">finalize()</code>
        is there to do that before object garbage collection.
    </p>

    </section>

    <section class="section" id="apache_asynch"><div class="titlepage"><div><div><h3 class="title">51.3.5. Asynchronous HTTP Request Processing</h3></div></div></div>
        
        <p>
            RESTEasy's default async engine implementation class is
            <span class="emphasis"><em>ApacheHttpAsyncClient4Engine</em></span>.  It can be set as the active
            engine by calling method <span class="emphasis"><em>useAsyncHttpEngine</em></span> in
            <span class="emphasis"><em>ResteasyClientBuilder</em></span>.
        </p>
        <pre><code class="no-highlight">
    Client asyncClient = ((ResteasyClientBuilder)ClientBuilder.newBuilder()).useAsyncHttpEngine()
                             .build();
    Future&lt;Response&gt; future = asyncClient
                             .target("http://locahost:8080/test").request()
                             .async().get();
    Response res = future.get();
    Assert.assertEquals(HttpResponseCodes.SC_OK, res.getStatus());
    String entity = res.readEntity(String.class);
        </code></pre>
        <section class="sect2" id="d5e3793"><div class="titlepage"><div><div><h3 class="title">51.3.5.1. InvocationCallbacks</h3></div></div></div>
            
            <p>
                InvocationCallbacks are called from within the io-threads and thus must not block or else
                the application may slow down to a halt. Reading the response is safe because the response
                is buffered in memory, as are other async and in-memory client-invocations that submit-calls
                returning a future not containing Response, InputStream or Reader.
            </p>
            <pre><code class="no-highlight">
   final CountDownLatch latch = new CountDownLatch(1);
   Future&lt;String&gt; future = nioClient.target(generateURL("/test")).request()
         .async().get(new InvocationCallback&lt;String&gt;()
                {
                   @Override
                   public void completed(String s)
                   {
                      Assert.assertEquals("get", s);
                      latch.countDown();
                      throw new RuntimeException("for the test of it");
                   }

                   @Override
                   public void failed(Throwable error)
                   {
                   }
                });
   String entity = future.get();
   Assert.assertEquals("get", entity);
            </code></pre>
            <p>
                InvocationCallbacks may be called seemingly "after" the future-object returns. Thus, responses
                should be handled solely in the InvocationCallback.
            </p>
            <p>
                InvocationCallbacks will see the same result as the future-object and vice versa. Thus, if the
                invocationcallback throws an exception, the future-object will not see it. This is the
                reason to handle responses only in the InvocationCallback.
            </p>

        </section>

        <section class="sect2" id="d5e3799"><div class="titlepage"><div><div><h3 class="title">51.3.5.2. Async Engine Usage Considerations</h3></div></div></div>
            
            <p>
                Asynchronous IO means non-blocking IO utilizing few threads, typically at most as many
                threads as number of cores.  As such, performance may profit from fewer thread switches
                and less memory usage due to fewer thread-stacks. But doing synchronous, blocking IO (the
                invoke-methods not returning a future) may suffer, because the data has to be transferred
                piecewise to/from the io-threads.
            </p>
            <p>
                Request-Entities are fully buffered in memory, thus <span class="emphasis"><em>HttpAsyncClient</em></span>
                is unsuitable for very large uploads.  Response-Entities are buffered in memory, except
                if requesting a Response, InputStream or Reader as Result. Thus for large downloads or
                COMET, one of these three return types must be requested, but there may be a performance
                penalty because the response-body is transferred piecewise from the io-threads. When
                using InvocationCallbacks, the response is always fully buffered in memory.
            </p>
        </section>
    </section>

    <section class="section" id="jetty_client"><div class="titlepage"><div><div><h3 class="title">51.3.6. Jetty Client Engine</h3></div></div></div>
        
        <p>
            As a drop in replacement, RESTEasy allows selecting a Jetty 9.4+ based HTTP engine.
            The Jetty implementation is newer and less tested, but it may end up being a good choice
            when relying on Jetty as server side already.  The Jetty Server can even share execution
            resources with Client libraries if you configure them to use e.g. the same QueuedThreadPool.
        </p>
        <p>
            The Jetty engine is enabled by adding a dependency to the <span class="emphasis"><em>org.jboss.resteasy:resteasy-client-jetty</em></span>
            artifact to the Maven project; then the client can be built as follows:
        </p>
        <pre><code class="no-highlight">
ResteasyClient client = ((ResteasyClientBuilder)ClientBuilder.newBuilder()).clientEngine(
   new JettyClientEngine(new HttpClient())).build();
        </code></pre>
    </section>

     <section class="section" id="vertx_client"><div class="titlepage"><div><div><h3 class="title">51.3.7. Vertx Client Engine</h3></div></div></div>
         
         <p>
           Still as a drop in replacement, RESTEasy allows selecting a Vert.x-based HTTP engine.
           The Vert.x implementation can perform asynchronous client invocations. It provides the following features:
         </p>
         <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                 <p>HTTP/1.1</p>
             </li><li class="listitem">
                 <p>HTTP/2</p>
             </li><li class="listitem">
                 <p>SSL/TLS (including native SSL engine)</p>
             </li><li class="listitem">
                 <p>Efficient client connection pooling</p>
             </li><li class="listitem">
                 <p>Optional native IO on Linux and BSD for greater performance</p>
             </li><li class="listitem">
                 <p>Domain sockets</p>
             </li><li class="listitem">
                 <p>HTTP Metrics with Dropwizard or Micrometer</p>
             </li></ul></div>
         <p>
           The Vert.x engine is enabled by adding a dependency to the <span class="emphasis"><em>org.jboss.resteasy:resteasy-client-vertx</em></span>
           artifact to the Maven project; then the client can be built as follows:
         </p>
         <pre><code class="no-highlight">
VertxClientHttpEngine engine = new VertxClientHttpEngine();
ResteasyClient client = ((ResteasyClientBuilder)ClientBuilder.newBuilder())
  .clientEngine(engine).build();
         </code></pre>
         <p>
           A Vert.x instance can also be provided when creating the client engine, as well as options configuration:
         </p>
         <pre><code class="no-highlight">
HttpClientOptions options = new HttpClientOptions()
 .setSsl(true);
 .setTrustStoreOptions(new JksOptions()
   .setPath("/path/to/your/truststore.jks")
   .setPassword("password-of-your-truststore")
);
VertxClientHttpEngine engine = new VertxClientHttpEngine(vertx, options);
         </code></pre>
       <p>You can read more about HttpClient configuration <a class="ulink" href="https://vertx.io/docs/vertx-core/java/#_making_requests">here</a>.</p>
     </section>

    <section class="section" id="reactor_netty_client"><div class="titlepage"><div><div><h3 class="title">51.3.8. Reactor Netty Client Engine</h3></div></div></div>
        
        <p>
            Still as a drop in replacement, RESTEasy allows selecting a Reactor Netty based HTTP engine.
            The Reactor Netty implementation is newer and less tested, but can be a good choice if the user
            application is already dependening on Netty and performs asynchronous client invocations.
        </p>
        <p>
            The Reactor Netty engine is enabled by adding a dependency to the <span class="emphasis"><em>org.jboss.resteasy:resteasy-client-reactor-netty</em></span>
            artifact to the Maven project; then the client can be built as follows:
        </p>
        <pre><code class="no-highlight">
ReactorNettyClientHttpEngine engine = new ReactorNettyClientHttpEngine(
   HttpClient.create(),
   new DefaultChannelGroup(new DefaultEventExecutor()),
   HttpResources.get());
ResteasyClient client = ((ResteasyClientBuilder)ClientBuilder.newBuilder())
   .clientEngine(engine).build();
        </code></pre>
        <p>
            When coupled with the MonoRxInvoker, this has several benefits.
            It supports things like this:
</p><pre><code class="no-highlight">
webTarget.path("/foo").get().rx(MonoRxInvoker.class).map(...).subscribe()
</code></pre><p>

        </p><p>
            in order to achieve non-blocking HTTP client calls. This allows leveraging
            some reactor features:
        </p><p>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">the ability for a <code class="code">Mono#timeout</code> set on the response to aggressively terminate the HTTP request;</li><li class="listitem">the ability to pass a (reactor) context from client calls into <code class="classname">ReactorNettyClientHttpEngine</code>.</li></ul></div><p>
        </p>
        
        <p>
        For some sample code, see 
        <code class="classname">org.jboss.resteasy.reactor.ReactorTest</code> in the
        RESTEasy module resteasy-reactor.
        </p>
    </section>

   </section>
   

</section>


   <section class="chapter" id="MicroProfile_Rest_Client"><div class="titlepage"><div><div><h1 class="title">Chapter 52. MicroProfile Rest Client</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="sect1"><a href="#d5e3860">52.1. Client proxies</a></span></li><li><span class="sect1"><a href="#d5e3903">52.2. Concepts imported from JAX-RS</a></span></li><li><span class="sect1"><a href="#d5e3936">52.3. Beyond JAX-RS and RESTEasy</a></span></li></ul></div>


<p>
As the microservices style of system architecture (see, for example,
<a class="ulink" href="https://martinfowler.com/articles/microservices.html">Microservices</a> by Martin Fowler)
gains increasing traction, new API standards are coming along to support it. One set of such standards comes from
the <a class="ulink" href="https://microprofile.io/">Microprofile Project</a> supported by the Eclipse Foundation, and among 
those is one, <a class="ulink" href="https://microprofile.io/project/eclipse/microprofile-rest-client">MicroProfile Rest Client</a>,
of particular interest to RESTEasy and JAX-RS. In fact, it is intended to be based on, and consistent with, JAX-RS,
and it includes ideas already implemented in RESTEasy. For a more detailed description of MicroProfile Rest Client,
see <a class="ulink" href="https://github.com/eclipse/microprofile-rest-client">https://github.com/eclipse/microprofile-rest-client</a>.
In particular, the API code is in 
<a class="ulink" href="https://github.com/eclipse/microprofile-rest-client/tree/master/api">https://github.com/eclipse/microprofile-rest-client/tree/master/api</a>.
and the specification is in
<a class="ulink" href="https://github.com/eclipse/microprofile-rest-client/tree/master/spec">https://github.com/eclipse/microprofile-rest-client/tree/master/spec</a>.
</p>

<section class="sect1" id="d5e3860"><div class="titlepage"><div><div><h2 class="title">52.1. Client proxies</h2></div></div></div>


<p>
One of the central ideas in MicroProfile Rest Client is a version of <span class="emphasis"><em>distributed object communication</em></span>, a concept
implemented in, among other places, <a class="ulink" href="http://www.corba.org/orb_basics.htm">CORBA</a>, Java RMI, the JBoss
Remoting project, and RESTEasy. Consider the resource
</p>

<pre><code class="no-highlight">
@Path("resource")
public class TestResource {

   @Path("test")
   @GET
   String test() {
      return "test";
   }
}
</code></pre>

<p>
The JAX-RS native way of accessing <code class="classname">TestResource</code> looks like
</p>

<pre><code class="no-highlight">
Client client = ClientBuilder.newClient();
String response = client.target("http://localhost:8081/test").request().get(String.class);
</code></pre>

<p>
The call to <code class="methodname">TestResource.test()</code> is not particularly onerous, but calling 
<code class="methodname">test()</code> directly allows a more natural syntax. That is exactly what Microprofile
Rest Client supports:
</p>

<pre><code class="no-highlight">
@Path("resource")
public interface TestResourceIntf {

   @Path("test")
   @GET
   public String test();
}
   
TestResourceIntf service = RestClientBuilder.newBuilder()
                              .baseUrl("http://localhost:8081/")
                              .build(TestResourceIntf.class);
String s = service.test();
</code></pre>

<p>
The first four lines of executable code are spent creating a proxy, <code class="code">service</code>, that implements
<code class="classname">TestResourceIntf</code>, but once that is done, calls on <code class="classname">TestResource</code>
can be made very naturally in terms of <code class="classname">TestResourceIntf</code>, as illustrated by the call
<code class="code">service.test()</code>. 
</p>

<p>
Beyond the natural syntax, another advantage of proxies is the way the proxy construction process quietly
gathers useful information from the implemented interface and makes it available for remote invocations.
Consider a more elaborate version of <code class="classname">TestResourceIntf</code>:
</p>

<pre><code class="no-highlight">
@Path("resource")
public interface TestResourceIntf2 {

   @Path("test/{path}")
   @Consumes("text/plain")
   @Produces("text/html")
   @POST
   public String test(@PathParam("path") String path, @QueryParam("query") String query, String entity);
}
</code></pre>

<p>
Calling <code class="methodname">service.test("p", "q", "e")</code> results in an HTTP message that looks like
</p>

<pre><code class="no-highlight">
POST /resource/test/p/?query=q HTTP/1.1
Accept: text/html
Content-Type: text/plain
Content-Length: 1

e
</code></pre>

<p>
The HTTP verb is derived from the <code class="code">@POST</code> annotation, the request URI is derived from the
two instances of the <code class="classname">@Path</code> annotation (one on the class, one on the method) plus the
first and second parameters of <code class="methodname">test()</code>, the Accept header is derived from the
<code class="classname">@Produces</code> annotation, and the Content-Type header is derived from the
<code class="classname">@Consumes</code> annotation, 
</p>

<p>
Using the JAX-RS API, <code class="code">service.test("p", "q", "e")</code> would look like the more verbose
</p>

<pre><code class="no-highlight">
Client client = ClientBuilder.newClient();
String response = client.target("http://localhost:8081/resource/test/p")
                     .queryParam("query", "q")
                     .request()
                     .accept("text/html")
                     .post(Entity.entity("e", "text/plain"), String.class);
</code></pre>

<p>
One other basic facility offered by MicroProfile Rest Client is the ability to configure the client environment
by registering providers:
</p>

<pre><code class="no-highlight">
TestResourceIntf service = RestClientBuilder.newBuilder()
                              .baseUrl("http://localhost:8081/")
                              .register(MyClientResponseFilter.class)
                              .register(MyMessageBodyReader.class)
                              .build(TestResourceIntf.class);
</code></pre>

<p>
Naturally, the registered providers should be relevant to the client environment, rather than, say, a
<code class="classname">ContainerResponseFilter</code>.
</p>

<div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2>
<p>
So far, the MicroProfile Rest Client should look familiar to anyone who has used the RESTEasy client proxy facility
(<a class="link" href="#proxies" title="51.2. RESTEasy Proxy Framework">Section ""RESTEasy Proxy Framework"</a>). The construction in 
the previous listing would look like
</p>

<pre><code class="no-highlight">
ResteasyClient client = (ResteasyClient) ResteasyClientBuilder.newClient();
TestResourceIntf service = client.target("http://localhost:8081/")
                              .register(MyClientResponseFilter.class)
                              .register(MyMessageBodyReader.class)
                              .proxy(TestResourceIntf.class);
</code></pre>

<p>
in RESTEasy.
</p>
</div>
</section>

<section class="sect1" id="d5e3903"><div class="titlepage"><div><div><h2 class="title">52.2. Concepts imported from JAX-RS</h2></div></div></div>


<p>
Beyond the central concept of the client proxy, some basic concepts in MicroProfile Client originate
in JAX-RS. Some of these have already been introduced in the previous section, since the interface
implemented by a client proxy represents the facilities provided by a JAX-RS server. For example, the
HTTP verb annotations and the <code class="code">@Consumes</code> and <code class="code">@Produces</code> annotations originate on the
JAX-RS server side. Injectable parameters annotated with <code class="code">@PathParameter</code>, <code class="code">@QueryParameter</code>,
etc., also come from JAX-RS.
</p>

<p>
Nearly all of the provider concepts supported by MicroProfile Client also originate in JAX-RS. These are:
</p>

<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">javax.ws.rs.client.ClientRequestFilter</li><li class="listitem">javax.ws.rs.client.ClientResponseFilter</li><li class="listitem">javax.ws.rs.ext.MessageBodyReader</li><li class="listitem">javax.ws.rs.ext.MessageBodyWriter</li><li class="listitem">javax.ws.rs.ext.ParamConverter</li><li class="listitem">javax.ws.rs.ext.ReaderInterceptor</li><li class="listitem">javax.ws.rs.ext.WriterInterceptor</li></ul></div>

<p>
Like JAX-RS, MicroProfile Client also has the concept of mandated providers. These are
</p>

<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">JSON-P <code class="classname">MessageBodyReader</code> and <code class="classname">MessageBodyWriter</code>
   must be provided.</li><li class="listitem">JSON-B <code class="classname">MessageBodyReader</code> and <code class="classname">MessageBodyWriter</code>
   must be provided if the implementation supports JSON-B.</li><li class="listitem"><code class="classname">MessageBodyReader</code>s and <code class="classname">MessageBodyWriter</code>s
   must be provided for the following types:
   <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">byte[]</li><li class="listitem">String</li><li class="listitem">InputStream</li><li class="listitem">Reader</li><li class="listitem">File</li></ul></div>
   </li></ul></div>
</section>

<section class="sect1" id="d5e3936"><div class="titlepage"><div><div><h2 class="title">52.3. Beyond JAX-RS and RESTEasy</h2></div></div></div>


<p>
Some concepts in MicroProfile Rest Client do not appear in either JAX-RS or RESTEasy.
</p>

<section class="sect1" id="d5e3939"><div class="titlepage"><div><div><h2 class="title">1. Default media type</h2></div></div></div>


<p>
Whenever no media type is specified by, for example, <code class="code">@Consumes</code> or <code class="code">@Produces</code> annotations,
the media type of a request entity or response entity is "application/json". This is different than JAX-RS, where
the media type defaults to "application/octet-stream".
</p>
</section>

<section class="sect1" id="d5e3944"><div class="titlepage"><div><div><h2 class="title">2. Declarative registration of providers</h2></div></div></div>


<p>
In addition to programmatic registration of providers as illustrated above, it is also possible to
register providers declaratively with annotations introduced in MicroProfile Rest Client. In particular,
providers can be registered by adding the <code class="classname">org.eclipse.microprofile.rest.client.annotation.RegisterProvider</code>
annotation to the target interface:
</p>

<pre><code class="no-highlight">
@Path("resource")
@RegisterProvider(MyClientResponseFilter.class)
@RegisterProvider(MyMessageBodyReader.class)
public interface TestResourceIntf2 {

   @Path("test/{path}")
   @Consumes("text/plain")
   @Produces("text/html")
   @POST
   public String test(@PathParam("path") String path, @QueryParam("query") String query, String entity);
}
</code></pre>

<p>
Declaring <code class="classname">MyClientResponseFilter</code> and <code class="classname">MyMessageBodyReader</code>  with
annotations eliminates the need to call <code class="methodname">RestClientBuilder.register()</code>.
</p>
</section>

<section class="sect1" id="d5e3953"><div class="titlepage"><div><div><h2 class="title">3. Global registration of providers</h2></div></div></div>


<p>
One more way to register providers is by implementing one or both of the listeners in package
<code class="code">org.eclipse.microprofile.rest.client.spi</code>:
</p>

<pre><code class="no-highlight">
public interface RestClientBuilderListener {

    void onNewBuilder(RestClientBuilder builder);
}

public interface RestClientListener {

    void onNewClient(Class&lt;?&gt; serviceInterface, RestClientBuilder builder);
}
</code></pre>

<p>
which can access a <code class="classname">RestClientBuilder</code> upon creation of a new <code class="classname">RestClientBuilder</code> or
upon the execution of <code class="methodname">RestClientBuilder.build()</code>, respectively. Implementations must
be declared in 
</p>

<pre><code class="no-highlight">
META-INF/services/org.eclipse.microprofile.rest.client.spi.RestClientBuilderListener
</code></pre>

<p>or</p>

<pre><code class="no-highlight">
META-INF/services/org.eclipse.microprofile.rest.client.spi.RestClientListener
</code></pre>
</section>

<section class="sect1" id="d5e3965"><div class="titlepage"><div><div><h2 class="title">4. Declarative specification of headers</h2></div></div></div>


<p>
One way of declaring a header to be included in a request is by annotating one of the resource method
parameters with <code class="code">@HeaderValue</code>:
</p>

<pre><code class="no-highlight">
@POST
@Produces(MediaType.TEXT_PLAIN)
@Consumes(MediaType.TEXT_PLAIN)
String contentLang(@HeaderParam(HttpHeaders.CONTENT_LANGUAGE) String contentLanguage, String subject);
</code></pre>

<p>
That option is available with RESTEasy client proxies as well,
but in case it is inconvenient or otherwise inappropriate to include the necessary parameter,
MicroProfile Client makes a declarative alternative available through the use of the
<code class="classname">org.eclipse.microprofile.rest.client.annotation.ClientHeaderParam</code> annotation: 
</p>

<pre><code class="no-highlight">
@POST
@Produces(MediaType.TEXT_PLAIN)
@Consumes(MediaType.TEXT_PLAIN)
@ClientHeaderParam(name=HttpHeaders.CONTENT_LANGUAGE, value="en")
String contentLang(String subject);
</code></pre>

<p>
In this example, the header value is hardcoded, but it is also possible to compute a value:
</p>

<pre><code class="no-highlight">
@POST
@Produces(MediaType.TEXT_PLAIN)
@Consumes(MediaType.TEXT_PLAIN)
@ClientHeaderParam(name=HttpHeaders.CONTENT_LANGUAGE, value="{getLanguage}")
String contentLang(String subject);

default String getLanguage() {
   return ...;
}
</code></pre>
</section>

<section class="sect1" id="d5e3975"><div class="titlepage"><div><div><h2 class="title">5. Propagating headers on the server</h2></div></div></div>


<p>
An instance of <code class="classname">org.eclipse.microprofile.rest.client.ext.ClientHeadersFactory</code>,
</p>

<pre><code class="no-highlight">
public interface ClientHeadersFactory {

/**
 * Updates the HTTP headers to send to the remote service. Note that providers
 * on the outbound processing chain could further update the headers.
 *
 * @param incomingHeaders - the map of headers from the inbound JAX-RS request. This will
 * be an empty map if the associated client interface is not part of a JAX-RS request.
 * @param clientOutgoingHeaders - the read-only map of header parameters specified on the
 * client interface.
 * @return a map of HTTP headers to merge with the clientOutgoingHeaders to be sent to
 * the remote service.
 */
MultivaluedMap&lt;String, String&gt; update(MultivaluedMap&lt;String, String&gt; incomingHeaders,
                                      MultivaluedMap&lt;String, String&gt; clientOutgoingHeaders);
}
</code></pre>
<p>
if activated, can do a bulk transfer of incoming headers to an outgoing request. The default instance
<code class="classname">org.eclipse.microprofile.rest.client.ext.DefaultClientHeadersFactoryImpl</code>
will return a map consisting of those incoming headers listed in the comma separated configuration property
</p>

<pre><code class="no-highlight">
org.eclipse.microprofile.rest.client.propagateHeaders
</code></pre>

<p>
In order for an instance of <code class="classname">ClientHeadersFactory</code> to be activated,
the interface must be annotated with 
<code class="classname">org.eclipse.microprofile.rest.client.annotation.RegisterClientHeaders</code>. Optionally,
the annotation may include a value field set to an implementation class; without an explicit value, the
default instance will be used.
</p>

<p>
Although a <code class="classname">ClientHeadersFactory</code> is not officially designated as a provider, it is
now (as of MicroProfile REST Client specification 1.4) subject to injection. In particular, when an instance of <code class="classname">ClientHeadersFactory</code>
is managed by CDI, then CDI injection is mandatory. When a REST Client is executing in the context
of a JAX-RS implementation, then @Context injection into a <code class="classname">ClientHeadersFactory</code> is
currently optional. RESTEasy supports CDI injection and does not currently support @Context injection.
</p>
</section>

<section class="sect1" id="d5e3990"><div class="titlepage"><div><div><h2 class="title">6. ResponseExceptionMapper</h2></div></div></div>


<p>
The <code class="classname">org.eclipse.microprofile.rest.client.ext.ResponseExceptionMapper</code> is the
client side inverse of the <code class="classname">javax.ws.rs.ext.ExceptionMapper</code> defined in JAX-RS. That is,
where <code class="methodname">ExceptionMapper.toResponse()</code> turns an <code class="classname">Exception</code> thrown
during server side processing into a <code class="classname">Response</code>,
<code class="methodname">ResponseExceptionMapper.toThrowable()</code> turns a 
<code class="classname">Response</code> received on the client side with an HTTP error status into
an <code class="classname">Exception</code>. <code class="classname">ResponseExceptionMapper</code>s can be registered
in the same manner as other providers, that is, either programmatically or declaratively. In the absence
of a registered <code class="classname">ResponseExceptionMapper</code>, a default <code class="classname">ResponseExceptionMapper</code>
will map any response with status &gt;= 400 to a <code class="classname">WebApplicationException</code>.
</p>

</section>

<section class="sect1" id="d5e4005"><div class="titlepage"><div><div><h2 class="title">7. Proxy injection by CDI</h2></div></div></div>


<p>
MicroProfile Rest Client mandates that implementations must support CDI injection of proxies. At first, the
concept might seem odd in that CDI is more commonly available on the server side. However, the idea is very
consistent with the microservices philosophy. If an application is composed of a number of small services,
then it is to be expected that services will often act as clients to other services.
</p>

<p>
CDI (Contexts and Dependency Injection) is a fairly rich subject and beyond the scope of this Guide. For more information, see 
<a class="ulink" href="https://www.jcp.org/en/jsr/detail?id=365">JSR 365: Contexts and Dependency Injection for JavaTM 2.0</a> 
(the specification), 
<a class="ulink" href="https://javaee.github.io/tutorial/toc.html">Java EE 8 Tutorial</a>, or
<a class="ulink" href="https://docs.jboss.org/weld/reference/latest-master/en-US/html/">WELD - CDI Reference Implementation</a>.
</p>

<p>
The fundamental thing to know about CDI injection is that annotating a variable with 
<code class="classname">javax.inject.Inject</code> will lead the CDI runtime (if it is present and enabled) to
create an object of the appropriate type and assign it to the variable. For example, in
</p>

<pre><code class="no-highlight">
   public interface Book {
      public String getTitle();
      public void setTitle(String title);
   }

   public class BookImpl implements Book {
      
      private String title;

      @Override
      public String getTitle() {
         return title;
      }
      
      @Override
      public void setTitle(String title) {
         this.title = title;
      }
   }
   
   public class Author {
      
      @Inject private Book book; 
      
      public Book getBook() {
         return book;
      }
   }
</code></pre>

<p>
The CDI runtime will create an instance of <code class="classname">BookImpl</code> and assign it to the private field
<code class="code">book</code> when an instance of <code class="classname">Author</code> is created;
</p>

<p>
In this example, the injection is done because <code class="classname">BookImpl</code> is assignable to <code class="code">book</code>, but
greater discrimination can be imposed by annotating the interface and the field with <span class="bold"><strong>qualifier</strong></span>
annotations. For the injection to be legal, every qualifier on the field must be present on the injected interface.
For example:</p>

<pre><code class="no-highlight">
   @Qualifier
   @Target({ElementType.TYPE, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD})
   @Retention(RetentionPolicy.RUNTIME)
   public @interface Text {}
   
   @Qualifier
   @Target({ElementType.TYPE, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD})
   @Retention(RetentionPolicy.RUNTIME)
   public @interface Graphic {}
   
   @Text
   public class TextBookImpl extends BookImpl { }
   
   @Graphic
   public class GraphicNovelImpl extends BookImpl { }
   
   public class Genius {
      
      @Inject @Graphic Book book;
   }

</code></pre>

<p>
Here, the class <code class="classname">TextBookImpl</code> is annotated with the <code class="classname">@Text</code> qualifier and
<code class="classname">GraphicNovelImpl</code> is annotated with <code class="classname">@Graphic</code>. It follows that an instance
of <code class="classname">GraphicNovelImpl</code> is eligible for assignment to the field <code class="code">book</code> in the 
<code class="classname">Genius</code> class, but an instance of <code class="classname">TextBookImpl</code> is not.
</p>

<p>
Now, in MicroProfile Rest Client, any interface that is to be managed as a CDI bean must be annotated with
<code class="classname">@RegisterRestClient</code>:
</p>

<pre><code class="no-highlight">
   @Path("resource")
   @RegisterProvider(MyClientResponseFilter.class)
   public static class TestResourceImpl {

      @Inject TestDataBase db;
      
      @Path("test/{path}")
      @Consumes("text/plain")
      @Produces("text/html")
      @POST
      public String test(@PathParam("path") String path, @QueryParam("query") String query, String entity) {
         return db.getByName(query);
      }
   }

   @Path("database")
   @RegisterRestClient
   public interface TestDataBase {
      
      @Path("")
      @POST
      public String getByName(String name);
   }
</code></pre>

<p>
Here, the MicroProfile Rest Client implementation creates a proxy for a <code class="classname">TestDataBase</code> service,
allowing easy access by <code class="classname">TestResourceImpl</code>. Notice, though, that there's no indication of
where the <code class="classname">TestDataBase</code> implementation lives. That information can be supplied by the optional
<code class="classname">@RegisterProvider</code> parameter <code class="code">baseUri</code>:</p>

<pre><code class="no-highlight">
   @Path("database")
   @RegisterRestClient(baseUri="https://localhost:8080/webapp")
   public interface TestDataBase {
      
      @Path("")
      @POST
      public String getByName(String name);
   }
</code></pre>

<p>
which indicates that an implementation of <code class="classname">TestDatabase</code> can be
accessed at https://localhost:8080/webapp. The same information can be supplied externally with the system variable
</p>

<pre><code class="no-highlight">
&lt;fqn of TestDataBase&gt;/mp-rest/uri=&lt;URL&gt;
</code></pre>

<p>or</p>

<pre><code class="no-highlight">
&lt;fqn of TestDataBase&gt;/mp-rest/url=&lt;URL&gt;
</code></pre>

<p>
which will override the value hardcoded in <code class="classname">@RegisterRestClient</code>. For example,
</p>

<pre><code class="no-highlight">
com.bluemonkeydiamond.TestDatabase/mp-rest/url=https://localhost:8080/webapp
</code></pre>

<p>
A number of other properties will be examined in the course of creating the proxy, including, for example
</p>

<pre><code class="no-highlight">
com.bluemonkeydiamond.TestDatabase/mp-rest/providers
</code></pre>

<p>
a comma separated list of provider classes to be registered with the proxy. See the MicroProfile Client
documentation for more such properties.
</p>

<p>
These properties can be simplified through the use of the <code class="code">configKey</code> field in 
<code class="classname">@RegisterRestClient</code>. For example, setting the <code class="code">configKey</code> as in
</p>

<pre><code class="no-highlight">
@Path("database")
@RegisterRestClient(configKey="bmd")
public interface TestDataBase { ... }
</code></pre>

<p>
allows the use of properties like
</p>

<pre><code class="no-highlight">
bmd/mp-rest/url=https://localhost:8080/webapp
</code></pre>

<p>
Note that, since the configKey is not tied to a particular interface name, multiple proxies can be
configured with the same properties.
</p>
</section>

<section class="sect1" id="d5e4062"><div class="titlepage"><div><div><h2 class="title">8. Proxy lifecycle</h2></div></div></div>


<p>
Proxies should be closed so that any resources they hold can be released. Every proxy created by
<code class="classname">RestClientBuilder</code> implements the <code class="classname">java.io.Closeable</code>
interface, so it is always possible to cast a proxy to <code class="classname">Closeable</code> and call
<code class="methodname">close()</code>. A nice trick to have the proxy interface explicitly extend
<code class="classname">Closeable</code>, which not only avoids the need for a cast but also makes the proxy
eligible to use in a try-with-resources block:
</p>

<pre><code class="no-highlight">
@Path("resource")
public interface TestResourceIntf extends Closeable {

   @Path("test")
   @GET
   public String test();
}
   
TestResourceIntf service = RestClientBuilder.newBuilder()
                              .baseUrl("http://localhost:8081/")
                              .build(TestResourceIntf.class);
try (TestResourceIntf tr = service) {
   String s = service.test();
}
</code></pre>
</section>

<section class="sect1" id="d5e4071"><div class="titlepage"><div><div><h2 class="title">9. Asynchronous support</h2></div></div></div>


<p>An interface method can be designated as asynchronous by having it return a
<code class="classname">java.util.concurrent.CompletionStage</code>. For example, in
</p>

<pre><code class="no-highlight">
public interface TestResourceIntf extends Closeable {

   @Path("test")
   @GET
   public String test();
   
   @Path("testasync")
   @GET
   public CompletionStage&lt;String&gt; testAsync();
}
</code></pre>

<p>
the <code class="code">test()</code> method can be turned into the asynchronous method <code class="code">testAsync()</code> by having it return
a <code class="classname">CompletionStage&lt;String&gt;</code> instead of a <code class="classname">String</code>.
</p>

<p>
Asynchronous methods are made to be asynchronous by scheduling their execution on a thread distinct from
the calling thread. The MicroProfile Client implementation will have a default means of doing that, but
<code class="methodname">RestClientBuilder.executorService(ExecutorService)</code> provides a way of substituting
an application specific <code class="classname">ExecutorService</code>.
</p>

<p>
The classes <code class="classname">AsyncInvocationInterceptorFactory</code> and
<code class="classname">AsyncInvocationInterceptor</code> in package
<code class="code">org.eclipse.microprofile.rest.client.ext</code> provides a means of communication
between the calling thread and the asynchronous thread:
</p>

<pre><code class="no-highlight">
public interface AsyncInvocationInterceptorFactory {

    /**
     * Implementations of this method should return an implementation of the
     * <code class="code">AsyncInvocationInterceptor</code> interface.  The MP Rest Client
     * implementation runtime will invoke this method, and then invoke the
     * <code class="code">prepareContext</code> and <code class="code">applyContext</code> methods of the
     * returned interceptor when performing an asynchronous method invocation.
     * Null return values will be ignored.
     *
     * @return Non-null instance of <code class="code">AsyncInvocationInterceptor</code>
     */
    AsyncInvocationInterceptor newInterceptor();
}

public interface AsyncInvocationInterceptor {

    /**
     * This method will be invoked by the MP Rest Client runtime on the "main"
     * thread (i.e. the thread calling the async Rest Client interface method)
     * prior to returning control to the calling method.
     */
    void prepareContext();

    /**
     * This method will be invoked by the MP Rest Client runtime on the "async"
     * thread (i.e. the thread used to actually invoke the remote service and
     * wait for the response) prior to sending the request.
     */
    void applyContext();

    /**
     * This method will be invoked by the MP Rest Client runtime on the "async"
     * thread (i.e. the thread used to actually invoke the remote service and
     * wait for the response) after all providers on the inbound response flow
     * have been invoked.
     *
     * @since 1.2
     */
     void removeContext();
}
</code></pre>

<p>
The following sequence of events occurs:
</p>

<div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
      <p>
      <code class="methodname">AsyncInvocationInterceptorFactory.newInterceptor()</code> is called
      on the calling thread to get an instance of the <code class="classname">AsyncInvocationInterceptor</code>.
      </p>
   </li><li class="listitem">
      <p>
      <code class="methodname">AsyncInvocationInterceptor.prepareContext()</code> is executed on the calling
      thread to store information to be used by the request execution.
      </p>
   </li><li class="listitem">
      <p>
      <code class="methodname">AsyncInvocationInterceptor.applyContext()</code> is executed on the 
      asynchronous thread.
      </p>
   </li><li class="listitem">
      <p>
      All relevant outbound providers such as interceptors and filters are executed on the asynchronous thread,
      followed by the request invocation.
      </p>
   </li><li class="listitem">
      <p>
      All relevant inbound providers are executed on the asynchronous thread, followed by executing
      <code class="methodname">AsyncInvocationInterceptor.removeContext()</code>
      </p>
   </li><li class="listitem">
      <p>
      The asynchronous thread returns.
      </p>
   </li></ol></div>

<p>
An <code class="classname">AsyncInvocationInterceptorFactory</code> class is enabled by registering it on the
client interface with <code class="classname">@RegisterProvider</code>. 
</p>

</section>

<section class="sect1" id="d5e4115"><div class="titlepage"><div><div><h2 class="title">10. SSL</h2></div></div></div>


<p>
The MicroProfile Client <code class="classname">RestClientBuilder</code> interface includes a number
of methods that support the use of SSL:
</p>

<pre><code class="no-highlight">
RestClientBuilder hostnameVerifier(HostnameVerifier hostnameVerifier);
RestClientBuilder keyStore(KeyStore keyStore, String keystorePassword);
RestClientBuilder sslContext(SSLContext sslContext);
RestClientBuilder trustStore(KeyStore trustStore);
</code></pre>

<p>
For example:
</p>

<pre><code class="no-highlight">
KeyStore trustStore = ... ;
HostnameVerifier verifier ... ;
TestResourceIntf service = RestClientBuilder.newBuilder()
                              .baseUrl("http://localhost:8081/")
                              .trustStore(trustStore)
                              .hostnameVerifier(verifier)
                              .build(TestResourceIntf.class);
</code></pre>

<p>
It is also possible to configure <code class="classname">HostnameVerifier</code>s, 
<code class="classname">KeyStore</code>s, and <code class="classname">TrustStore</code>s using configuration
properties:
</p>

<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>com.bluemonkeydiamond.TestResourceIntf/mp-rest/hostnameVerifier</p></li><li class="listitem"><p>com.bluemonkeydiamond.TestResourceIntf/mp-rest/keyStore</p></li><li class="listitem"><p>com.bluemonkeydiamond.TestResourceIntf/mp-rest/keyStorePassword</p></li><li class="listitem"><p>com.bluemonkeydiamond.TestResourceIntf/mp-rest/keyStoreType</p></li><li class="listitem"><p>com.bluemonkeydiamond.TestResourceIntf/mp-rest/trustStore</p></li><li class="listitem"><p>com.bluemonkeydiamond.TestResourceIntf/mp-rest/trustStorePassword</p></li><li class="listitem"><p>com.bluemonkeydiamond.TestResourceIntf/mp-rest/trustStoreType</p></li></ul></div>

<p>
The values of the ".../mp-rest/keyStore" and "../mp-rest/trustStore" parameters can be either
classpath resources (e.g., "classpath:/client-keystore.jks") or files (e.g., "file:/home/user/client-keystore.jks").
</p>

</section>
</section>

</section>

   

 <section class="chapter" id="AJAX_Client"><div class="titlepage"><div><div><h1 class="title">Chapter 53. AJAX Client</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="section"><a href="#d5e4145">53.1. Generated JavaScript API</a></span><ul><li><span class="section"><a href="#d5e4154">53.1.1. JavaScript API servlet</a></span></li><li><span class="section"><a href="#d5e4158">53.1.2. JavaScript API usage</a></span></li><li><span class="section"><a href="#d5e4212">53.1.3. Work with @Form</a></span></li><li><span class="section"><a href="#d5e4224">53.1.4. MIME types and unmarshalling.</a></span></li><li><span class="section"><a href="#d5e4249">53.1.5. MIME types and marshalling.</a></span></li></ul></li><li><span class="section"><a href="#d5e4278">53.2. Using the JavaScript API to build AJAX queries</a></span><ul><li><span class="section"><a href="#d5e4281">53.2.1. The REST object</a></span></li><li><span class="section"><a href="#d5e4301">53.2.2. The REST.Request class</a></span></li></ul></li><li><span class="section"><a href="#d5e4351">53.3. Caching Features</a></span></li></ul></div>
    
    <p>RESTEasy resources can be accessed in JavaScript using AJAX using a 
      proxy API generated by RESTEasy.</p>
    <section class="section" id="d5e4145"><div class="titlepage"><div><div><h2 class="title">53.1. Generated JavaScript API</h2></div></div></div>
    	
    	<p>
    		RESTEasy can generate a JavaScript API that uses AJAX calls to invoke JAX-RS operations.
    	</p>
   		<div class="example" id="d5e4148"><div class="example-title">Example 53.1. First JAX-RS JavaScript API example</div><div class="example-contents">
   			
    		<p>
    			Let's take a simple JAX-RS API:
	    	</p>
	    	<pre><code class="no-highlight">@Path("orders")
public interface Orders {
 @Path("{id}")
 @GET
 public String getOrder(@PathParam("id") String id){
  return "Hello "+id;
 }
}</code></pre>
	    	<p>
				The preceding API would be accessible using the following JavaScript code:
	    	</p>
	    	<pre><code class="language-javascript">var order = Orders.getOrder({id: 23});</code></pre>
   		</div></div><br class="example-break"/>
    	<section class="section" id="d5e4154"><div class="titlepage"><div><div><h3 class="title">53.1.1. JavaScript API servlet</h3></div></div></div>
    		
    		<p>
    			In order to enable the JavaScript API servlet you must configure it in your
    			web.xml file as such:
    		</p>
    		<pre><code class="language-xml">&lt;servlet&gt;
 &lt;servlet-name&gt;RESTEasy JSAPI&lt;/servlet-name&gt;
 &lt;servlet-class&gt;org.jboss.resteasy.jsapi.JSAPIServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
 &lt;servlet-name&gt;RESTEasy JSAPI&lt;/servlet-name&gt;
 &lt;url-pattern&gt;/rest-js&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</code></pre>
    	</section>
    	<section class="section" id="d5e4158"><div class="titlepage"><div><div><h3 class="title">53.1.2. JavaScript API usage</h3></div></div></div>
    		
    		<p>
    			Each JAX-RS resource class will generate a JavaScript object of the same name
    			as the declaring class (or interface), which will contain every JAX-RS method
    			as properties.
    		</p>
    		<div class="example" id="d5e4161"><div class="example-title">Example 53.2. Structure of JAX-RS generated JavaScript</div><div class="example-contents">
    			
    			<p>For example, if the JAX-RS resource X defines methods Y and Z:
    			</p>
	    		<pre><code class="language-java">@Path("/")
public interface X{
 @GET
 public String Y();
 @PUT
 public void Z(String entity);
}</code></pre>
    			<p>
	    			Then the JavaScript API will define the following functions:
    			</p>
	    		<pre><code class="language-javascript">var X = {
 Y : function(params){…},
 Z : function(params){…}
};</code></pre>
    		</div></div><br class="example-break"/>
    		<p>
				Each JavaScript API method takes an optional object as single
				parameter where each property is a cookie, header, path, query or form parameter as identified
				by their name, or the following special parameters:
    		</p>
    		<div style="margin-left: 0.5in; margin-right: 0.5in;" class="warning"><h2>Warning</h2><p>The following special parameter names are subject to change.</p></div>
    		<div class="table" id="d5e4170"><div class="table-title">Table 53.1. API parameter properties</div><div class="table-contents"><table>
				
				<thead>
					<tr>
						<th>Property name</th>
						<th>Default</th>
						<th>Description</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>$entity</td>
						<td/>
						<td>The entity to send as a PUT, POST request.</td>
					</tr>
					<tr>
						<td>$contentType</td>
						<td>As determined by @Consumes.</td>
						<td>The MIME type of the body entity sent as the Content-Type header.</td>
					</tr>
					<tr>
						<td>$accepts</td>
						<td>Determined by @Provides, defaults to */*.</td>
						<td>The accepted MIME types sent as the Accept header.</td>
					</tr>
					<tr>
						<td>$callback</td>
						<td/>
						<td>
							Set to a function(httpCode, xmlHttpRequest, value) for an asynchronous call. If 
							not present, the call will be synchronous and return the value.
						</td>
					</tr>
					<tr>
						<td>$apiURL</td>
						<td>Determined by container</td>
						<td>Set to the base URI of your JAX-RS endpoint, not including the last slash.</td>
					</tr>
					<tr>
						<td>$username</td>
						<td/>
						<td>If username and password are set, they will be used for credentials for the request.</td>
					</tr>
					<tr>
						<td>$password</td>
						<td/>
						<td>If username and password are set, they will be used for credentials for the request.</td>
					</tr>
				</tbody>
    		</table></div></div><br class="table-break"/>
    		<div class="example" id="d5e4206"><div class="example-title">Example 53.3. Using the API</div><div class="example-contents">
    			
    			<p>Here is an example of JAX-RS API:</p>
	    		<pre><code class="language-java">@Path("foo")
public class Foo{
 @Path("{id}")
 @GET
 public String get(@QueryParam("order") String order, @HeaderParam("X-Foo") String header,
                   @MatrixParam("colour") String colour, @CookieParam("Foo-Cookie") String cookie){
  …
 }
 @POST
 public void post(String text){
 }
}</code></pre>
				<p>We can use the previous JAX-RS API in JavaScript using the following code:</p>
	    		<pre><code class="language-javascript">
var text = Foo.get({order: 'desc', 'X-Foo': 'hello',
                    colour: 'blue', 'Foo-Cookie': 123987235444});
Foo.put({$entity: text});</code></pre>
    		</div></div><br class="example-break"/>
    	</section>
    	<section class="section" id="d5e4212"><div class="titlepage"><div><div><h3 class="title">53.1.3. Work with @Form</h3></div></div></div>
    		
    		<p>
    			@Form is a RESTEasy specific annotation that allows you to re-use any @*Param annotation within an injected class. 
    			The generated JavaScript API will expand the parameters for use automatically. Support we have the following form:
    		</p>
    		<pre><code class="language-java">public class MyForm {
    @FormParam("stuff")
    private String stuff;

    @FormParam("number")
    private int number;

    @HeaderParam("myHeader")
    private String header;
}</code></pre>
			<p>And the resource is like:</p>
			<pre><code class="language-java">@Path("/")
public class MyResource {

    @POST
    public String postForm(@Form MyForm myForm) {...}

}</code></pre>
			<p>Then we could call the method from JavaScript API like following:</p>
			<pre><code class="language-java">MyResource.postForm({stuff:"A", myHeader:"B", number:1});</code></pre>
			<p>Also, @Form supports prefix mappings for lists and maps:</p>
			<pre><code class="language-java">public static class Person {
    @Form(prefix="telephoneNumbers") List&lt;TelephoneNumber&gt; telephoneNumbers;
    @Form(prefix="address") Map&lt;String, Address&gt; addresses;
}

public static class TelephoneNumber {
    @FormParam("countryCode") private String countryCode;
    @FormParam("number") private String number;
}

public static class Address {
    @FormParam("street") private String street;
    @FormParam("houseNumber") private String houseNumber;
}

@Path("person")
public static class MyResource {
	@POST
	public void postForm(@Form Person p) {...} 
}</code></pre>
		<p>From JavaScript we could call the API like this:</p>
		<pre><code class="no-highlight">MyResource.postForm({
	telephoneNumbers:[
		{"telephoneNumbers[0].countryCode":31},
		{"telephoneNumbers[0].number":12345678},
		{"telephoneNumbers[1].countryCode":91},
		{"telephoneNumbers[1].number":9717738723}
	],
	address:[
		{"address[INVOICE].street":"Main Street"},
		{"address[INVOICE].houseNumber":2},
		{"address[SHIPPING].street":"Square One"},
		{"address[SHIPPING].houseNumber":13}
	]
});</code></pre>
    	</section>
    	<section class="section" id="d5e4224"><div class="titlepage"><div><div><h3 class="title">53.1.4. MIME types and unmarshalling.</h3></div></div></div>
    		
    		<p>
    			The Accept header sent by any client JavaScript function is controlled by the $accepts parameter, which overrides
    			the @Produces annotation on the JAX-RS endpoint. The returned value however is controlled by the Content-Type header
    			sent in the response as follows:
    		</p>
    		<div class="table" id="d5e4227"><div class="table-title">Table 53.2. Return values by MIME type</div><div class="table-contents"><table>
				
				<thead>
					<tr>
						<th>MIME</th>
						<th>Description</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>text/xml,application/xml,application/*+xml</td>
						<td>
							The response entity is parsed as XML before being returned. The return value is thus a DOM Document.
						</td>
					</tr>
					<tr>
						<td>application/json</td>
						<td>
							The response entity is parsed as JSON before being returned. The return value is thus a JavaScript Object.
						</td>
					</tr>
					<tr>
						<td>Anything else</td>
						<td>The response entity is returned raw.</td>
					</tr>
				</tbody>
			</table></div></div><br class="table-break"/>
	   		<div class="example" id="d5e4243"><div class="example-title">Example 53.4. Unmarshalling example</div><div class="example-contents">
   				
    			<p>
	    			The RESTEasy JavaScript client API can automatically unmarshall JSON and XML:
	    		</p>
	    		<pre><code class="no-highlight">@Path("orders")
public interface Orders {

 @XmlRootElement
 public static class Order {
  @XmlElement
  private String id;
  
  public Order(){}
  
  public Order(String id){
   this.id = id;
  }
 }

 @Path("{id}/xml")
 @GET
 @Produces("application/xml")
 public Order getOrderXML(@PathParam("id") String id){
  return new Order(id);
 }

 @Path("{id}/json")
 @GET
 @Produces("application/json")
 public Order getOrderJSON(@PathParam("id") String id){
  return new Order(id);
 }
}</code></pre>
	    		<p>
					Let us look at what the preceding JAX-RS API would give us on the client side:
	    		</p>
	    		<pre><code class="language-javascript">// this returns a JSON object
var orderJSON = Orders.getOrderJSON({id: "23"});
orderJSON.id == "23";

// this one returns a DOM Document whose root element is the order, with one child (id)
// whose child is the text node value
var orderXML = Orders.getOrderXML({id: "23"});
orderXML.documentElement.childNodes[0].childNodes[0].nodeValue == "23";</code></pre>
   			</div></div><br class="example-break"/>
    	</section>
    	<section class="section" id="d5e4249"><div class="titlepage"><div><div><h3 class="title">53.1.5. MIME types and marshalling.</h3></div></div></div>
    		
    		<p>
    			The Content-Type header sent in the request is controlled by the $contentType parameter which overrides the
    			@Consumes annotation on the JAX-RS endpoint. The value passed as entity body using the $entity parameter is marshalled
    			according to both its type and content type:
    		</p>
    		<div class="table" id="d5e4252"><div class="table-title">Table 53.3. Controlling sent entities</div><div class="table-contents"><table>
				
				<thead>
					<tr>
						<th>Type</th>
						<th>MIME</th>
						<th>Description</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>DOM Element</td>
						<td>Empty or text/xml,application/xml,application/*+xml</td>
						<td>The DOM Element is marshalled to XML before being sent.</td>
					</tr>
					<tr>
						<td>JavaScript Object (JSON)</td>
						<td>Empty or application/json</td>
						<td>The JSON object is marshalled to a JSON string before being sent.</td>
					</tr>
					<tr>
						<td>Anything else</td>
						<td>Anything else</td>
						<td>
							The entity is sent as is.
						</td>
					</tr>
				</tbody>
			</table></div></div><br class="table-break"/>
	   		<div class="example" id="d5e4272"><div class="example-title">Example 53.5. Marshalling example</div><div class="example-contents">
   				
    			<p>
	    			The RESTEasy JavaScript client API can automatically marshall JSON and XML:
	    		</p>
	    		<pre><code class="no-highlight">@Path("orders")
public interface Orders {

 @XmlRootElement
 public static class Order {
  @XmlElement
  private String id;
  
  public Order(){}
  
  public Order(String id){
   this.id = id;
  }
 }

 @Path("{id}/xml")
 @PUT
 @Consumes("application/xml")
 public void putOrderXML(Order order){
  // store order
 }

 @Path("{id}/json")
 @PUT
 @Consumes("application/json")
 public void putOrderJSON(Order order){
  // store order
 }
}</code></pre>
	    		<p>
					Let us look at what the preceding JAX-RS API would give us on the client side:
	    		</p>
	    		<pre><code class="language-javascript">// this saves a JSON object
Orders.putOrderJSON({$entity: {id: "23"}});

// It is a bit more work with XML
var order = document.createElement("order");
var id = document.createElement("id");
order.appendChild(id);
id.appendChild(document.createTextNode("23"));
Orders.putOrderXML({$entity: order});</code></pre>
   			</div></div><br class="example-break"/>
    	</section>
   	</section>
   	<section class="section" id="d5e4278"><div class="titlepage"><div><div><h2 class="title">53.2. Using the JavaScript API to build AJAX queries</h2></div></div></div>
   		
   		<p>
   			The RESTEasy JavaScript API can also be used to manually construct your requests.
   		</p>
   		<section class="section" id="d5e4281"><div class="titlepage"><div><div><h3 class="title">53.2.1. The REST object</h3></div></div></div>
   			
   			<p>
   				The REST object contains the following read-write properties:
   			</p>
    		<div class="table" id="d5e4284"><div class="table-title">Table 53.4. The REST object</div><div class="table-contents"><table>
				
				<thead>
					<tr>
						<th>Property</th>
						<th>Description</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>apiURL</td>
						<td>
							Set by default to the JAX-RS root URL, used by every JavaScript client API functions when constructing
							the requests.
						</td>
					</tr>
					<tr>
						<td>log</td>
						<td>
							Set to a function(string) in order to receive RESTEasy client API logs. This is useful if you want to
							debug your client API and place the logs where you can see them.
						</td>
					</tr>
				</tbody>
			</table></div></div><br class="table-break"/>
	   		<div class="example" id="d5e4297"><div class="example-title">Example 53.6. Using the REST object</div><div class="example-contents">
   				
    			<p>
	    			The REST object can be used to override RESTEasy JavaScript API client behaviour:
	    		</p>
	    		<pre><code class="language-javascript">// Change the base URL used by the API:
REST.apiURL = "http://api.service.com";

// log everything in a div element
REST.log = function(text){
 jQuery("#log-div").append(text);
};</code></pre>
   			</div></div><br class="example-break"/>
   		</section>
   		<section class="section" id="d5e4301"><div class="titlepage"><div><div><h3 class="title">53.2.2. The REST.Request class</h3></div></div></div>
   			
   			<p>
   				The REST.Request class is used to build custom requests. It has the following members: 
   			</p>
    		<div class="table" id="d5e4304"><div class="table-title">Table 53.5. The REST.Request class</div><div class="table-contents"><table>
				
				<thead>
					<tr>
						<th>Member</th>
						<th>Description</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>execute(callback)</td>
						<td>
							Executes the request with all the information set in the current object. The value is never returned
							but passed to the optional argument callback.
						</td>
					</tr>
					<tr>
						<td>setAccepts(acceptHeader)</td>
						<td>
							Sets the Accept request header. Defaults to */*.
						</td>
					</tr>
					<tr>
						<td>setCredentials(username, password)</td>
						<td>
							Sets the request credentials.
						</td>
					</tr>
					<tr>
						<td>setEntity(entity)</td>
						<td>
							Sets the request entity.
						</td>
					</tr>
					<tr>
						<td>setContentType(contentTypeHeader)</td>
						<td>
							Sets the Content-Type request header.
						</td>
					</tr>
					<tr>
						<td>setURI(uri)</td>
						<td>
							Sets the request URI. This should be an absolute URI.
						</td>
					</tr>
					<tr>
						<td>setMethod(method)</td>
						<td>
							Sets the request method. Defaults to GET.
						</td>
					</tr>
					<tr>
						<td>setAsync(async)</td>
						<td>
							Controls whether the request should be asynchronous. Defaults to true.
						</td>
					</tr>
					<tr>
						<td>addCookie(name, value)</td>
						<td>
							Sets the given cookie in the current document when executing the request.
							Beware that this will be persistent in your browser.
						</td>
					</tr>
					<tr>
						<td>addQueryParameter(name, value)</td>
						<td>
							Adds a query parameter to the URI query part.
						</td>
					</tr>
					<tr>
						<td>addMatrixParameter(name, value)</td>
						<td>
							Adds a matrix parameter (path parameter) to the last path segment of the request URI.
						</td>
					</tr>
					<tr>
						<td>addHeader(name, value)</td>
						<td>
							Adds a request header.
						</td>
					</tr>
				</tbody>
			</table></div></div><br class="table-break"/>
	   		<div class="example" id="d5e4347"><div class="example-title">Example 53.7. Using the REST.Request class</div><div class="example-contents">
   				
    			<p>
	    			The REST.Request class can be used to build custom requests:
	    		</p>
	    		<pre><code class="language-javascript">var r = new REST.Request();
r.setURI("http://api.service.com/orders/23/json");
r.setMethod("PUT");
r.setContentType("application/json");
r.setEntity({id: "23"});
r.addMatrixParameter("JSESSIONID", "12309812378123");
r.execute(function(status, request, entity){
 log("Response is "+status);
});</code></pre>
   			</div></div><br class="example-break"/>
   		</section>
   	</section>
   	<section class="section" id="d5e4351"><div class="titlepage"><div><div><h2 class="title">53.3. Caching Features</h2></div></div></div>
   		
   		<p>
   			RESTEasy AJAX Client works well with server side caching features. But the buggy browsers cache will 
   			always prevent the function to work properly. If you'd like to use RESTEasy's caching feature with its
   			AJAX client, you can enable 'antiBrowserCache' option:
   		</p>
	    <pre><code class="language-javascript">REST.antiBrowserCache = true;</code></pre>
		<p>
			The above setting should be set once before you call any APIs.
		</p>
   	</section>
</section>
   

<section class="chapter" id="WADL"><div class="titlepage"><div><div><h1 class="title">Chapter 54. RESTEasy WADL Support</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="section"><a href="#d5e4359">54.1. RESTEasy WADL Support for Servlet Container(Deprecated)</a></span></li><li><span class="section"><a href="#d5e4369">54.2. RESTEasy WADL Support for Servlet Container(Updated)</a></span></li><li><span class="section"><a href="#d5e4383">54.3. RESTEasy WADL support for Sun JDK HTTP Server</a></span></li><li><span class="section"><a href="#d5e4393">54.4. RESTEasy WADL support for Netty Container</a></span></li><li><span class="section"><a href="#d5e4398">54.5. RESTEasy WADL Support for Undertow Container</a></span></li></ul></div>
    
    <p>RESTEasy has its own support to generate WADL for its resources, and it supports several different containers. The following text will show you how to use this feature in different containers.
    </p>
    <section class="section" id="d5e4359"><div class="titlepage"><div><div><h2 class="title">54.1. RESTEasy WADL Support for Servlet Container(Deprecated)</h2></div></div></div>
        
        <div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2>
            <p>
                The content introduced in this section is outdated, and the <code class="code">ResteasyWadlServlet</code> class is deprecated because it doesn't support the GRAMMAR generation. Please check the <code class="code">ResteasyWadlDefaultResource</code> introduced in the later section.
            </p>
        </div>
        <p>
            RESTEasy WADL uses ResteasyWadlServlet to support servlet container. It can be registered into web.xml to enable WADL feature. Here is an example to show the usages of ResteasyWadlServlet in web.xml:
        </p>
        <pre><code class="no-highlight">&lt;servlet&gt;
	&lt;servlet-name&gt;RESTEasy WADL&lt;/servlet-name&gt;
	&lt;servlet-class&gt;org.jboss.resteasy.wadl.ResteasyWadlServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
	&lt;servlet-name&gt;RESTEasy WADL&lt;/servlet-name&gt;
	&lt;url-pattern&gt;/application.xml&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
        <p>
            The preceding configuration in web.xml shows how to enable ResteasyWadlServlet and mapped it to /application.xml. And then the WADL can be accessed from the configured URL:
        </p>
        <pre><code class="no-highlight">/application.xml</code></pre>
    </section>
    <section class="section" id="d5e4369"><div class="titlepage"><div><div><h2 class="title">54.2. RESTEasy WADL Support for Servlet Container(Updated)</h2></div></div></div>
    
        <p>
            This section introduces the recommended way to enable WADL support under Servlet Container situation. Firstly, you need to add a class then extends the <code class="code">ResteasyWadlDefaultResource</code> to serve a resource path. Here is an example:
        </p>
        <pre><code class="no-highlight">import org.jboss.resteasy.wadl.ResteasyWadlDefaultResource;
import javax.ws.rs.Path;

@Path("/")
public class MyWadlResource extends ResteasyWadlDefaultResource {
}</code></pre>
        <p>As the sample shown above, it will enable the <code class="code">ResteasyWadlDefaultResource</code> and serves this URL by default:</p>
        <pre><code class="no-highlight">/application.xml</code></pre>
        <p>To enable the GRAMMAR generation, you can extend the <code class="code">ResteasyWadlDefaultResource</code> list this:</p>
        <pre><code class="no-highlight">import org.jboss.resteasy.wadl.ResteasyWadlDefaultResource;
import org.jboss.resteasy.wadl.ResteasyWadlWriter;

import javax.ws.rs.Path;

@Path("/")
public class MyWadlResource extends ResteasyWadlDefaultResource {

    public MyWadlResource() {
        ResteasyWadlWriter.ResteasyWadlGrammar wadlGrammar = new ResteasyWadlWriter.ResteasyWadlGrammar();
        wadlGrammar.enableSchemaGeneration();
        getWadlWriter().setWadlGrammar(wadlGrammar);

    }
}</code></pre>
        <p>With the above setup, the WADL module will generate GRAMMAR automatically and register the service under this url:</p>
        <pre><code class="no-highlight">/wadl-extended/xsd0.xsd</code></pre>
        <p>Above is the basic usage of WADL module under servlet container deployment.</p>
    </section>
    <section class="section" id="d5e4383"><div class="titlepage"><div><div><h2 class="title">54.3. RESTEasy WADL support for Sun JDK HTTP Server</h2></div></div></div>
        
        <p>
            RESTEasy has provided a ResteasyWadlDefaultResource to generate WADL info for its embedded containers. Here is and example to show how to use it with RESTEasy's Sun JDK HTTP Server container:
        </p>
        <pre><code class="no-highlight">com.sun.net.httpserver.HttpServer httpServer =
	com.sun.net.httpserver.HttpServer.create(new InetSocketAddress(port), 10);

org.jboss.resteasy.plugins.server.sun.http.HttpContextBuilder contextBuilder = 
	new org.jboss.resteasy.plugins.server.sun.http.HttpContextBuilder();

contextBuilder.getDeployment().getActualResourceClasses()
	.add(ResteasyWadlDefaultResource.class);
contextBuilder.bind(httpServer);

ResteasyWadlDefaultResource.getServices()
	.put("/",
		ResteasyWadlGenerator
			.generateServiceRegistry(contextBuilder.getDeployment()));

httpServer.start();</code></pre>
        <p>
            From the above code example, we can see how ResteasyWadlDefaultResource is registered into deployment:
        </p>
        <pre><code class="no-highlight">contextBuilder.getDeployment().getActualResourceClasses()
	.add(ResteasyWadlDefaultResource.class);</code></pre>
        <p>
            Another important thing is to use ResteasyWadlGenerator to generate the WADL info for the resources in deployment at last:
        </p>
        <pre><code class="no-highlight">ResteasyWadlDefaultResource.getServices()
	.put("/",
		ResteasyWadlGenerator
			.generateServiceRegistry(contextBuilder.getDeployment()));</code></pre>
        <p>After the above configuration is set, then users can access "/application.xml" to fetch the WADL info, because ResteasyWadlDefaultResource has @PATH set to "/application.xml" as default:
        </p>
        <pre><code class="no-highlight">@Path("/application.xml")
public class ResteasyWadlDefaultResource</code></pre>
    </section>
    <section class="section" id="d5e4393"><div class="titlepage"><div><div><h2 class="title">54.4. RESTEasy WADL support for Netty Container</h2></div></div></div>
        
        <p>RESTEasy WADL support for Netty Container is simliar to the support for JDK HTTP Server. It also uses ResteasyWadlDefaultResource to serve '/application.xml' and ResteasyWadlGenerator to generate WADL info for resources. Here is the sample code:
        </p>
        <pre><code class="no-highlight">ResteasyDeployment deployment = new ResteasyDeploymentImpl();

netty = new NettyJaxrsServer();
netty.setDeployment(deployment);
netty.setPort(port);
netty.setRootResourcePath("");
netty.setSecurityDomain(null);
netty.start();

deployment.getRegistry()
	.addPerRequestResource(ResteasyWadlDefaultResource.class);        
ResteasyWadlDefaultResource.getServices()
	.put("/", ResteasyWadlGenerator.generateServiceRegistry(deployment));</code></pre>
        <p>
            Please note for all the embedded containers like JDK HTTP Server and Netty Container, if the resources in the deployment changes at runtime, the ResteasyWadlGenerator.generateServiceRegistry() need to be re-run to refresh the WADL info.
        </p>
    </section>
    <section class="section" id="d5e4398"><div class="titlepage"><div><div><h2 class="title">54.5. RESTEasy WADL Support for Undertow Container</h2></div></div></div>
        
        <p>
            The RESTEasy Undertow Container is a embedded Servlet Container, and RESTEasy WADL provides a connector to it. To use RESTEasy Undertow Container together with WADL support, you need to add these three components into your maven dependencies:
        </p>
        <pre><code class="no-highlight">
&lt;dependency&gt;
	&lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
	&lt;artifactId&gt;resteasy-wadl&lt;/artifactId&gt;
	&lt;version&gt;${project.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
	&lt;artifactId&gt;resteasy-wadl-undertow-connector&lt;/artifactId&gt;
	&lt;version&gt;${project.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
	&lt;artifactId&gt;resteasy-undertow&lt;/artifactId&gt;
	&lt;version&gt;${project.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
        <p>The resteasy-wadl-undertow-connector provides a WadlUndertowConnector to help you to use WADL in RESTEasy Undertow Container. Here is the code example:
        </p>
        <pre><code class="no-highlight">
UndertowJaxrsServer server = new UndertowJaxrsServer().start();
WadlUndertowConnector connector = new WadlUndertowConnector();
connector.deployToServer(server, MyApp.class);
</code></pre>
        <p>The MyApp class shown in above code is a standard JAX-RS 2.0 Application class in your project:</p>
        <pre><code class="no-highlight">
            
@ApplicationPath("/base")
public static class MyApp extends Application {
    @Override
    public Set&lt;Class&lt;?&gt;&gt; getClasses() {
        HashSet&lt;Class&lt;?&gt;&gt; classes = new HashSet&lt;Class&lt;?&gt;&gt;();
        classes.add(YourResource.class);
        return classes;
    }
}
</code></pre>
        <p>After the Application is deployed to the UndertowJaxrsServer via WadlUndertowConnector, you can access the WADL info at "/application.xml" prefixed by the @ApplicationPath in your Application class. If you want to override the @ApplicationPath, you can use the other method in WadlUndertowConnector:</p>
        <pre><code class="no-highlight">
            
public UndertowJaxrsServer deployToServer(UndertowJaxrsServer server, Class&lt;? extends Application&gt; application, String contextPath)
            
        </code></pre>
        <p>The "deployToServer" method shown above accepts a "contextPath" parameter, which you can use to override the @ApplicationPath value in the Application class.</p>
    </section>
</section>

   

<section class="chapter" id="Tracing_Feature"><div class="titlepage"><div><div><h1 class="title">Chapter 55. RESTEasy Tracing Feature</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="section"><a href="#d5e4411">55.1. Overview</a></span></li><li><span class="section"><a href="#d5e4416">55.2. Tracing Info Mode</a></span></li><li><span class="section"><a href="#d5e4424">55.3. Tracing Info Level</a></span></li><li><span class="section"><a href="#d5e4433">55.4. Basic Usages</a></span></li><li><span class="section"><a href="#d5e4459">55.5. Client Side Tracing Info</a></span></li><li><span class="section"><a href="#d5e4464">55.6. Json Formatted Response</a></span></li><li><span class="section"><a href="#d5e4475">55.7. List Of Tracing Events</a></span></li><li><span class="section"><a href="#d5e4543">55.8. Tracing Example</a></span></li></ul></div>
    
    <section class="section" id="d5e4411"><div class="titlepage"><div><div><h2 class="title">55.1. Overview</h2></div></div></div>
        
        <p>
            Tracing feature is a way for the users of the RESTEasy to understand what's going on internally in the
            container when a request is processed. It's different from the pure logging system or profiling feature,
            which provides more general information about the request and response.
        </p>
        <p>
            The tracing feature provides more internal states of the JAX-RS container. For example, it could be able
            to show what filters a request is going through, or how long time a request is processed and other kinds
            of information.
        </p>
        <p>
            Currently it doesn't have a standard or spec to define the tracing feature, so the tracing feature is
            tightly coupled with the concrete JAX-RS implementation itself. In this chapter, let's check the design and
            usage of the tracing feature.
        </p>
    </section>
    <section class="section" id="d5e4416"><div class="titlepage"><div><div><h2 class="title">55.2. Tracing Info Mode</h2></div></div></div>
        
        <p>The RESTEasy tracing feature supports three logging mode:
        </p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">OFF</li><li class="listitem">ON_DEMAND</li><li class="listitem">ALL</li></ul></div>
        <p>
            "ALL" will enable the tracing feature. "ON_DEMAND" mode will give the control to client side: A client can
            send
            a tracing request via HTTP header and get the tracing info back from response headers. "OFF" mode will
            disable
            the tracing feature, and this is the default mode.
        </p>
    </section>
    <section class="section" id="d5e4424"><div class="titlepage"><div><div><h2 class="title">55.3. Tracing Info Level</h2></div></div></div>
        
        <p>The tracing info has three levels:
        </p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">SUMMARY</li><li class="listitem">TRACE</li><li class="listitem">VERBOSE</li></ul></div>
        <p>
            The "SUMMARY" level will emit some brief tracing information. The "TRACE" level will produce more detailed
            tracing information, and the "VERBOSE" level will generate extremely detailed tracing information.
        </p>
        <p>
            The tracing feature relies on the JBoss Logging framework to produce the tracing info, so the JBoss Logging
            configuration actually controls the final output of the tracing info. So it is JBoss Logging framework
            configuration
            that controls the logging threshold of the tracing info.
        </p>
    </section>
    <section class="section" id="d5e4433"><div class="titlepage"><div><div><h2 class="title">55.4. Basic Usages</h2></div></div></div>
        
        <p>By default, the tracing feature is turned off. If you want to enable the tracing feature, you need to
            add the following dependency in your project:
            </p><pre><code class="no-highlight">&lt;dependency&gt;
    &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
    &lt;artifactId&gt;resteasy-tracing-api&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre><p>
        </p>
        <p>
            Because the tracing feature is an optional feature, the above dependency is provided by the
            <a class="ulink" href="https://github.com/resteasy/resteasy-extensions">resteasy-extensions</a>
            project.
        </p>
        <p>
            After including the dependency in your project, you can set the tracing mode and tracing level via the
            context-param parameters in your web
            project’s web.xml file. Here is the example:
            </p><pre><code class="no-highlight">&lt;context-param&gt;
    &lt;param-name&gt;resteasy.server.tracing.type&lt;/param-name&gt;
    &lt;param-value&gt;ALL&lt;/param-value&gt;
    &lt;param-name&gt;resteasy.server.tracing.threshold&lt;/param-name&gt;
    &lt;param-value&gt;SUMMARY&lt;/param-value&gt;
&lt;/context-param&gt;</code></pre><p>
        </p>
        <p>
            Besides the above configuration, we also need to make sure that the underlying JBoss Logger is configured
            properly so it can output the tracing info as required. Here is an example of the "logging.properties":

            </p><pre><code class="no-highlight"># Additional logger names to configure (root logger is always configured)
#loggers=org.foo.bar, org.foo.baz
# Root logger level
logger.level=ALL
# Declare handlers for the root logger
logger.handlers=CONSOLE, FILE
# Declare handlers for additional loggers
#logger.org.foo.bar.handlers=XXX, YYY
# Console handler configuration
handler.CONSOLE=org.jboss.logmanager.handlers.ConsoleHandler
handler.CONSOLE.properties=autoFlush
handler.CONSOLE.level=ALL
handler.CONSOLE.autoFlush=true
handler.CONSOLE.formatter=PATTERN
# File handler configuration
handler.FILE=org.jboss.logmanager.handlers.FileHandler
handler.FILE.level=ALL
handler.FILE.properties=autoFlush,fileName
handler.FILE.autoFlush=true
handler.FILE.fileName=/tmp/jboss.log
handler.FILE.formatter=PATTERN
# The log format pattern for both logs
formatter.PATTERN=org.jboss.logmanager.formatters.PatternFormatter
formatter.PATTERN.properties=pattern
formatter.PATTERN.pattern=%d{HH:mm:ss,SSS} %-5p [%c{1}] %m%n</code></pre><p>

            In above setting, we have set the logger level to "ALL", and output log file to "/tmp/jboss.log". In this
            case, we can make sure that we get all the tracing info.
        </p>
        <p>
            After enabling the tracing feature as shown above, we should get the tracing info output like following:
            </p><pre><code class="no-highlight">16:21:40,110 INFO  [general] org.jboss.resteasy.plugins.server.servlet.Servlet3AsyncHttpRequest@721299ff START baseUri=[http://localhost:8081/] requestUri=[http://localhost:8081/type] method=[GET] authScheme=[n/a] accept=n/a accept-encoding=n/a accept-charset=n/a accept-language=n/a content-type=n/a content-length=n/a  [ ---- ms]
16:21:40,110 TRACE [general] org.jboss.resteasy.plugins.server.servlet.Servlet3AsyncHttpRequest@721299ff START_HEADERS Other request headers: Connection=[Keep-Alive] Host=[localhost:8081] User-Agent=[Apache-HttpClient/4.5.4 (Java/1.8.0_201)]  [ ---- ms]
16:21:40,114 INFO  [general] org.jboss.resteasy.plugins.server.servlet.Servlet3AsyncHttpRequest@721299ff PRE_MATCH_SUMMARY PreMatchRequest summary: 0 filters [ 0.04 ms]
16:21:40,118 DEBUG [general] org.jboss.resteasy.plugins.server.servlet.Servlet3AsyncHttpRequest@721299ff REQUEST_FILTER Filter by [io.weli.tracing.HttpMethodOverride @60353244] [ 0.02 ms]
...
16:21:40,164 INFO  [general] org.jboss.resteasy.plugins.server.servlet.Servlet3AsyncHttpRequest@721299ff RESPONSE_FILTER_SUMMARY Response summary: 1 filters [ 8.11 ms]
16:21:40,164 INFO  [general] org.jboss.resteasy.plugins.server.servlet.Servlet3AsyncHttpRequest@721299ff FINISHED Response status: 200 [ ---- ms]</code></pre><p>

            From the above tracing log output shown above, we can see that the entry of tracing log contains several
            parts:

            </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    <p>Level Of The Log Entry</p>
                    <p>We can see the log entries have different log levels, such as "TRACE",
                        "INFO", "DEBUG". The tracing feature maps its own tracing info levels to the JBoss Logger output
                        levels like this.
                    </p>
                </li><li class="listitem">
                    <p>The Request Scope Id</p>
                    <p>
                        We can see the request id like:
                        </p><pre><code class="no-highlight">
org.jboss.resteasy.plugins.server.servlet.Servlet3AsyncHttpRequest@721299ff</code></pre><p>
                        So we can know which request the log entry belongs to.
                    </p>
                </li><li class="listitem">
                    <p>The Type Of The Tracing Log</p>
                    <p>tracing log entries are divided into multiple categories, such as
                        "START_HEADERS", "REQUEST_FILTER", "FINISHED", etc.
                    </p>
                </li><li class="listitem">
                    <p>
                        The Detail Of The Log Entry
                    </p>
                    <p>The last part of a log entry is the detail message of this
                        entry.
                    </p>
                </li></ul></div><p>

            In next section let's see how do we fetch the tracing info from client side.
        </p>
    </section>
    <section class="section" id="d5e4459"><div class="titlepage"><div><div><h2 class="title">55.5. Client Side Tracing Info</h2></div></div></div>
        
        <p>
            From client side, we can send request to the server side as usual, and if the server side is configured
            properly to produce tracing info, then the info will also be sent back to client side via response headers.
            For
            example, we can send request to the server like this:

            </p><pre><code class="no-highlight">$ curl -i http://localhost:8081/foo</code></pre><p>

            And then we can get the tracing info from the response header like the following:

            </p><pre><code class="no-highlight">HTTP/1.1 200 OK
X-RESTEasy-Tracing-026: org.jboss.resteasy.plugins.server.servlet.Servlet3AsyncHttpRequest@7a49a8aa MBW         [ ---- / 61.57 ms |  ---- %] [org.jboss.resteasy.plugins.providers.InputStreamProvider @1cbf0b08] is skipped
...
Date: Wed, 27 Mar 2019 09:39:50 GMT
Connection: keep-alive
X-RESTEasy-Tracing-000: org.jboss.resteasy.plugins.server.servlet.Servlet3AsyncHttpRequest@7a49a8aa START       [ ---- /  ---- ms |  ---- %] baseUri=[http://localhost:8081/] requestUri=[http://localhost:8081/type] method=[GET] authScheme=[n/a] accept=*/* accept-encoding=n/a accept-charset=n/a accept-language=n/a content-type=n/a content-length=n/a
...
X-RESTEasy-Tracing-025: org.jboss.resteasy.plugins.server.servlet.Servlet3AsyncHttpRequest@7a49a8aa MBW         [ ---- / 61.42 ms |  ---- %] [org.jboss.resteasy.plugins.providers.FileRangeWriter @35b791fa] is skipped</code></pre><p>

            From above output, we can see the tracing info is in response headers, and it's marked in sequence as in the
            form of "X-RESTEasy-Tracing-nnn".
        </p>
    </section>
    <section class="section" id="d5e4464"><div class="titlepage"><div><div><h2 class="title">55.6. Json Formatted Response</h2></div></div></div>
        
        <p>The tracing log can be returned to client side in JSON format. To use
            this feature, we need to choose a JSON provider for tracing module to
            generate JSON formatted info. There are two JSON providers you can choose from and they both support the
            JSON data marshalling. The first choice is to use the jackson2 provider:
            </p><pre><code class="no-highlight">&lt;dependency&gt;
    &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
    &lt;artifactId&gt;resteasy-jackson2-provider&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre><p>
        </p>
        <p>
            The second choice is to use the json-binding provider:

            </p><pre><code class="no-highlight">&lt;dependency&gt;
    &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
    &lt;artifactId&gt;resteasy-json-binding-provider&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre><p>
        </p>
        <p>
            After including either of the above module, we can send request to server to get the JSON formatted tracing
            info.
            Here is a request example(the example is provided at last section of this chapter):

            </p><pre><code class="no-highlight">
$ curl -H "X-RESTEasy-Tracing-Accept-Format: JSON" -i http://localhost:8081/type</code></pre><p>

            In the above curl command, we have added "X-RESTEasy-Tracing-Accept-Format: JSON" into request header, in
            this way we are
            requesting the json formatted tracing info from server, and the tracing info in response header is like the
            following:

            </p><pre><code class="no-highlight">
X-RESTEasy-Tracing-000: [{"event":"START","duration":0,"timestamp":195286694509932,"text":"baseUri=[http://localhost:8081/] requestUri=[http://localhost:8081/type] method=[GET] authScheme=[n/a] accept=*/* accept-encoding=n/a accept-charset=n/a accept-language=n/a content-type=n/a content-length=n/a ","requestId":"org.jboss.resteasy.plugins.server.servlet.Servlet3AsyncHttpRequest@7f8a33b9"},{"event":"START_HEADERS","duration":0,"timestamp":195286695053606,"text":"Other request headers: Accept=[*/*] Host=[localhost:8081] User-Agent=[curl/7.54.0] X-RESTEasy-Tracing-Accept-Format=[JSON] ","requestId":"org.jboss.resteasy.plugins.server.servlet.Servlet3AsyncHttpRequest@7f8a33b9"}...{"event":"FINISHED","duration":0,"timestamp":195286729758836,"text":"Response status: 200","requestId":"org.jboss.resteasy.plugins.server.servlet.Servlet3AsyncHttpRequest@7f8a33b9"}]</code></pre><p>
        </p>
        <p>
            The above text is the raw output from response, and we can format it to make it readable:

            </p><pre><code class="no-highlight">[{
    "X-RESTEasy-Tracing-000": [
        {
            "event": "START",
            "duration": 0,
            "timestamp": 195286694509932,
            "text": "baseUri=[http://localhost:8081/] requestUri=[http://localhost:8081/type] method=[GET] authScheme=[n/a] accept=*/* accept-encoding=n/a accept-charset=n/a accept-language=n/a content-type=n/a content-length=n/a ",
            "requestId": "org.jboss.resteasy.plugins.server.servlet.Servlet3AsyncHttpRequest@7f8a33b9"
        },
        {
            "event": "START_HEADERS",
            "duration": 0,
            "timestamp": 195286695053606,
            "text": "Other request headers: Accept=[*/*] Host=[localhost:8081] User-Agent=[curl/7.54.0] X-RESTEasy-Tracing-Accept-Format=[JSON] ",
            "requestId": "org.jboss.resteasy.plugins.server.servlet.Servlet3AsyncHttpRequest@7f8a33b9"
        },
        {
            "event": "PRE_MATCH_SUMMARY",
            "duration": 14563,
            "timestamp": 195286697637157,
            "text": "PreMatchRequest summary: 0 filters",
            "requestId": "org.jboss.resteasy.plugins.server.servlet.Servlet3AsyncHttpRequest@7f8a33b9"
        },
 ...
        {
            "event": "FINISHED",
            "duration": 0,
            "timestamp": 195286729758836,
            "text": "Response status: 200",
            "requestId": "org.jboss.resteasy.plugins.server.servlet.Servlet3AsyncHttpRequest@7f8a33b9"
        }
    ]
}]</code></pre><p>
            From above we can see the tracing info is returned as JSON text.
        </p>
    </section>
    <section class="section" id="d5e4475"><div class="titlepage"><div><div><h2 class="title">55.7. List Of Tracing Events</h2></div></div></div>
        
        <p>
            The tracing events are defined in <a class="ulink" href="https://github.com/resteasy/resteasy-extensions/blob/master/tracing/src/main/java/org/jboss/resteasy/tracing/api/RESTEasyServerTracingEvent.java">RESTEasyServerTracingEvent</a>. Here is a complete list of the tracing events and its descriptions:

            </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    <p>
                        DISPATCH_RESPONSE
                    </p>
                    <p>
                        Resource method invocation results to JAX-RS Response.
                    </p>
                </li><li class="listitem">
                    <p>
                        EXCEPTION_MAPPING
                    </p>
                    <p>
                        ExceptionMapper invoked.
                    </p>
                </li><li class="listitem">
                    <p>
                        FINISHED
                    </p>
                    <p>
                        Request processing finished.
                    </p>
                </li><li class="listitem">
                    <p>
                        MATCH_LOCATOR
                    </p>
                    <p>
                        Matched sub-resource locator method.
                    </p>
                </li><li class="listitem">
                    <p>
                        MATCH_PATH_FIND
                    </p>
                    <p>
                        Matching path pattern.
                    </p>
                </li><li class="listitem">
                    <p>
                        MATCH_PATH_NOT_MATCHED
                    </p>
                    <p>
                        Path pattern not matched.
                    </p>
                </li><li class="listitem">
                    <p>
                        MATCH_PATH_SELECTED
                    </p>
                    <p>
                        Path pattern matched/selected.
                    </p>
                </li><li class="listitem">
                    <p>
                        MATCH_PATH_SKIPPED
                    </p>
                    <p>
                        Path pattern skipped as higher-priority pattern has been selected already.
                    </p>
                </li><li class="listitem">
                    <p>
                        MATCH_RESOURCE
                    </p>
                    <p>
                        Matched resource instance.
                    </p>
                </li><li class="listitem">
                    <p>
                        MATCH_RESOURCE_METHOD
                    </p>
                    <p>
                        Matched resource method.
                    </p>
                </li><li class="listitem">
                    <p>
                        MATCH_RUNTIME_RESOURCE
                    </p>
                    <p>
                        Matched runtime resource.
                    </p>
                </li><li class="listitem">
                    <p>
                        MATCH_SUMMARY
                    </p>
                    <p>
                        Matching summary.
                    </p>
                </li><li class="listitem">
                    <p>
                        METHOD_INVOKE
                    </p>
                    <p>
                        Resource method invoked.
                    </p>
                </li><li class="listitem">
                    <p>
                        PRE_MATCH
                    </p>
                    <p>
                        RESTEasy HttpRequestPreprocessor invoked.
                    </p>
                </li><li class="listitem">
                    <p>
                        PRE_MATCH_SUMMARY
                    </p>
                    <p>
                        RESTEasy HttpRequestPreprocessor invoked.
                    </p>
                </li><li class="listitem">
                    <p>
                        REQUEST_FILTER
                    </p>
                    <p>
                        ContainerRequestFilter invoked.
                    </p>
                </li><li class="listitem">
                    <p>
                        REQUEST_FILTER_SUMMARY
                    </p>
                    <p>
                        ContainerRequestFilter invocation summary.
                    </p>
                </li><li class="listitem">
                    <p>
                        RESPONSE_FILTER
                    </p>
                    <p>
                        ContainerResponseFilter invoked.
                    </p>
                </li><li class="listitem">
                    <p>
                        RESPONSE_FILTER_SUMMARY
                    </p>
                    <p>
                        ContainerResponseFilter invocation summary.
                    </p>
                </li><li class="listitem">
                    <p>
                        START
                    </p>
                    <p>
                        Request processing started.
                    </p>
                </li><li class="listitem">
                    <p>
                        START_HEADERS
                    </p>
                    <p>
                        All HTTP request headers.
                    </p>
                </li></ul></div><p>
        </p>
    </section>
    <section class="section" id="d5e4543"><div class="titlepage"><div><div><h2 class="title">55.8. Tracing Example</h2></div></div></div>
        
        <p>
            In the "resteasy-example" project, it contains a <a class="ulink" href="https://github.com/resteasy/resteasy-examples/tree/master/tracing-example">RESTEasy Tracing
            Example
        </a> to show the usages of tracing features. Please check the example to see the usages in action.
        </p>
    </section>
</section>
   <section class="chapter" id="Validation"><div class="titlepage"><div><div><h1 class="title">Chapter 56. Validation</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="section"><a href="#d5e4576">56.1. Violation reporting</a></span></li><li><span class="section"><a href="#d5e4608">56.2. Validation Service Providers</a></span></li><li><span class="section"><a href="#d5e4626">56.3. Validation Implementations</a></span></li></ul></div>
   
   
   <p>
   RESTEasy provides the support for validation mandated by the
   <a class="ulink" href="http://www.jcp.org/en/jsr/detail?id=339">JAX-RS: Java API for RESTful Web Services 2.1 </a>,
   given the presence of an implementation of the
   <a class="ulink" href="https://beanvalidation.org/2.0/spec/">Bean Validation specification</a>
   such as <a class="ulink" href="http://hibernate.org/validator/">Hibernate Validator</a>. 
   </p>
   
   <p>
   Validation provides a declarative way of imposing constraints on fields and properties of beans, bean classes,
   and the parameters and return values of bean methods.  For example, in
   </p>
   
   <pre><code class="no-highlight">
@Path("all")
@TestClassConstraint(5)
public class TestResource
{
   @Size(min=2, max=4)
   @PathParam("s")
   String s;

   private String t;

   @Size(min=3)  
   public String getT()
   {
      return t;
   }

   @PathParam("t") 
   public void setT(String t)
   {
      this.t = t;
   }

   @POST
   @Path("{s}/{t}/{u}")
   @Pattern(regexp="[a-c]+")
   public String post(@PathParam("u") String u)
   {
      return u;
   }
}
</code></pre>  
   
   <p>
   the field <code class="code">s</code> is constrained by the Bean Validation built-in annotation <code class="code">@Size</code>
   to have between 2 and 4 characters, the property <code class="code">t</code> is constrained to have at least 3
   characters, and the <code class="code">TestResource</code> object is constrained by the application defined
   annotation <code class="code">@TestClassConstraint</code> to have the combined lengths of <code class="code">s</code> and
   <code class="code">t</code> less than 5:
   </p>
   
   <pre><code class="no-highlight">
@Constraint(validatedBy = TestClassValidator.class)
@Target({TYPE})
@Retention(RUNTIME)
public @interface TestClassConstraint
{
   String message() default "Concatenation of s and t must have length &gt; {value}";
   Class&lt;?&gt;[] groups() default {};
   Class&lt;? extends Payload&gt;[] payload() default {};
   int value();
}

public class TestClassValidator implements ConstraintValidator&lt;TestClassConstraint, TestResource&gt;
{
   int length;

   public void initialize(TestClassConstraint constraintAnnotation)
   {
      length = constraintAnnotation.value();
   }

   public boolean isValid(TestResource value, ConstraintValidatorContext context)
   {
      boolean b = value.retrieveS().length() + value.getT().length() &lt; length;
   }
}
</code></pre> 
   
   <p>
   See the links above for more about how to create validation annotations.
   </p>
   
   <p>
   Also, the method parameter <code class="code">u</code> is constrained to have no more than 5 characters,
   and the return value of method <code class="code">post</code> is constrained by the built-in annotation
   <code class="code">@Pattern</code> to match the regular expression "[a-c]+".
   </p>
   
   <p>
   The sequence of validation constraint testing is as follows:
   </p>
   
   <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">Create the resource and validate property, and class constraints.</li><li class="listitem">Validate the resource method parameters.</li><li class="listitem">If no violations have been detected, call the resource method and validate the return value</li></ol></div>
   
   <p>
      <span class="bold"><strong>Note.</strong></span> Though fields and properties are technically different, they are subject
      to the same kinds of constraints, so they are treated the same in the context of validation. Together,
      they will both be referred to as "properties" herein.
   </p>
   
   <section class="section" id="d5e4576"><div class="titlepage"><div><div><h2 class="title">56.1. Violation reporting</h2></div></div></div>
   
   
   <p>
   If a validation problem occurs, either a problem with the validation definitions or a constraint violation,
   RESTEasy will set the return header <code class="classname">org.jboss.resteasy.api.validation.Validation.VALIDATION_HEADER</code>
   ("validation-exception") to "true".
   </p>
   
   <p>
   If RESTEasy detects a structural validation problem, such as a validation annotation with a 
   missing validator class, it will return a String representation of a 
   <code class="classname">javax.validation.ValidationException</code>.  For example
   </p>
   
<pre><code class="no-highlight">
javax.validation.ValidationException: HV000028: Unexpected exception during isValid call.[org.jboss.resteasy.test.validation.TestValidationExceptions$OtherValidationException]
</code></pre>
   
   <p>
   If any constraint violations are detected, RESTEasy will return a report in one of a variety
   of formats.  If one of "application/xml" or "application/json" occur in the "Accept" request header,
   RESTEasy will return an appropriately marshalled instance of
   <code class="classname">org.jboss.resteasy.api.validation.ViolationReport</code>:
   </p>

<pre><code class="no-highlight">
@XmlRootElement(name="violationReport")
@XmlAccessorType(XmlAccessType.FIELD)
public class ViolationReport
{
   ...

   public ArrayList&lt;ResteasyConstraintViolation&gt; getPropertyViolations()
   {
      return propertyViolations;
   }

   public ArrayList&lt;ResteasyConstraintViolation&gt; getClassViolations()
   {
      return classViolations;
   }

   public ArrayList&lt;ResteasyConstraintViolation&gt; getParameterViolations()
   {
      return parameterViolations;
   }

   public ArrayList&lt;ResteasyConstraintViolation&gt; getReturnValueViolations()
   {
      return returnValueViolations;
   }

   ...
}
</code></pre>

   <p>
   where <code class="classname">org.jboss.resteasy.api.validation.ResteasyConstraintViolation</code> is defined:
   </p>
   
<pre><code class="no-highlight">
@XmlRootElement(name="resteasyConstraintViolation")
@XmlAccessorType(XmlAccessType.FIELD)
public class ResteasyConstraintViolation implements Serializable
{
   ...
   
   /**
    * @return type of constraint
    */
   public ConstraintType.Type getConstraintType()
   {
      return constraintType;
   }
   
   /**
    * @return description of element violating constraint
    */
   public String getPath()
   {
      return path;
   }
   
   /**
    * @return description of constraint violation
    */
   public String getMessage()
   {
      return message;
   }
   
   /**
    * @return object in violation of constraint
    */
   public String getValue()
   {
      return value;
   }
   
   /**
    * @return String representation of violation
    */
   public String toString()
   {
      return "[" + type() + "]\r[" + path + "]\r[" + message + "]\r[" + value + "]\r";
   }
   
   /**
    * @return String form of violation type 
    */
   public String type()
   {
      return constraintType.toString();
   }
}
</code></pre>

   <p>
   and <code class="classname">org.jboss.resteasy.api.validation.ConstraintType</code> is the enumeration
   </p>
   
<pre><code class="no-highlight">
public class ConstraintType
{
   public enum Type {CLASS, PROPERTY, PARAMETER, RETURN_VALUE};
}
</code></pre>

   <p>
   If both "application/xml" or "application/json" occur in the "Accept" request header, the media type
   is chosen according to the ranking given by implicit or explicit "q" parameter values.  In the
   case of a tie, the returned media type is indeterminate.
   </p>
   
   <p>If neither "application/xml" or "application/json" occur in the "Accept" request header,
   RESTEasy returns a report with a String representation of each
   <code class="classname">ResteasyConstraintViolation</code>, where
   each field is delimited by '[' and ']', followed by a '\r', with a final '\r' at the end.
   For example,
   </p>
   
<pre><code class="no-highlight">
[PROPERTY]
[s]
[size must be between 2 and 4]
[a]

[PROPERTY]
[t]
[size must be between 3 and 5]
[z]

[CLASS]
[]
[Concatenation of s and t must have length &gt; 5]
[org.jboss.resteasy.validation.TestResource@68467a6f]

[PARAMETER]
[test.&lt;cross-parameter&gt;]
[Parameters must total &lt;= 7]
[[5, 7]]

[RETURN_VALUE]
[g.&lt;return value&gt;]
[size must be between 2 and 4]
[abcde]
</code></pre>

   <p>
   where the four fields are
   </p>
   
   <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">type of constraint</li><li class="listitem">path to violating element (e.g., property name, class name, method name and parameter name)</li><li class="listitem">message</li><li class="listitem">violating element</li></ol></div>
   
   <p>
   The <code class="classname">ViolationReport</code> can be reconsititued from the <code class="classname">String</code> as follows:
   </p>
   
<pre><code class="no-highlight">
Client client = ClientBuilder.newClient();
Invocation.Builder request = client.target(...).request();
Response response = request.get();
if (Boolean.valueOf(response.getHeaders().getFirst(Validation.VALIDATION_HEADER)))
{
   String s = response.readEntity(String.class);
   ViolationReport report = new ViolationReport(s);
}
</code></pre>

<p>
If the path field is considered to be too much server side information, it can be surpressed by setting
the parameter "resteasy.validation.suppress.path" to "true". In that case, "*" will be returned in the
path fields. [See <a class="xref" href="#microprofile_config" title="3.4. Configuration">Section 3.4, “Configuration”</a> for more information about application configuration.]
</p>

   </section>
            
   <section class="section" id="d5e4608"><div class="titlepage"><div><div><h2 class="title">56.2. Validation Service Providers</h2></div></div></div>
         
         
            <p>
   The form of validation mandated by the JAX-RS 2.1 specification, based on Bean Validation 1.1 or greater,
   is supported by the RESTEasy module resteasy-validator-provider, which produces the artifact
   resteasy-validator-provider-&lt;version&gt;.jar.  Validation is turned on by default (assuming
   resteasy-validator-provider-&lt;version&gt;.jar is available), though
   parameter and return value validation can be turned off or modified in the validation.xml
   configuration file. See the
   <a class="ulink" href="https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/?v=6.0">Hibernate Validator</a>
   documentation for the details.
   </p>
   
         <p>
         RESTEasy obtains a bean validation implementation by looking in the available
         META-INF/services/javax.ws.rs.Providers files for an implementation
         of <code class="classname">ContextResolver&lt;GeneralValidator&gt;</code>, where 
         <code class="classname">org.jboss.resteasy.spi.GeneralValidator</code> is
         </p>

<pre><code class="no-highlight">
public interface GeneralValidator
{
   /**
    * Validates all constraints on {@code object}.
    *
    * @param object object to validate
    * @param groups the group or list of groups targeted for validation (defaults to
    *        {@link Default})
    * @return constraint violations or an empty set if none
    * @throws IllegalArgumentException if object is {@code null}
    *         or if {@code null} is passed to the varargs groups
    * @throws ValidationException if a non recoverable error happens
    *         during the validation process
    */
   public abstract void validate(HttpRequest request, Object object, Class&lt;?&gt;... groups);
   /**
    * Validates all constraints placed on the parameters of the given method.
    *
    * @param &lt;T&gt; the type hosting the method to validate
    * @param object the object on which the method to validate is invoked
    * @param method the method for which the parameter constraints is validated
    * @param parameterValues the values provided by the caller for the given method's
    *        parameters
    * @param groups the group or list of groups targeted for validation (defaults to
    *        {@link Default})
    * @return a set with the constraint violations caused by this validation;
    *         will be empty if no error occurs, but never {@code null}
    * @throws IllegalArgumentException if {@code null} is passed for any of the parameters
    *         or if parameters don't match with each other
    * @throws ValidationException if a non recoverable error happens during the
    *         validation process
    */
   public abstract void validateAllParameters(HttpRequest request, Object object, Method method, Object[] parameterValues, Class&lt;?&gt;... groups);

   /**
    * Validates all return value constraints of the given method.
    *
    * @param &lt;T&gt; the type hosting the method to validate
    * @param object the object on which the method to validate is invoked
    * @param method the method for which the return value constraints is validated
    * @param returnValue the value returned by the given method
    * @param groups the group or list of groups targeted for validation (defaults to
    *        {@link Default})
    * @return a set with the constraint violations caused by this validation;
    *         will be empty if no error occurs, but never {@code null}
    * @throws IllegalArgumentException if {@code null} is passed for any of the object,
    *         method or groups parameters or if parameters don't match with each other
    * @throws ValidationException if a non recoverable error happens during the
    *         validation process
    */
   public abstract void validateReturnValue(
         HttpRequest request, Object object, Method method, Object returnValue, Class&lt;?&gt;... groups);

   /**
    * Indicates if validation is turned on for a class.
    * 
    * @param clazz Class to be examined
    * @return true if and only if validation is turned on for clazz
    */
   public abstract boolean isValidatable(Class&lt;?&gt; clazz);
     
   /**
    * Indicates if validation is turned on for a method.
    * 
    * @param method method to be examined
    * @return true if and only if validation is turned on for method
    */   
   public abstract boolean isMethodValidatable(Method method);

   void checkViolations(HttpRequest request);
}
</code></pre>

   <p>
   The methods and the javadoc are adapted from the Bean Validation 1.1 classes
   <code class="classname">javax.validation.Validator</code> and
   <code class="classname">javax.validation.executable.ExecutableValidator</code>.
   </p>
 
   <p>
   RESTEasy module resteasy-validator-provider supplies an implementation
   of <code class="methodname">GeneralValidator</code>.
   An alternative implementation may be supplied by implementing 
   <code class="classname">ContextResolver&lt;GeneralValidator&gt;</code> and
   <code class="classname">org.jboss.resteasy.spi.validation.GeneralValidator</code>.
   </p>
   
   <p>
   A validator intended to function in the presence of CDI must also implement the subinterface
   </p>
   
   <pre><code class="no-highlight">
public interface GeneralValidatorCDI extends GeneralValidator
{
   /**
    * Indicates if validation is turned on for a class.
    * 
    * This method should be called from the resteasy-jaxrs module. It should
    * test if injectorFactor is an instance of CdiInjectorFactory, which indicates
    * that CDI is active.  If so, it should return false. Otherwise, it should
    * return the same value returned by GeneralValidator.isValidatable().
    * 
    * @param clazz Class to be examined
    * @param injectorFactory the InjectorFactory used for clazz
    * @return true if and only if validation is turned on for clazz
    */
   public boolean isValidatable(Class&lt;?&gt; clazz, InjectorFactory injectorFactory);
   
   /**
    * Indicates if validation is turned on for a class.
    * This method should be called only from the resteasy-cdi module.
    * 
    * @param clazz Class to be examined
    * @return true if and only if validation is turned on for clazz
    */
   public abstract boolean isValidatableFromCDI(Class&lt;?&gt; clazz);
  
   /**
    * Throws a ResteasyViolationException if any validation violations have been detected.
    * The method should be called only from the resteasy-cdi module.
    * @param request
    */
   public void checkViolationsfromCDI(HttpRequest request);
   
   /**
    * Throws a ResteasyViolationException if either a ConstraintViolationException or a
    * ResteasyConstraintViolationException is embedded in the cause hierarchy of e.
    * 
    * @param request
    * @param e
    */
   public void checkForConstraintViolations(HttpRequest request, Exception e);
}
   </code></pre>

   <p>
   The validator in resteasy-validator-provider implements GeneralValidatorCDI.
   </p>
   </section>
   
   <section class="section" id="d5e4626"><div class="titlepage"><div><div><h2 class="title">56.3. Validation Implementations</h2></div></div></div>
      
         
    <p>
    As mentioned above, RESTEasy validation requires an implementation of the
    <a class="ulink" href="https://beanvalidation.org/2.0/spec/">Bean Validation specification</a>
    such as <a class="ulink" href="http://hibernate.org/validator/">Hibernate Validator</a>. Hibernate
    Validator is supplied automatically when RESTEasy is running in the context of WildFly. Otherwise,
    it should be made available. For example, in maven
    
    </p><pre><code class="no-highlight">
        &lt;dependency&gt;
            &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;
            &lt;artifactId&gt;hibernate-validator/artifactId&gt;
        &lt;/dependency&gt;
    </code></pre><p>
    </p>
   </section>
   
</section>

   <section class="chapter" id="I18N"><div class="titlepage"><div><div><h1 class="title">Chapter 57. Internationalization and Localization</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="section"><a href="#d5e4637">57.1. Internationalization</a></span></li><li><span class="section"><a href="#d5e4739">57.2. Localization</a></span></li></ul></div>
   

   <p>
   With the help of the JBoss Logging project, all log and exception messages in RESTEasy are internationalized. That is, they
   have a default value in English which can be overridden in any given locale by a file which gives translated values. For
   more information about internationalization and localization in Java, see, for example,
   <a class="ulink" href="http://docs.oracle.com/javase/tutorial/i18n">http://docs.oracle.com/javase/tutorial/i18n</a>. For more about
   JBoss Logging, see
   <a class="ulink" href="https://access.redhat.com/documentation/en-US/JBoss_Enterprise_Application_Platform/6/html/Development_Guide/">
   https://access.redhat.com/documentation/en-US/JBoss_Enterprise_Application_Platform/6/html/Development_Guide/</a>,
   Chapters 4 and 5.
   </p>

   <section class="section" id="d5e4637"><div class="titlepage"><div><div><h2 class="title">57.1. Internationalization</h2></div></div></div>
   
   <p>
   Each module in RESTEasy that produces any text in the form of logging messages or exception messages
   has an interface named org.jboss.resteasy...i18n.Messages which contains the default messages. Those
   modules which do any logging also have an interface named org.jboss.resteasy...i18n.LogMessages which gives access to an
   underlying logger. With the exception of the resteasy-jaxrs module, all messages are in the Messages class. resteasy-jaxrs
   has exception messages in the Messages class and log messages in the LogMessages class.
   </p>

   <p>
   Each message is prefixed by the project code "RESTEASY" followed by an ID which is unique to RESTEasy. These IDs belong to the
   following ranges:
   </p>

   <div class="table" id="d5e4641"><div class="table-title">Table 57.1. </div><div class="table-contents">
   <table style="border-collapse: collapse;border-top: 1px solid ; border-bottom: 1px solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: center; border-right: 1px  ; border-bottom: 1px  ; ">Range</th><th style="text-align: center; border-bottom: 1px  ; ">Module</th></tr></thead><tbody><tr><td style="text-align: left; border-right: 1px  ; border-bottom: 1px  ; ">2000-2999</td><td style="text-align: left; border-bottom: 1px  ; ">resteasy-jaxrs log messages</td></tr><tr><td style="text-align: left; border-right: 1px  ; border-bottom: 1px  ; ">3000-4499</td><td style="text-align: left; border-bottom: 1px  ; ">resteasy-jaxrs exception messages</td></tr><tr><td style="text-align: left; border-right: 1px  ; border-bottom: 1px  ; ">4500-4999</td><td style="text-align: left; border-bottom: 1px  ; ">resteasy-client</td></tr><tr><td style="text-align: left; border-right: 1px  ; border-bottom: 1px  ; ">5000-5499</td><td style="text-align: left; border-bottom: 1px  ; ">providers/resteasy-atom</td></tr><tr><td style="text-align: left; border-right: 1px  ; border-bottom: 1px  ; ">5500-5999</td><td style="text-align: left; border-bottom: 1px  ; ">providers/fastinfoset</td></tr><tr><td style="text-align: left; border-right: 1px  ; border-bottom: 1px  ; ">6000-6499</td><td style="text-align: left; border-bottom: 1px  ; ">providers/resteasy-html</td></tr><tr><td style="text-align: left; border-right: 1px  ; border-bottom: 1px  ; ">6500-6999</td><td style="text-align: left; border-bottom: 1px  ; ">providers/jaxb</td></tr><tr><td style="text-align: left; border-right: 1px  ; border-bottom: 1px  ; ">7500-7999</td><td style="text-align: left; border-bottom: 1px  ; ">providers/multipart</td></tr><tr><td style="text-align: left; border-right: 1px  ; border-bottom: 1px  ; ">8000-8499</td><td style="text-align: left; border-bottom: 1px  ; ">providers/resteasy-hibernatevalidator-provider</td></tr><tr><td style="text-align: left; border-right: 1px  ; border-bottom: 1px  ; ">8500-8999</td><td style="text-align: left; border-bottom: 1px  ; ">providers/resteasy-validator-provider</td></tr><tr><td style="text-align: left; border-right: 1px  ; border-bottom: 1px  ; ">9500-9999</td><td style="text-align: left; border-bottom: 1px  ; ">async-http-servlet-3.0</td></tr><tr><td style="text-align: left; border-right: 1px  ; border-bottom: 1px  ; ">10000-10499</td><td style="text-align: left; border-bottom: 1px  ; ">resteasy-cache-core</td></tr><tr><td style="text-align: left; border-right: 1px  ; border-bottom: 1px  ; ">10500-10999</td><td style="text-align: left; border-bottom: 1px  ; ">resteasy-cdi</td></tr><tr><td style="text-align: left; border-right: 1px  ; border-bottom: 1px  ; ">11000-11499</td><td style="text-align: left; border-bottom: 1px  ; ">resteasy-guice</td></tr><tr><td style="text-align: left; border-right: 1px  ; border-bottom: 1px  ; ">11500-11999</td><td style="text-align: left; border-bottom: 1px  ; ">resteasy-jsapi</td></tr><tr><td style="text-align: left; border-right: 1px  ; border-bottom: 1px  ; ">12000-12499</td><td style="text-align: left; border-bottom: 1px  ; ">resteasy-links</td></tr><tr><td style="text-align: left; border-right: 1px  ; border-bottom: 1px  ; ">12500-12999</td><td style="text-align: left; border-bottom: 1px  ; ">resteasy-servlet-initializer</td></tr><tr><td style="text-align: left; border-right: 1px  ; border-bottom: 1px  ; ">13000-13499</td><td style="text-align: left; border-bottom: 1px  ; ">resteasy-spring</td></tr><tr><td style="text-align: left; border-right: 1px  ; border-bottom: 1px  ; ">13500-13999</td><td style="text-align: left; border-bottom: 1px  ; ">security/resteasy-crypto</td></tr><tr><td style="text-align: left; border-right: 1px  ; border-bottom: 1px  ; ">14000-14499</td><td style="text-align: left; border-bottom: 1px  ; ">security/jose-jwt</td></tr><tr><td style="text-align: left; border-right: 1px  ; border-bottom: 1px  ; ">14500-14999</td><td style="text-align: left; border-bottom: 1px  ; ">security/keystone/keystone-as7</td></tr><tr><td style="text-align: left; border-right: 1px  ; border-bottom: 1px  ; ">15000-15499</td><td style="text-align: left; border-bottom: 1px  ; ">security/keystone/keystone-core</td></tr><tr><td style="text-align: left; border-right: 1px  ; border-bottom: 1px  ; ">15500-15999</td><td style="text-align: left; border-bottom: 1px  ; ">security/resteasy-oauth</td></tr><tr><td style="text-align: left; border-right: 1px  ; border-bottom: 1px  ; ">16000-16499</td><td style="text-align: left; border-bottom: 1px  ; ">security/skeleton-key-idm/skeleton-key-as7</td></tr><tr><td style="text-align: left; border-right: 1px  ; border-bottom: 1px  ; ">16500-16999</td><td style="text-align: left; border-bottom: 1px  ; ">security/skeleton-key-idm/skeleton-key-core</td></tr><tr><td style="text-align: left; border-right: 1px  ; border-bottom: 1px  ; ">17000-17499</td><td style="text-align: left; border-bottom: 1px  ; ">security/skeleton-key-idm/skeleton-key-idp</td></tr><tr><td style="text-align: left; border-right: 1px  ; border-bottom: 1px  ; ">17500-17999</td><td style="text-align: left; border-bottom: 1px  ; ">server-adapters/resteasy-jdk-http</td></tr><tr><td style="text-align: left; border-right: 1px  ; ">18500-18999</td><td style="text-align: left; ">server-adapters/resteasy-netty4</td></tr></tbody></table>
   </div></div><br class="table-break"/>

   <p>
   For example, the jaxb provider contains the interface
   </p>

   <div class="blockquote"><blockquote class="blockquote">
   <code class="classname">org.jboss.resteasy.plugins.providers.jaxb.i18.Messages</code>
   </blockquote></div>

   <p>
   which looks like
   </p>

   <pre><code class="no-highlight">
@MessageBundle(projectCode = "RESTEASY")
public interface Messages
{
   Messages MESSAGES = org.jboss.logging.Messages.getBundle(Messages.class);
   int BASE = 6500;

   @Message(id = BASE + 00, value = "Collection wrapping failed, expected root element name of {0} got {1}", format=Format.MESSAGE_FORMAT)
   String collectionWrappingFailedLocalPart(String element, String localPart);

   @Message(id = BASE + 05, value = "Collection wrapping failed, expect namespace of {0} got {1}", format=Format.MESSAGE_FORMAT)
   String collectionWrappingFailedNamespace(String namespace, String uri);
   ...
   </code></pre>

   <p>
   The value of a message is retrieved by referencing a method and passing the appropriate parameters. For example,
   </p>

   <pre><code class="no-highlight">
throw new JAXBUnmarshalException(Messages.MESSAGES.collectionWrappingFailedLocalPart(wrapped.element(), ele.getName().getLocalPart()));
   </code></pre>

   </section>

   <section class="section" id="d5e4739"><div class="titlepage"><div><div><h2 class="title">57.2. Localization</h2></div></div></div>
   

   <p>
   When RESTEasy is built with the "i18n" profile, a template properties file containing the default messages
   is created in a subdirectory of target/generated-translation-files. In the jaxb provider, for example,
   the
   </p>

   <div class="blockquote"><blockquote class="blockquote">
   Messages.i18n_locale_COUNTRY_VARIANT.properties
   </blockquote></div>

   <p>
   goes in the
   </p>

   <div class="blockquote"><blockquote class="blockquote">
   org/jboss/resteasy/plugins/providers/jaxb/i18n
   </blockquote></div>

   <p>
   directory, and the first few lines are
   </p>

   <pre><code class="no-highlight">
# Id: 6500
# Message: Collection wrapping failed, expected root element name of {0} got {1}
# @param 1: element -
# @param 2: localPart -
collectionWrappingFailedLocalPart=Collection wrapping failed, expected root element name of {0} got {1}
# Id: 6505
# Message: Collection wrapping failed, expect namespace of {0} got {1}
# @param 1: namespace -
# @param 2: uri -
collectionWrappingFailedNamespace=Collection wrapping failed, expect namespace of {0} got {1}
   </code></pre>

   <p>
   To provide the translation of the messages for a particular locale, the file should be renamed, replacing
   "locale", "COUNTRY", and "VARIANT" as appropriate (possibly omitting the latter two), and copied to the
   src/main/resources directory. In the jaxb provider, it would go in
   </p>

   <div class="blockquote"><blockquote class="blockquote">
   src/main/resources/org/jboss/resteasy/plugins/providers/jaxb/i18n
   </blockquote></div>

   <p>
   For testing purposes, each module containing a Messages interface has two sample properties files, for
   the locale "en" and the imaginary locale "xx", in the src/test/resources directory. They are copied to
   src/main/resources when the module is built and deleted when it is cleaned.
   </p>

   <p>
   The Messages.i18n_xx.properties file in the jaxb provider, for example, looks like
   </p>

   <pre><code class="no-highlight">
# Id: 6500
# Message: Collection wrapping failed, expected root element name of {0} got {1}
# @param 1: element -
# @param 2: localPart -
collectionWrappingFailedLocalPart=Collection wrapping failed, expected root element name of {0} got {1}
# Id: 6505
# Message: Collection wrapping failed, expect namespace of {0} got {1}
# @param 1: namespace -
# @param 2: uri -
collectionWrappingFailedNamespace=aaa {0} bbb {1} ccc
...
   </code></pre>

   <p>
   Note that the value of collectionWrappingFailedNamespace is modified.
   </p>
   </section>
</section>

   <section class="chapter" id="Maven_and_RESTEasy"><div class="titlepage"><div><div><h1 class="title">Chapter 58. Maven and RESTEasy</h1></div></div></div>
   
   <p>
JBoss's Maven Repository is at:
      https://repository.jboss.org/nexus/content/groups/public/
   </p>
   <p>

     RESTEasy is modularized into 20 plus components.  Each component is accessible as a Maven
     artifact.  As a convenience RESTEasy provides a BOM containing the complete set of components
     with the appropriate versions for the "stack".
   </p>
   <p>
     It is recommended to declare the BOM in your POM file, that way you will always
     be sure to get the correct version of the artifacts.  In addition, you will not need
     to declare the version of each RESTEasy artifact called out in the dependencies section.
   </p>
   <p>
     Declare the BOM file in the dependencyManagement section of the POM file like this.
     Note that Maven version 2.0.9 or higher is required to process BOM files.
   </p>
  <pre><code class="no-highlight">
    
    &lt;dependencyManagement&gt;
      &lt;dependencies&gt;
        &lt;dependency&gt;
          &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
          &lt;artifactId&gt;resteasy-bom&lt;/artifactId&gt;
          &lt;version&gt;${version.resteasy}&lt;/version&gt;
          &lt;type&gt;pom&lt;/type&gt;
          &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
      &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
  
  </code></pre>
   <p>
     Declare the specific RESTEasy artifacts you require in the dependencies section of the
     POM file like this.
   </p>
  <pre><code class="no-highlight">
    
     &lt;dependencies&gt;
       &lt;dependency&gt;
          &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
          &lt;artifactId&gt;resteasy-client&lt;/artifactId&gt;
       &lt;/dependency&gt;
        ....
   &lt;/dependencies&gt;
  
  </code></pre>
   <p>
     It is possible to reference a RESTEasy artifact version not in the current BOM
     by specifying a version in the dependency itself.
   </p>
  <pre><code class="no-highlight">
    
     &lt;dependencies&gt;
       &lt;dependency&gt;
          &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
          &lt;artifactId&gt;resteasy-client&lt;/artifactId&gt;
          &lt;version&gt;${version.some.other}&lt;version&gt;
       &lt;/dependency&gt;
        ....
   &lt;/dependencies&gt;
  
  </code></pre>
   
</section>

   <section class="chapter" id="Migration_from_older_versions"><div class="titlepage"><div><div><h1 class="title">Chapter 59. Migration from older versions</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="sect1"><a href="#d5e4766">59.1. Migration to RESTEasy 3.0 series</a></span></li><li><span class="sect1"><a href="#Migration_to_RESTEasy_3.1">59.2. Migration to RESTEasy 3.1 series</a></span></li><li><span class="sect1"><a href="#d5e4865">59.3. Migration to RESTEasy 3.5+ series</a></span></li><li><span class="sect1"><a href="#d5e4870">59.4. Migration to RESTEasy 4 series</a></span></li></ul></div>

<section class="sect1" id="d5e4766"><div class="titlepage"><div><div><h2 class="title">59.1. Migration to RESTEasy 3.0 series</h2></div></div></div>
    
    
    <p>
        Many facilities from RESTEasy 2 appear in a different form in RESTEasy 3. For example, much
        of the client framework in RESTEasy 2 is formalized, in modified form, in JAX-RS 2.0. RESTEasy
        versions 3.0.x implement both the older deprecated form and the newer conformant form. The
        deprecated form is moved to legacy module in RESTEasy 3.1 and finally removed in RESTEasy 4.
        For more information on upgrading from various deprecated facilities in RESTEasy 2, see
        <a class="ulink" href="http://docs.jboss.org/resteasy/docs/resteasy-upgrade-guide-en-US.pdf">http://docs.jboss.org/resteasy/docs/resteasy-upgrade-guide-en-US.pdf</a>
    </p>
</section>



<section class="sect1" id="Migration_to_RESTEasy_3.1"><div class="titlepage"><div><div><h2 class="title">59.2. Migration to RESTEasy 3.1 series</h2></div></div></div>
    

    <p>
    RESTEasy 3.1.0.Final release comes with many changes compared to previous 3.0 point releases.
    User discernible changes in RESTEasy 3.1.0.Final include
    </p>
    
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">module reorganization</li><li class="listitem">package reorganization</li><li class="listitem">new features</li><li class="listitem">minor behavioral changes</li><li class="listitem">miscellaneous changes</li></ul></div>
    
    <p>
    In this chapter we focus on changes that might cause existing code to fail or behave in new ways.
    The audience for this discussion may be partitioned into three subsets, depending on the version
    of RESTEasy currently in use, the API currently in use, and the API to be used after an upgrade
    to RESTEasy 3.1. The following APIs are available:
    </p>
    
    <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
      <p><span class="bold"><strong>RESTEasy 2</strong></span>: RESTEasy 2 conforms to the JAX-RS 1 specification, and adds a
      variety of additional facilities, such as a client API, a caching system, an interceptor framework, etc. 
      All of these user facing classes and interfaces comprise the RESTEasy 2 API.</p>
      </li><li class="listitem">
      <p><span class="bold"><strong>RESTEasy 3</strong></span>: RESTEasy 3 conforms to the JAX-RS 2 specification, and adds some additional
      facilities. Many of the non-spec facilities from the RESTEasy 2 API are formalized, in altered form,
      in JAX-RS 2, in which case the older facilites are deprecated. The non-deprecated user facing classes and interfaces in
      RESTEasy 3 comprise the RESTEasy 3 API.</p>
      </li></ol></div>
    
    <p>
    These definitions are rather informal and imprecise, since the user facing classes / interfaces in Resteasy
    3.0.19.Final, for example, are a proper superset of the user facing classes / interfaces in RESTEasy 3.0.1.Final.
    For this discussion, we identify the API with the version currently in use in a given project.
    </p>
    
    <p>
    Now, there are three potential target audiences of users planning to upgrade to RESTEasy 3.1.0.Final:
    </p>
    
    <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
      <p>Those currently using RESTEasy API 3 with some RESTEasy 3.0.x release</p>
      </li><li class="listitem">
      <p>Those currently using RESTEasy API 2 with some RESTEasy 2.x or 3.0.x release and planning
      to upgrade to RESTEasy API 3</p>
      </li><li class="listitem">
      <p>Those currently using RESTEasy API 2 with some RESTEasy 2.x or 3.0.x release and planning
      to continue to use RESTEasy API 2</p>
      </li></ol></div>
    
    <p>
    Of these, users in Group 2 have the most work to do in upgrading from RESTEasy API 2 to RESTEasy API 3.
    They should consult the separate guide
    <a class="ulink" href="http://docs.jboss.org/resteasy/docs/resteasy-upgrade-guide-en-US.pdf">Upgrading from RESTEasy 2 to RESTEasy 3</a>.
    </p>

    <p>
    Ideally, users in Groups 1 and 3 might make some changes to take advantage of new features but would have
    no changes forced on them by reorganization or altered behavior. Indeed, that is almost the case, but there
    are a few changes that they should be aware of.
    </p>
    
    <section class="sect1" id="d5e4799"><div class="titlepage"><div><div><h2 class="title">1. Upgrading with RESTEasy 3 API</h2></div></div></div>
    
    
    <p>
    All RESTEasy changes are documented in JIRA issues. Issues that describe detectable changes in
    release 3.1.0.Final that might impact existing applications include
    </p>
    
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
      <a class="ulink" href="https://issues.jboss.org/browse/RESTEASY-1341">RESTEASY-1341: Build method of org.jboss.resteasy.client.jaxrs.internal.ClientInvocationBuilder always return the same instance.</a>
      <p>
      When a <code class="methodname">build()</code> method from
      </p>
      <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="classname">org.jboss.resteasy.client.jaxrs.internal.ClientInvocationBuilder</code> in resteasy-client,</li><li class="listitem"><code class="classname">org.jboss.resteasy.specimpl.LinkBuilderImpl</code> in resteasy-jaxrs,</li><li class="listitem"><code class="classname">org.jboss.resteasy.specimpl.ResteasyUriBuilder</code> in resteasy-jaxrs</li></ul></div>
      <p>
      is called, it will return a new object. This behavior might be seen indirectly. For example,
      </p>
      <pre><code class="no-highlight">
Builder builder = client.target(generateURL(path)).request();
...
Link link = new LinkBuilderImpl().uri(href).build();
...
URI uri = uriInfo.getBaseUriBuilder().path("test").build();
      </code></pre>
      </li><li class="listitem">
      <a class="ulink" href="https://issues.jboss.org/browse/RESTEASY-1433">RESTEASY-1433: Compile with JDK 1.8 source/target version</a>
      <p>
      As it says. Depending on the application, it might be necessary to recompile with a target of JDK 1.8 so that calls to RESTEasy code
      can work.
      </p>
      </li><li class="listitem">
      <a class="ulink" href="https://issues.jboss.org/browse/RESTEASY-1484">RESTEASY-1484: CVE-2016-6346: Abuse of GZIPInterceptor in can lead to denial of service attack</a>
      <p>
      Prior to release 3.1.0.Final, the default behavior of RESTEasy was to use GZIP to compress and decompress messages
      whenever "gzip" appeared in the Content-Encoding header.
      However, decompressing messages can lead to security issues, so, as of release 3.1.0.Final, GZIP compression has to
      be enabled explicitly. For details, see Chapter <a class="link" href="#gzip" title="Chapter 32. Content encoding">GZIP Compression/Decompression</a>.
      </p>
      <p><span class="bold"><strong>Note.</strong></span> Because of some package reorganization due to RESTEASY-1531 (see below),
      the GZIP interceptors, which used to be in package <code class="classname">org.jboss.resteasy.plugins.interceptors.encoding</code> are
      now in <code class="classname">org.jboss.resteasy.plugins.interceptors</code>.</p>
      </li><li class="listitem">
      <a class="ulink" href="https://issues.jboss.org/browse/RESTEASY-1531">RESTEASY-1531: Restore removed RESTEasy internal classes into a deprecated/disabled module</a>
      <p>
      This issue is related to refactoring deprecated elements of the RESTEasy 2 API into a separate module, and, ideally,
      would have no bearing at all on RESTEasy 3. However, a reorganization of packages has led to moving some
      non-deprecated API elements in the resteasy-jaxrs module:
      </p>
      
      <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
          <div class="literallayout"><p><code class="classname">org.jboss.resteasy.client.ClientURI</code> is now<br/>
          <code class="classname">org.jboss.resteasy.annotations.ClientURI</code></p></div>
        </li><li class="listitem">
          <div class="literallayout"><p><code class="classname">org.jboss.resteasy.core.interception.JaxrsInterceptorRegistryListener</code> is now<br/>
<code class="classname">org.jboss.resteasy.core.interception.jaxrs.JaxrsInterceptorRegistryListener</code></p></div>
        </li><li class="listitem">
	      <div class="literallayout"><p><code class="classname">org.jboss.resteasy.spi.interception.DecoratorProcessor</code> is now<br/>
<code class="classname">org.jboss.resteasy.spi.DecoratorProcessor</code></p></div>
	    </li><li class="listitem">
          <div class="literallayout"><p>All of the dynamic features and interceptors in the package<br/>
<code class="classname">org.jboss.resteasy.plugins.interceptors.encoding</code> are now in<br/>
<code class="classname">org.jboss.resteasy.plugins.interceptors</code></p></div>
        </li></ul></div>
	  </li></ul></div>
    </section>

    <section class="sect1" id="d5e4847"><div class="titlepage"><div><div><h2 class="title">2. Upgrading with RESTEasy 2 API</h2></div></div></div>
    
    
    <p>
    Most of the deprecated classes and interfaces
    from RESTEasy 2 have been segregated in a separate module, resteasy-legacy, as of release 3.1.0.Final.
    A few remain in module resteasy-jaxrs for technical reasons. Eventually, all such classes and interfaces will be
    removed from RESTEasy. Most of the relocated elements are internal, so ensuring that resteasy-legacy is on the
    classpath will make most changes undetectable. One way to do that, of course, is to include it in an application's
    WAR. In the context of WildFly, it is also possible to use a jboss-deployment-structure.xml file in the 
    WEB-INF directory of your WAR file. For example:
    </p>
    
        <pre><code class="no-highlight">
&lt;jboss-deployment-structure&gt;
    &lt;deployment&gt;
        &lt;dependencies&gt;
            &lt;module name="org.jboss.resteasy.resteasy-legacy"/&gt;
        &lt;/dependencies&gt;
    &lt;/deployment&gt;
&lt;/jboss-deployment-structure&gt;</code></pre>

    <p>
    There are a few API classes and interfaces from resteasy-jaxrs that have moved to a new package
    in resteasy-legacy. These are
    </p>
    
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><div class="literallayout"><p><code class="classname">org.jboss.resteasy.annotations.ClientResponseType</code> is now<br/>
<code class="classname">org.jboss.resteasy.annotations.legacy.ClientResponseType</code></p></div>
      </li><li class="listitem"><div class="literallayout"><p><code class="classname">org.jboss.resteasy.spi.Link</code> is now<br/>
	    <code class="classname">org.jboss.resteasy.client.Link</code></p></div>
      </li><li class="listitem"><div class="literallayout"><p><code class="classname">org.jboss.resteasy.spi.LinkHeader</code> is now<br/>
	    <code class="classname">org.jboss.resteasy.client.LinkHeader</code></p></div>
      </li></ul></div>
    </section>

</section>


<section class="sect1" id="d5e4865"><div class="titlepage"><div><div><h2 class="title">59.3. Migration to RESTEasy 3.5+ series</h2></div></div></div>
    
    <p>
      RESTEasy 3.5 series is a spin-off of the old RESTEasy 3.0 series, featuring JAX-RS 2.1 implementation.
    </p>
    <p>
      The reason why 3.5 comes from 3.0 instead of the 3.1 / 4.0 development streams is basically providing
      users with a selection of RESTEasy 4 critical / strategic new features, while ensuring full backward
      compatiblity. As a consequence, no major issues are expected when upgrading RESTEasy from 3.0.x to 3.5.x.
      The 3.6 and all other 3.x minors after that are backward compatible evolutions of 3.5 series.
    </p>
    <p>
      The natural upgrade path for users already on RESTEasy 3.1 series is straight to RESTEasy 4 instead.
    </p>
</section>

<section class="sect1" id="d5e4870"><div class="titlepage"><div><div><h2 class="title">59.4. Migration to RESTEasy 4 series</h2></div></div></div>
    
    <p>
      User migrating from RESTEasy 3.0 and 3.5+ series should be aware of the changes mentioned in the
      <a class="xref" href="#Migration_to_RESTEasy_3.1" title="59.2. Migration to RESTEasy 3.1 series">Section 59.2, “Migration to RESTEasy 3.1 series”</a>. In addition to that,
      the aspects from the following sections are to be considered.
    </p>
    <section class="section" id="d5e4874"><div class="titlepage"><div><div><h2 class="title">1. Public / private API</h2></div></div></div>
        
        <p>
            The <code class="classname">resteasy-jaxrs</code> and <code class="classname">resteasy-client</code> modules
            in RESTEasy 3 contain most of the framework classes and
            there's no real demarcation between what is internal implementation detail and what is for public
            consumption. In WildFly, the artifact archives from those modules are also included in a public module.
            Given the common expectation of full backward compatibility of whatever comes from public modules,
            to allow for easier project evolution and maintenance, in RESTEasy 4.0.0.Final those big components
            have been split as follows: 
        </p>
        <section class="section" id="d5e4879"><div class="titlepage"><div><div><h3 class="title">1.1. resteasy-core-spi</h3></div></div></div>
          
          <p>
            The public classes of the former <code class="classname">resteasy-jaxrs</code> module; the following packages
            are included:
          </p>
          <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="classname">org.jboss.resteasy.annotations</code></li><li class="listitem"><code class="classname">org.jboss.resteasy.api.validation</code></li><li class="listitem"><code class="classname">org.jboss.resteasy.spi</code></li><li class="listitem"><code class="classname">org.jboss.resteasy.plugins.providers.validation</code></li></ul></div>
        </section>
        <section class="section" id="d5e4892"><div class="titlepage"><div><div><h3 class="title">1.2. resteasy-core</h3></div></div></div>
          
          <p>
            The internal details of the former <code class="classname">resteasy-jaxrs</code> module, including classes
            from the following packages:
          </p>
          <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="classname">org.jboss.resteasy.core</code></li><li class="listitem"><code class="classname">org.jboss.resteasy.mock</code></li><li class="listitem"><code class="classname">org.jboss.resteasy.plugins</code></li><li class="listitem"><code class="classname">org.jboss.resteasy.specimpl</code></li><li class="listitem"><code class="classname">org.jboss.resteasy.tracing</code></li><li class="listitem"><code class="classname">org.jboss.resteasy.util</code></li></ul></div>
        </section>
        <section class="section" id="d5e4909"><div class="titlepage"><div><div><h3 class="title">1.3. resteasy-client-api</h3></div></div></div>
          
          <p>
            The public classes from the former <code class="classname">resteasy-client</code> module, basically whatever
            is used for configuring the RESTEasy client additions:
          </p>
          <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="classname">ClientHttpEngine</code> and <code class="classname">ClientHttpEngineBuilder</code></li><li class="listitem"><code class="classname">ProxyBuilder</code> and <code class="classname">ProxyConfig</code></li><li class="listitem"><code class="classname">ResteasyClient</code></li><li class="listitem"><code class="classname">ResteasyClientBuilder</code></li><li class="listitem"><code class="classname">ResteasyWebTarget</code></li></ul></div>
        </section>
        <section class="section" id="d5e4926"><div class="titlepage"><div><div><h3 class="title">1.4. resteasy-client</h3></div></div></div>
          
          <p>
            The remainings of the former <code class="classname">resteasy-client</code> module, internal details.
          </p>
        </section>
        <p>
          As a consequence of the split, all modules except <code class="classname">resteasy-core-spi</code> and
          <code class="classname">resteasy-client-api</code> are effectively private / internal. User applications and
          integration code should not directly rely on classes from those modules, which can be changed without
          going through any formal deprecation process.
        </p>
        <p>
          Unfortunately, the refactoring that led to this implied some unavoidable class moves and changes breaking backward
          compatibility. A detailed list of the potentially problematic changes is available on the
          <a class="ulink" href="https://github.com/resteasy/Resteasy/pull/1697">refactoring PR</a>.
        </p>
    </section>
    <section class="section" id="d5e4935"><div class="titlepage"><div><div><h2 class="title">2. Deprecated classes and modules removal</h2></div></div></div>
        
        <p>
          All classes and modules that were deprecated in RESTEasy 3 have been dropped in 4. In particular, this
          includes the legacy modules (<code class="classname">resteasy-legacy</code>, <code class="classname">security-legacy</code>)
          that were introduced in 3.1.
        </p>
        <p>
          In addition to the legacy modules, few other modules have been dropped for multiple different reasons,
          including dependency on unsupported / abandoned libraries, better options available, etc:
        </p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="classname">resteasy-jackson-provider</code>, users should rely on <code class="classname">resteasy-jackson2-provider</code> instead;</li><li class="listitem"><code class="classname">resteasy-jettison-provider</code>, users should rely on <code class="classname">resteasy-jackson2-provider</code> instead;</li><li class="listitem"><code class="classname">abdera-atom-provider</code>;</li><li class="listitem"><code class="classname">resteasy-yaml-provider</code>;</li><li class="listitem"><code class="classname">resteasy-rx-java</code>, users should rely on <code class="classname">resteasy-rx-java2</code> instead;</li><li class="listitem"><code class="classname">tjws</code>.</li></ul></div>
        <p>
          The <code class="classname">resteasy-validator-provider-11</code> is also gone, with the
          <code class="classname">resteasy-validator-provider</code> one now supporting Bean Validation 2.0.
        </p>
    </section>
    <section class="section" id="d5e4960"><div class="titlepage"><div><div><h2 class="title">3. Behavior changes</h2></div></div></div>
        
        <p>
          With the <code class="classname">ClientHttpEngine</code> based on Apache HTTP Client 4.0 having gone (it
          was previously deprecated) and the engine based on version 4.3 of the same library being the default,
          the user might want to double check the notes about connection close in <a class="xref" href="#apache_4_3" title="51.3.4. Apache HTTP Client 4.3 APIs">Section 51.3.4, “Apache HTTP Client 4.3 APIs”</a>.
        </p>
        <p>
          The conversion of <code class="classname">String</code> ojects to <code class="classname">MediaType</code> objects is quite
          common in RESTEasy; for performances reasons a cache has been added to store the results of that conversion;
          by default the cache keeps the result of 200 conversions, but the number can be configured by setting the
          <code class="classname">org.jboss.resteasy.max_mediatype_cache_size</code> system property.
        </p>
    </section>
    <section class="section" id="d5e4969"><div class="titlepage"><div><div><h2 class="title">4. Other changes</h2></div></div></div>
        
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                In releases 3.x, when bean validation (<a class="xref" href="#Validation" title="Chapter 56. Validation">Chapter 56, <em>Validation</em></a>) threw instances of exceptions
                <p>
                    </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="classname">javax.validation.ConstraintDefinitionException</code>,</li><li class="listitem"><code class="classname">javax.validation.ConstraintDeclarationException</code>, or</li><li class="listitem"><code class="classname">javax.validation.GroupDefinitionException</code>,</li></ul></div><p>
                    they were wrapped in a
                    <code class="classname">org.jboss.resteasy.api.validation.Resteasy.ResteasyViolationException</code>,
                    which <code class="classname">org.jboss.resteasy.api.validation.ResteasyViolationExceptionMapper</code>,
                    the built-in implementation of
                    <code class="classname">javax.ws.rs.ext.ExceptionMapper&lt;javax.validation.ValidationException&gt;</code>,
                    then turned into descriptive text.
                    As of release 4.0.0, instances of <code class="classname">ConstraintDefinitionException</code>, etc., are thrown as is.
                    They are still caught by <code class="classname">ResteasyViolationExceptionMapper</code>, so, in general, there is
                    no detectable change. It should be noted, however, that an implementation of
                    <code class="classname">ExceptionMapper&lt;ResteasyViolationException&gt;</code>, which, prior to release
                    4.0.0, would have caught wrapped instances of <code class="classname">ConstraintDefinitionException</code>,
                    will not catch unwrapped instances.
                </p>
            </li><li class="listitem">
              The <code class="classname">ResteasyProviderFactory</code> is now an abstract class and is meant to be created using
              its <code class="classname">getInstance()</code> and <code class="classname">newInstance()</code> methods. Moreover, on client
              side, the resolution of the current instance is cached for each thread local context classloader.
            </li><li class="listitem">
              The <code class="classname">ResteasyClient</code> and <code class="classname">ResteasyClientBuilder</code> are now abstract
              classes (from <code class="classname">resteasy-client-api</code>) and are not meant for user direct instantiation;
              plain JAX-RS API usage is expected instead:
              <pre><code class="no-highlight">
//ResteasyClient client = new ResteasyClientBuilder().build(); NO!
//if plan JAX-RS is enough ...
Client client = ClientBuilder.newClient();
...
//if RESTEasy API is needed ...
ResteasyClient client = (ResteasyClient)ClientBuilder.newClient();


//ResteasyClientBuilder builder = new ResteasyClientBuilder(); NO!
//if plan JAX-RS is enough ...
ClientBuilder builder = ClientBuilder.newBuilder();
...
//if RESTEasy API is needed ...
ResteayClientBuilder builder = (ResteasyClientBuilder)ClientBuilder.newBuilder();
              </code></pre>
            </li><li class="listitem">
              The package <code class="classname">org.jboss.resteasy.plugins.stats</code> (which contains a resource and some related classes) has
              been moved out of the <code class="classname">resteasy-jaxb-provider</code> module into a <code class="classname">new resteasy-stats</code> module.
            </li></ul></div>
    </section>
</section>
</section>

   <section class="chapter" id="REST_BOOKS"><div class="titlepage"><div><div><h1 class="title">Chapter 60. Books You Can Read</h1></div></div></div>

<p>There are a number of great books that you can learn REST and JAX-RS from</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
<a class="ulink" href="http://oreilly.com/catalog/9780596529260/">RESTful Web Services</a> by Leonard Richardson and Sam Ruby.  A great introduction to REST.
</li><li class="listitem">
<a class="ulink" href="http://oreilly.com/catalog/9780596158040/">RESTful Java with JAX-RS</a> by Bill Burke.  Overview of REST and detailed explanation of JAX-RS.  
Book examples are distributed with RESTEasy.
</li><li class="listitem">
<a class="ulink" href="http://oreilly.com/catalog/9780596808679/">RESTful Web Services Cookbook</a> by Subbu Allamaraju and Mike Amundsen.  Detailed cookbook on how to design RESTful services.
</li></ul></div>
</section>

</div><script type="text/javascript" src="highlight.js/highlight.pack.js"> </script><script type="text/javascript">hljs.initHighlightingOnLoad();</script></body></html>